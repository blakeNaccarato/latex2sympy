
// Generated from LATEX.g4 by ANTLR 4.11.1



#include "LATEXParser.h"


using namespace antlrcpp;
using namespace latex2antlr;

using namespace antlr4;

namespace {

struct LATEXParserStaticData final {
  LATEXParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  LATEXParserStaticData(const LATEXParserStaticData&) = delete;
  LATEXParserStaticData(LATEXParserStaticData&&) = delete;
  LATEXParserStaticData& operator=(const LATEXParserStaticData&) = delete;
  LATEXParserStaticData& operator=(LATEXParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag latexParserOnceFlag;
LATEXParserStaticData *latexParserStaticData = nullptr;

void latexParserInitialize() {
  assert(latexParserStaticData == nullptr);
  auto staticData = std::make_unique<LATEXParserStaticData>(
    std::vector<std::string>{
      "accent_symbol", "math", "matrix", "matrix_row", "relation", "relation_list", 
      "relation_list_content", "equality", "expr", "additive", "mp", "mp_nofunc", 
      "unary", "unary_nofunc", "postfix", "postfix_nofunc", "postfix_op", 
      "eval_at", "eval_at_sub", "eval_at_sup", "exp", "exp_nofunc", "comp", 
      "comp_nofunc", "group", "abs_group", "floor_group", "ceil_group", 
      "accent", "atom_expr", "atom", "mathit", "mathit_text", "frac", "binom", 
      "func_normal_functions_single_arg", "func_normal_functions_multi_arg", 
      "func_operator_names_single_arg", "func_operator_names_multi_arg", 
      "func_normal_single_arg", "func_normal_multi_arg", "func", "args", 
      "limit_sub", "func_single_arg", "func_single_arg_noparens", "func_multi_arg", 
      "func_multi_arg_noparens", "subexpr", "supexpr", "subeq"
    },
    std::vector<std::string>{
      "", "", "'\\$'", "'+'", "'-'", "'*'", "'/'", "'('", "')'", "'\\lgroup'", 
      "'\\rgroup'", "'{'", "'}'", "'\\{'", "'\\}'", "'\\lbrace'", "'\\rbrace'", 
      "'['", "']'", "'\\lbrack'", "'\\rbrack'", "'|'", "'\\lvert'", "'\\rvert'", 
      "'\\vert'", "'\\lfloor'", "'\\rfloor'", "'\\llcorner'", "'\\lrcorner'", 
      "'\\lceil'", "'\\rceil'", "'\\ulcorner'", "'\\urcorner'", "'\\left'", 
      "'\\right'", "'\\mleft'", "'\\mright'", "'\\lim'", "", "'\\int'", 
      "'\\sum'", "'\\prod'", "'\\log'", "'\\ln'", "'\\exp'", "'\\sin'", 
      "'\\cos'", "'\\tan'", "'\\csc'", "'\\sec'", "'\\cot'", "'\\arcsin'", 
      "'\\arccos'", "'\\arctan'", "'\\arccsc'", "'\\arcsec'", "'\\arccot'", 
      "'\\sinh'", "'\\cosh'", "'\\tanh'", "'\\arsinh'", "'\\arcosh'", "'\\artanh'", 
      "'\\arcsinh'", "'\\arccosh'", "'\\arctanh'", "'arsinh'", "'arcsinh'", 
      "'arcosh'", "'arccosh'", "'artanh'", "'arctanh'", "'gcd'", "'lcm'", 
      "'floor'", "'ceil'", "'\\sqrt'", "'\\gcd'", "'\\lcm'", "'\\floor'", 
      "'\\ceil'", "'\\max'", "'\\min'", "'\\times'", "'\\cdot'", "'\\div'", 
      "'\\frac'", "'\\binom'", "'\\choose'", "'\\mod'", "'\\mathit'", "'\\operatorname'", 
      "'matrix'", "'pmatrix'", "'bmatrix'", "", "", "", "'&'", "'\\\\'", 
      "'\\overline'", "'\\bar'", "'_'", "'^'", "':'", "';'", "','", "'.'", 
      "", "", "'E'", "", "", "", "", "", "'='", "'<'", "", "'>'", "", "", 
      "'!'"
    },
    std::vector<std::string>{
      "", "WS", "DOLLAR_SIGN", "ADD", "SUB", "MUL", "DIV", "L_PAREN", "R_PAREN", 
      "L_GROUP", "R_GROUP", "L_BRACE", "R_BRACE", "L_BRACE_VISUAL", "R_BRACE_VISUAL", 
      "L_BRACE_CMD", "R_BRACE_CMD", "L_BRACKET", "R_BRACKET", "L_BRACK", 
      "R_BRACK", "BAR", "L_VERT", "R_VERT", "VERT", "L_FLOOR", "R_FLOOR", 
      "LL_CORNER", "LR_CORNER", "L_CEIL", "R_CEIL", "UL_CORNER", "UR_CORNER", 
      "L_LEFT", "R_RIGHT", "ML_LEFT", "MR_RIGHT", "FUNC_LIM", "LIM_APPROACH_SYM", 
      "FUNC_INT", "FUNC_SUM", "FUNC_PROD", "FUNC_LOG", "FUNC_LN", "FUNC_EXP", 
      "FUNC_SIN", "FUNC_COS", "FUNC_TAN", "FUNC_CSC", "FUNC_SEC", "FUNC_COT", 
      "FUNC_ARCSIN", "FUNC_ARCCOS", "FUNC_ARCTAN", "FUNC_ARCCSC", "FUNC_ARCSEC", 
      "FUNC_ARCCOT", "FUNC_SINH", "FUNC_COSH", "FUNC_TANH", "FUNC_ARSINH", 
      "FUNC_ARCOSH", "FUNC_ARTANH", "FUNC_ARCSINH", "FUNC_ARCCOSH", "FUNC_ARCTANH", 
      "FUNC_ARSINH_NAME", "FUNC_ARCSINH_NAME", "FUNC_ARCOSH_NAME", "FUNC_ARCCOSH_NAME", 
      "FUNC_ARTANH_NAME", "FUNC_ARCTANH_NAME", "FUNC_GCD_NAME", "FUNC_LCM_NAME", 
      "FUNC_FLOOR_NAME", "FUNC_CEIL_NAME", "FUNC_SQRT", "FUNC_GCD", "FUNC_LCM", 
      "FUNC_FLOOR", "FUNC_CEIL", "FUNC_MAX", "FUNC_MIN", "CMD_TIMES", "CMD_CDOT", 
      "CMD_DIV", "CMD_FRAC", "CMD_BINOM", "CMD_CHOOSE", "CMD_MOD", "CMD_MATHIT", 
      "CMD_OPERATORNAME", "MATRIX_TYPE_MATRIX", "MATRIX_TYPE_PMATRIX", "MATRIX_TYPE_BMATRIX", 
      "MATRIX_TYPES", "CMD_MATRIX_START", "CMD_MATRIX_END", "MATRIX_DEL_COL", 
      "MATRIX_DEL_ROW", "ACCENT_OVERLINE", "ACCENT_BAR", "UNDERSCORE", "CARET", 
      "COLON", "SEMICOLON", "COMMA", "PERIOD", "DIFFERENTIAL", "EXP_E", 
      "E_NOTATION_E", "LETTER_NO_E", "NUMBER", "FRACTION_NUMBER", "SCI_NOTATION_NUMBER", 
      "E_NOTATION", "EQUAL", "LT", "LTE", "GT", "GTE", "UNEQUAL", "BANG", 
      "PERCENT_NUMBER", "GREEK_CMD", "SYMBOL", "VARIABLE"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,126,948,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,1,0,1,0,1,1,1,1,3,1,107,8,1,1,2,1,2,1,2,1,2,5,2,113,8,2,
  	10,2,12,2,116,9,2,1,2,1,2,1,3,1,3,1,3,5,3,123,8,3,10,3,12,3,126,9,3,1,
  	4,1,4,1,4,1,4,1,4,1,4,5,4,134,8,4,10,4,12,4,137,9,4,1,5,1,5,1,5,1,5,1,
  	5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,
  	1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,
  	5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,
  	1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,
  	5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,
  	1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,
  	5,1,5,1,5,1,5,3,5,252,8,5,1,6,1,6,1,6,1,6,1,6,5,6,259,8,6,10,6,12,6,262,
  	9,6,1,6,1,6,1,6,1,6,1,6,5,6,269,8,6,10,6,12,6,272,9,6,3,6,274,8,6,1,7,
  	1,7,1,7,1,7,1,8,1,8,1,9,1,9,1,9,1,9,1,9,1,9,5,9,288,8,9,10,9,12,9,291,
  	9,9,1,10,1,10,1,10,1,10,1,10,1,10,5,10,299,8,10,10,10,12,10,302,9,10,
  	1,11,1,11,1,11,1,11,1,11,1,11,5,11,310,8,11,10,11,12,11,313,9,11,1,12,
  	1,12,1,12,4,12,318,8,12,11,12,12,12,319,3,12,322,8,12,1,13,1,13,1,13,
  	1,13,5,13,328,8,13,10,13,12,13,331,9,13,3,13,333,8,13,1,14,1,14,5,14,
  	337,8,14,10,14,12,14,340,9,14,1,15,1,15,5,15,344,8,15,10,15,12,15,347,
  	9,15,1,16,1,16,3,16,351,8,16,1,17,1,17,1,17,1,17,1,17,1,17,3,17,359,8,
  	17,1,18,1,18,1,18,1,18,3,18,365,8,18,1,18,1,18,1,19,1,19,1,19,1,19,3,
  	19,373,8,19,1,19,1,19,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,
  	20,3,20,387,8,20,1,20,3,20,390,8,20,5,20,392,8,20,10,20,12,20,395,9,20,
  	1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,3,21,407,8,21,1,21,
  	3,21,410,8,21,5,21,412,8,21,10,21,12,21,415,9,21,1,22,1,22,1,22,1,22,
  	1,22,1,22,1,22,1,22,1,22,3,22,426,8,22,1,23,1,23,1,23,1,23,1,23,1,23,
  	1,23,1,23,3,23,436,8,23,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,24,3,24,550,8,24,1,25,1,25,1,25,1,25,1,25,1,25,
  	1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,
  	1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,
  	1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,
  	3,25,600,8,25,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,
  	1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,
  	1,26,1,26,1,26,1,26,1,26,1,26,1,26,3,26,634,8,26,1,27,1,27,1,27,1,27,
  	1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,
  	1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,
  	3,27,668,8,27,1,28,1,28,1,28,1,28,1,28,1,29,1,29,1,29,3,29,678,8,29,1,
  	29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,3,29,688,8,29,1,30,1,30,1,30,1,
  	30,1,30,1,30,1,30,1,30,1,30,1,30,3,30,700,8,30,1,31,1,31,1,31,1,31,1,
  	31,1,32,4,32,708,8,32,11,32,12,32,709,1,33,1,33,1,33,1,33,1,33,1,33,1,
  	33,1,33,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,35,1,35,1,36,1,36,1,
  	37,1,37,1,38,1,38,1,39,1,39,1,39,1,39,1,39,1,39,3,39,742,8,39,1,40,1,
  	40,1,40,1,40,1,40,1,40,3,40,750,8,40,1,41,1,41,3,41,754,8,41,1,41,3,41,
  	757,8,41,1,41,3,41,760,8,41,1,41,3,41,763,8,41,3,41,765,8,41,1,41,3,41,
  	768,8,41,1,41,1,41,1,41,3,41,773,8,41,1,41,1,41,1,41,3,41,778,8,41,1,
  	41,1,41,1,41,3,41,783,8,41,1,41,1,41,1,41,3,41,788,8,41,1,41,1,41,3,41,
  	792,8,41,1,41,3,41,795,8,41,1,41,3,41,798,8,41,1,41,3,41,801,8,41,3,41,
  	803,8,41,1,41,3,41,806,8,41,1,41,1,41,1,41,3,41,811,8,41,1,41,1,41,1,
  	41,3,41,816,8,41,1,41,1,41,1,41,3,41,821,8,41,1,41,1,41,1,41,3,41,826,
  	8,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,
  	1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,3,41,849,8,41,1,41,3,41,852,8,
  	41,1,41,1,41,1,41,3,41,857,8,41,1,41,1,41,1,41,1,41,1,41,3,41,864,8,41,
  	1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,3,41,877,8,41,
  	1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,3,41,887,8,41,3,41,889,8,41,1,
  	42,1,42,1,42,1,42,1,42,3,42,896,8,42,1,43,1,43,1,43,1,43,1,43,1,43,1,
  	43,1,43,1,43,3,43,907,8,43,1,43,1,43,1,44,1,44,1,45,1,45,1,46,1,46,1,
  	46,1,46,1,46,3,46,920,8,46,1,47,1,47,1,48,1,48,1,48,1,48,1,48,3,48,929,
  	8,48,1,48,1,48,3,48,933,8,48,1,49,1,49,1,49,1,49,1,49,1,49,3,49,941,8,
  	49,1,50,1,50,1,50,1,50,1,50,1,50,0,6,8,18,20,22,40,42,51,0,2,4,6,8,10,
  	12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,
  	58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,0,
  	12,1,0,100,101,1,0,116,121,1,0,3,4,4,0,5,6,83,85,89,89,104,104,1,0,109,
  	111,1,0,87,88,2,0,42,65,79,80,2,0,77,78,81,82,2,0,66,71,74,75,1,0,72,
  	73,1,0,40,41,2,0,111,111,124,124,1059,0,102,1,0,0,0,2,106,1,0,0,0,4,108,
  	1,0,0,0,6,119,1,0,0,0,8,127,1,0,0,0,10,251,1,0,0,0,12,273,1,0,0,0,14,
  	275,1,0,0,0,16,279,1,0,0,0,18,281,1,0,0,0,20,292,1,0,0,0,22,303,1,0,0,
  	0,24,321,1,0,0,0,26,332,1,0,0,0,28,334,1,0,0,0,30,341,1,0,0,0,32,350,
  	1,0,0,0,34,352,1,0,0,0,36,360,1,0,0,0,38,368,1,0,0,0,40,376,1,0,0,0,42,
  	396,1,0,0,0,44,425,1,0,0,0,46,435,1,0,0,0,48,549,1,0,0,0,50,599,1,0,0,
  	0,52,633,1,0,0,0,54,667,1,0,0,0,56,669,1,0,0,0,58,677,1,0,0,0,60,699,
  	1,0,0,0,62,701,1,0,0,0,64,707,1,0,0,0,66,711,1,0,0,0,68,719,1,0,0,0,70,
  	727,1,0,0,0,72,729,1,0,0,0,74,731,1,0,0,0,76,733,1,0,0,0,78,741,1,0,0,
  	0,80,749,1,0,0,0,82,888,1,0,0,0,84,895,1,0,0,0,86,897,1,0,0,0,88,910,
  	1,0,0,0,90,912,1,0,0,0,92,919,1,0,0,0,94,921,1,0,0,0,96,923,1,0,0,0,98,
  	934,1,0,0,0,100,942,1,0,0,0,102,103,7,0,0,0,103,1,1,0,0,0,104,107,3,8,
  	4,0,105,107,3,10,5,0,106,104,1,0,0,0,106,105,1,0,0,0,107,3,1,0,0,0,108,
  	109,5,96,0,0,109,114,3,6,3,0,110,111,5,99,0,0,111,113,3,6,3,0,112,110,
  	1,0,0,0,113,116,1,0,0,0,114,112,1,0,0,0,114,115,1,0,0,0,115,117,1,0,0,
  	0,116,114,1,0,0,0,117,118,5,97,0,0,118,5,1,0,0,0,119,124,3,16,8,0,120,
  	121,5,98,0,0,121,123,3,16,8,0,122,120,1,0,0,0,123,126,1,0,0,0,124,122,
  	1,0,0,0,124,125,1,0,0,0,125,7,1,0,0,0,126,124,1,0,0,0,127,128,6,4,-1,
  	0,128,129,3,16,8,0,129,135,1,0,0,0,130,131,10,2,0,0,131,132,7,1,0,0,132,
  	134,3,8,4,3,133,130,1,0,0,0,134,137,1,0,0,0,135,133,1,0,0,0,135,136,1,
  	0,0,0,136,9,1,0,0,0,137,135,1,0,0,0,138,252,3,12,6,0,139,140,5,7,0,0,
  	140,141,3,12,6,0,141,142,5,8,0,0,142,252,1,0,0,0,143,144,5,9,0,0,144,
  	145,3,12,6,0,145,146,5,10,0,0,146,252,1,0,0,0,147,148,5,11,0,0,148,149,
  	3,12,6,0,149,150,5,12,0,0,150,252,1,0,0,0,151,152,5,13,0,0,152,153,3,
  	12,6,0,153,154,5,14,0,0,154,252,1,0,0,0,155,156,5,15,0,0,156,157,3,12,
  	6,0,157,158,5,16,0,0,158,252,1,0,0,0,159,160,5,17,0,0,160,161,3,12,6,
  	0,161,162,5,18,0,0,162,252,1,0,0,0,163,164,5,19,0,0,164,165,3,12,6,0,
  	165,166,5,20,0,0,166,252,1,0,0,0,167,168,5,33,0,0,168,169,5,7,0,0,169,
  	170,3,12,6,0,170,171,5,34,0,0,171,172,5,8,0,0,172,252,1,0,0,0,173,174,
  	5,33,0,0,174,175,5,9,0,0,175,176,3,12,6,0,176,177,5,34,0,0,177,178,5,
  	10,0,0,178,252,1,0,0,0,179,180,5,33,0,0,180,181,5,11,0,0,181,182,3,12,
  	6,0,182,183,5,34,0,0,183,184,5,12,0,0,184,252,1,0,0,0,185,186,5,33,0,
  	0,186,187,5,13,0,0,187,188,3,12,6,0,188,189,5,34,0,0,189,190,5,14,0,0,
  	190,252,1,0,0,0,191,192,5,33,0,0,192,193,5,15,0,0,193,194,3,12,6,0,194,
  	195,5,34,0,0,195,196,5,16,0,0,196,252,1,0,0,0,197,198,5,33,0,0,198,199,
  	5,17,0,0,199,200,3,12,6,0,200,201,5,34,0,0,201,202,5,18,0,0,202,252,1,
  	0,0,0,203,204,5,33,0,0,204,205,5,19,0,0,205,206,3,12,6,0,206,207,5,34,
  	0,0,207,208,5,20,0,0,208,252,1,0,0,0,209,210,5,35,0,0,210,211,5,7,0,0,
  	211,212,3,12,6,0,212,213,5,36,0,0,213,214,5,8,0,0,214,252,1,0,0,0,215,
  	216,5,35,0,0,216,217,5,9,0,0,217,218,3,12,6,0,218,219,5,36,0,0,219,220,
  	5,10,0,0,220,252,1,0,0,0,221,222,5,35,0,0,222,223,5,11,0,0,223,224,3,
  	12,6,0,224,225,5,36,0,0,225,226,5,12,0,0,226,252,1,0,0,0,227,228,5,35,
  	0,0,228,229,5,13,0,0,229,230,3,12,6,0,230,231,5,36,0,0,231,232,5,14,0,
  	0,232,252,1,0,0,0,233,234,5,35,0,0,234,235,5,15,0,0,235,236,3,12,6,0,
  	236,237,5,36,0,0,237,238,5,16,0,0,238,252,1,0,0,0,239,240,5,35,0,0,240,
  	241,5,17,0,0,241,242,3,12,6,0,242,243,5,36,0,0,243,244,5,18,0,0,244,252,
  	1,0,0,0,245,246,5,35,0,0,246,247,5,19,0,0,247,248,3,12,6,0,248,249,5,
  	36,0,0,249,250,5,20,0,0,250,252,1,0,0,0,251,138,1,0,0,0,251,139,1,0,0,
  	0,251,143,1,0,0,0,251,147,1,0,0,0,251,151,1,0,0,0,251,155,1,0,0,0,251,
  	159,1,0,0,0,251,163,1,0,0,0,251,167,1,0,0,0,251,173,1,0,0,0,251,179,1,
  	0,0,0,251,185,1,0,0,0,251,191,1,0,0,0,251,197,1,0,0,0,251,203,1,0,0,0,
  	251,209,1,0,0,0,251,215,1,0,0,0,251,221,1,0,0,0,251,227,1,0,0,0,251,233,
  	1,0,0,0,251,239,1,0,0,0,251,245,1,0,0,0,252,11,1,0,0,0,253,254,3,8,4,
  	0,254,255,5,106,0,0,255,260,3,8,4,0,256,257,5,106,0,0,257,259,3,8,4,0,
  	258,256,1,0,0,0,259,262,1,0,0,0,260,258,1,0,0,0,260,261,1,0,0,0,261,274,
  	1,0,0,0,262,260,1,0,0,0,263,264,3,8,4,0,264,265,5,105,0,0,265,270,3,8,
  	4,0,266,267,5,105,0,0,267,269,3,8,4,0,268,266,1,0,0,0,269,272,1,0,0,0,
  	270,268,1,0,0,0,270,271,1,0,0,0,271,274,1,0,0,0,272,270,1,0,0,0,273,253,
  	1,0,0,0,273,263,1,0,0,0,274,13,1,0,0,0,275,276,3,16,8,0,276,277,5,116,
  	0,0,277,278,3,16,8,0,278,15,1,0,0,0,279,280,3,18,9,0,280,17,1,0,0,0,281,
  	282,6,9,-1,0,282,283,3,20,10,0,283,289,1,0,0,0,284,285,10,2,0,0,285,286,
  	7,2,0,0,286,288,3,18,9,3,287,284,1,0,0,0,288,291,1,0,0,0,289,287,1,0,
  	0,0,289,290,1,0,0,0,290,19,1,0,0,0,291,289,1,0,0,0,292,293,6,10,-1,0,
  	293,294,3,24,12,0,294,300,1,0,0,0,295,296,10,2,0,0,296,297,7,3,0,0,297,
  	299,3,20,10,3,298,295,1,0,0,0,299,302,1,0,0,0,300,298,1,0,0,0,300,301,
  	1,0,0,0,301,21,1,0,0,0,302,300,1,0,0,0,303,304,6,11,-1,0,304,305,3,26,
  	13,0,305,311,1,0,0,0,306,307,10,2,0,0,307,308,7,3,0,0,308,310,3,22,11,
  	3,309,306,1,0,0,0,310,313,1,0,0,0,311,309,1,0,0,0,311,312,1,0,0,0,312,
  	23,1,0,0,0,313,311,1,0,0,0,314,315,7,2,0,0,315,322,3,24,12,0,316,318,
  	3,28,14,0,317,316,1,0,0,0,318,319,1,0,0,0,319,317,1,0,0,0,319,320,1,0,
  	0,0,320,322,1,0,0,0,321,314,1,0,0,0,321,317,1,0,0,0,322,25,1,0,0,0,323,
  	324,7,2,0,0,324,333,3,26,13,0,325,329,3,28,14,0,326,328,3,30,15,0,327,
  	326,1,0,0,0,328,331,1,0,0,0,329,327,1,0,0,0,329,330,1,0,0,0,330,333,1,
  	0,0,0,331,329,1,0,0,0,332,323,1,0,0,0,332,325,1,0,0,0,333,27,1,0,0,0,
  	334,338,3,40,20,0,335,337,3,32,16,0,336,335,1,0,0,0,337,340,1,0,0,0,338,
  	336,1,0,0,0,338,339,1,0,0,0,339,29,1,0,0,0,340,338,1,0,0,0,341,345,3,
  	42,21,0,342,344,3,32,16,0,343,342,1,0,0,0,344,347,1,0,0,0,345,343,1,0,
  	0,0,345,346,1,0,0,0,346,31,1,0,0,0,347,345,1,0,0,0,348,351,5,122,0,0,
  	349,351,3,34,17,0,350,348,1,0,0,0,350,349,1,0,0,0,351,33,1,0,0,0,352,
  	358,5,21,0,0,353,359,3,38,19,0,354,359,3,36,18,0,355,356,3,38,19,0,356,
  	357,3,36,18,0,357,359,1,0,0,0,358,353,1,0,0,0,358,354,1,0,0,0,358,355,
  	1,0,0,0,359,35,1,0,0,0,360,361,5,102,0,0,361,364,5,11,0,0,362,365,3,16,
  	8,0,363,365,3,14,7,0,364,362,1,0,0,0,364,363,1,0,0,0,365,366,1,0,0,0,
  	366,367,5,12,0,0,367,37,1,0,0,0,368,369,5,103,0,0,369,372,5,11,0,0,370,
  	373,3,16,8,0,371,373,3,14,7,0,372,370,1,0,0,0,372,371,1,0,0,0,373,374,
  	1,0,0,0,374,375,5,12,0,0,375,39,1,0,0,0,376,377,6,20,-1,0,377,378,3,44,
  	22,0,378,393,1,0,0,0,379,380,10,2,0,0,380,386,5,103,0,0,381,387,3,60,
  	30,0,382,383,5,11,0,0,383,384,3,16,8,0,384,385,5,12,0,0,385,387,1,0,0,
  	0,386,381,1,0,0,0,386,382,1,0,0,0,387,389,1,0,0,0,388,390,3,96,48,0,389,
  	388,1,0,0,0,389,390,1,0,0,0,390,392,1,0,0,0,391,379,1,0,0,0,392,395,1,
  	0,0,0,393,391,1,0,0,0,393,394,1,0,0,0,394,41,1,0,0,0,395,393,1,0,0,0,
  	396,397,6,21,-1,0,397,398,3,46,23,0,398,413,1,0,0,0,399,400,10,2,0,0,
  	400,406,5,103,0,0,401,407,3,60,30,0,402,403,5,11,0,0,403,404,3,16,8,0,
  	404,405,5,12,0,0,405,407,1,0,0,0,406,401,1,0,0,0,406,402,1,0,0,0,407,
  	409,1,0,0,0,408,410,3,96,48,0,409,408,1,0,0,0,409,410,1,0,0,0,410,412,
  	1,0,0,0,411,399,1,0,0,0,412,415,1,0,0,0,413,411,1,0,0,0,413,414,1,0,0,
  	0,414,43,1,0,0,0,415,413,1,0,0,0,416,426,3,48,24,0,417,426,3,50,25,0,
  	418,426,3,52,26,0,419,426,3,54,27,0,420,426,3,82,41,0,421,426,3,60,30,
  	0,422,426,3,66,33,0,423,426,3,68,34,0,424,426,3,4,2,0,425,416,1,0,0,0,
  	425,417,1,0,0,0,425,418,1,0,0,0,425,419,1,0,0,0,425,420,1,0,0,0,425,421,
  	1,0,0,0,425,422,1,0,0,0,425,423,1,0,0,0,425,424,1,0,0,0,426,45,1,0,0,
  	0,427,436,3,48,24,0,428,436,3,50,25,0,429,436,3,52,26,0,430,436,3,54,
  	27,0,431,436,3,60,30,0,432,436,3,66,33,0,433,436,3,68,34,0,434,436,3,
  	4,2,0,435,427,1,0,0,0,435,428,1,0,0,0,435,429,1,0,0,0,435,430,1,0,0,0,
  	435,431,1,0,0,0,435,432,1,0,0,0,435,433,1,0,0,0,435,434,1,0,0,0,436,47,
  	1,0,0,0,437,438,5,7,0,0,438,439,3,16,8,0,439,440,5,8,0,0,440,550,1,0,
  	0,0,441,442,5,9,0,0,442,443,3,16,8,0,443,444,5,10,0,0,444,550,1,0,0,0,
  	445,446,5,11,0,0,446,447,3,16,8,0,447,448,5,12,0,0,448,550,1,0,0,0,449,
  	450,5,13,0,0,450,451,3,16,8,0,451,452,5,14,0,0,452,550,1,0,0,0,453,454,
  	5,15,0,0,454,455,3,16,8,0,455,456,5,16,0,0,456,550,1,0,0,0,457,458,5,
  	17,0,0,458,459,3,16,8,0,459,460,5,18,0,0,460,550,1,0,0,0,461,462,5,19,
  	0,0,462,463,3,16,8,0,463,464,5,20,0,0,464,550,1,0,0,0,465,466,5,33,0,
  	0,466,467,5,7,0,0,467,468,3,16,8,0,468,469,5,34,0,0,469,470,5,8,0,0,470,
  	550,1,0,0,0,471,472,5,33,0,0,472,473,5,9,0,0,473,474,3,16,8,0,474,475,
  	5,34,0,0,475,476,5,10,0,0,476,550,1,0,0,0,477,478,5,33,0,0,478,479,5,
  	11,0,0,479,480,3,16,8,0,480,481,5,34,0,0,481,482,5,12,0,0,482,550,1,0,
  	0,0,483,484,5,33,0,0,484,485,5,13,0,0,485,486,3,16,8,0,486,487,5,34,0,
  	0,487,488,5,14,0,0,488,550,1,0,0,0,489,490,5,33,0,0,490,491,5,15,0,0,
  	491,492,3,16,8,0,492,493,5,34,0,0,493,494,5,16,0,0,494,550,1,0,0,0,495,
  	496,5,33,0,0,496,497,5,17,0,0,497,498,3,16,8,0,498,499,5,34,0,0,499,500,
  	5,18,0,0,500,550,1,0,0,0,501,502,5,33,0,0,502,503,5,19,0,0,503,504,3,
  	16,8,0,504,505,5,34,0,0,505,506,5,20,0,0,506,550,1,0,0,0,507,508,5,35,
  	0,0,508,509,5,7,0,0,509,510,3,16,8,0,510,511,5,36,0,0,511,512,5,8,0,0,
  	512,550,1,0,0,0,513,514,5,35,0,0,514,515,5,9,0,0,515,516,3,16,8,0,516,
  	517,5,36,0,0,517,518,5,10,0,0,518,550,1,0,0,0,519,520,5,35,0,0,520,521,
  	5,11,0,0,521,522,3,16,8,0,522,523,5,36,0,0,523,524,5,12,0,0,524,550,1,
  	0,0,0,525,526,5,35,0,0,526,527,5,13,0,0,527,528,3,16,8,0,528,529,5,36,
  	0,0,529,530,5,14,0,0,530,550,1,0,0,0,531,532,5,35,0,0,532,533,5,15,0,
  	0,533,534,3,16,8,0,534,535,5,36,0,0,535,536,5,16,0,0,536,550,1,0,0,0,
  	537,538,5,35,0,0,538,539,5,17,0,0,539,540,3,16,8,0,540,541,5,36,0,0,541,
  	542,5,18,0,0,542,550,1,0,0,0,543,544,5,35,0,0,544,545,5,19,0,0,545,546,
  	3,16,8,0,546,547,5,36,0,0,547,548,5,20,0,0,548,550,1,0,0,0,549,437,1,
  	0,0,0,549,441,1,0,0,0,549,445,1,0,0,0,549,449,1,0,0,0,549,453,1,0,0,0,
  	549,457,1,0,0,0,549,461,1,0,0,0,549,465,1,0,0,0,549,471,1,0,0,0,549,477,
  	1,0,0,0,549,483,1,0,0,0,549,489,1,0,0,0,549,495,1,0,0,0,549,501,1,0,0,
  	0,549,507,1,0,0,0,549,513,1,0,0,0,549,519,1,0,0,0,549,525,1,0,0,0,549,
  	531,1,0,0,0,549,537,1,0,0,0,549,543,1,0,0,0,550,49,1,0,0,0,551,552,5,
  	21,0,0,552,553,3,16,8,0,553,554,5,21,0,0,554,600,1,0,0,0,555,556,5,22,
  	0,0,556,557,3,16,8,0,557,558,5,23,0,0,558,600,1,0,0,0,559,560,5,24,0,
  	0,560,561,3,16,8,0,561,562,5,24,0,0,562,600,1,0,0,0,563,564,5,33,0,0,
  	564,565,5,21,0,0,565,566,3,16,8,0,566,567,5,34,0,0,567,568,5,21,0,0,568,
  	600,1,0,0,0,569,570,5,33,0,0,570,571,5,22,0,0,571,572,3,16,8,0,572,573,
  	5,34,0,0,573,574,5,23,0,0,574,600,1,0,0,0,575,576,5,33,0,0,576,577,5,
  	24,0,0,577,578,3,16,8,0,578,579,5,34,0,0,579,580,5,24,0,0,580,600,1,0,
  	0,0,581,582,5,35,0,0,582,583,5,21,0,0,583,584,3,16,8,0,584,585,5,36,0,
  	0,585,586,5,21,0,0,586,600,1,0,0,0,587,588,5,35,0,0,588,589,5,22,0,0,
  	589,590,3,16,8,0,590,591,5,36,0,0,591,592,5,23,0,0,592,600,1,0,0,0,593,
  	594,5,35,0,0,594,595,5,24,0,0,595,596,3,16,8,0,596,597,5,36,0,0,597,598,
  	5,24,0,0,598,600,1,0,0,0,599,551,1,0,0,0,599,555,1,0,0,0,599,559,1,0,
  	0,0,599,563,1,0,0,0,599,569,1,0,0,0,599,575,1,0,0,0,599,581,1,0,0,0,599,
  	587,1,0,0,0,599,593,1,0,0,0,600,51,1,0,0,0,601,602,5,25,0,0,602,603,3,
  	16,8,0,603,604,5,26,0,0,604,634,1,0,0,0,605,606,5,27,0,0,606,607,3,16,
  	8,0,607,608,5,28,0,0,608,634,1,0,0,0,609,610,5,33,0,0,610,611,5,25,0,
  	0,611,612,3,16,8,0,612,613,5,34,0,0,613,614,5,26,0,0,614,634,1,0,0,0,
  	615,616,5,33,0,0,616,617,5,27,0,0,617,618,3,16,8,0,618,619,5,34,0,0,619,
  	620,5,28,0,0,620,634,1,0,0,0,621,622,5,35,0,0,622,623,5,25,0,0,623,624,
  	3,16,8,0,624,625,5,36,0,0,625,626,5,26,0,0,626,634,1,0,0,0,627,628,5,
  	35,0,0,628,629,5,27,0,0,629,630,3,16,8,0,630,631,5,36,0,0,631,632,5,28,
  	0,0,632,634,1,0,0,0,633,601,1,0,0,0,633,605,1,0,0,0,633,609,1,0,0,0,633,
  	615,1,0,0,0,633,621,1,0,0,0,633,627,1,0,0,0,634,53,1,0,0,0,635,636,5,
  	29,0,0,636,637,3,16,8,0,637,638,5,30,0,0,638,668,1,0,0,0,639,640,5,31,
  	0,0,640,641,3,16,8,0,641,642,5,32,0,0,642,668,1,0,0,0,643,644,5,33,0,
  	0,644,645,5,29,0,0,645,646,3,16,8,0,646,647,5,34,0,0,647,648,5,30,0,0,
  	648,668,1,0,0,0,649,650,5,33,0,0,650,651,5,31,0,0,651,652,3,16,8,0,652,
  	653,5,34,0,0,653,654,5,32,0,0,654,668,1,0,0,0,655,656,5,35,0,0,656,657,
  	5,29,0,0,657,658,3,16,8,0,658,659,5,36,0,0,659,660,5,30,0,0,660,668,1,
  	0,0,0,661,662,5,35,0,0,662,663,5,31,0,0,663,664,3,16,8,0,664,665,5,36,
  	0,0,665,666,5,32,0,0,666,668,1,0,0,0,667,635,1,0,0,0,667,639,1,0,0,0,
  	667,643,1,0,0,0,667,649,1,0,0,0,667,655,1,0,0,0,667,661,1,0,0,0,668,55,
  	1,0,0,0,669,670,3,0,0,0,670,671,5,11,0,0,671,672,3,16,8,0,672,673,5,12,
  	0,0,673,57,1,0,0,0,674,678,5,111,0,0,675,678,5,124,0,0,676,678,3,56,28,
  	0,677,674,1,0,0,0,677,675,1,0,0,0,677,676,1,0,0,0,678,687,1,0,0,0,679,
  	680,3,98,49,0,680,681,3,96,48,0,681,688,1,0,0,0,682,683,3,96,48,0,683,
  	684,3,98,49,0,684,688,1,0,0,0,685,688,3,96,48,0,686,688,3,98,49,0,687,
  	679,1,0,0,0,687,682,1,0,0,0,687,685,1,0,0,0,687,686,1,0,0,0,687,688,1,
  	0,0,0,688,59,1,0,0,0,689,700,3,58,29,0,690,700,5,125,0,0,691,700,5,112,
  	0,0,692,700,5,114,0,0,693,700,5,113,0,0,694,700,5,123,0,0,695,700,5,115,
  	0,0,696,700,5,108,0,0,697,700,3,62,31,0,698,700,5,126,0,0,699,689,1,0,
  	0,0,699,690,1,0,0,0,699,691,1,0,0,0,699,692,1,0,0,0,699,693,1,0,0,0,699,
  	694,1,0,0,0,699,695,1,0,0,0,699,696,1,0,0,0,699,697,1,0,0,0,699,698,1,
  	0,0,0,700,61,1,0,0,0,701,702,5,90,0,0,702,703,5,11,0,0,703,704,3,64,32,
  	0,704,705,5,12,0,0,705,63,1,0,0,0,706,708,7,4,0,0,707,706,1,0,0,0,708,
  	709,1,0,0,0,709,707,1,0,0,0,709,710,1,0,0,0,710,65,1,0,0,0,711,712,5,
  	86,0,0,712,713,5,11,0,0,713,714,3,16,8,0,714,715,5,12,0,0,715,716,5,11,
  	0,0,716,717,3,16,8,0,717,718,5,12,0,0,718,67,1,0,0,0,719,720,7,5,0,0,
  	720,721,5,11,0,0,721,722,3,16,8,0,722,723,5,12,0,0,723,724,5,11,0,0,724,
  	725,3,16,8,0,725,726,5,12,0,0,726,69,1,0,0,0,727,728,7,6,0,0,728,71,1,
  	0,0,0,729,730,7,7,0,0,730,73,1,0,0,0,731,732,7,8,0,0,732,75,1,0,0,0,733,
  	734,7,9,0,0,734,77,1,0,0,0,735,742,3,70,35,0,736,737,5,91,0,0,737,738,
  	5,11,0,0,738,739,3,74,37,0,739,740,5,12,0,0,740,742,1,0,0,0,741,735,1,
  	0,0,0,741,736,1,0,0,0,742,79,1,0,0,0,743,750,3,72,36,0,744,745,5,91,0,
  	0,745,746,5,11,0,0,746,747,3,76,38,0,747,748,5,12,0,0,748,750,1,0,0,0,
  	749,743,1,0,0,0,749,744,1,0,0,0,750,81,1,0,0,0,751,764,3,78,39,0,752,
  	754,3,96,48,0,753,752,1,0,0,0,753,754,1,0,0,0,754,756,1,0,0,0,755,757,
  	3,98,49,0,756,755,1,0,0,0,756,757,1,0,0,0,757,765,1,0,0,0,758,760,3,98,
  	49,0,759,758,1,0,0,0,759,760,1,0,0,0,760,762,1,0,0,0,761,763,3,96,48,
  	0,762,761,1,0,0,0,762,763,1,0,0,0,763,765,1,0,0,0,764,753,1,0,0,0,764,
  	759,1,0,0,0,765,787,1,0,0,0,766,768,5,33,0,0,767,766,1,0,0,0,767,768,
  	1,0,0,0,768,769,1,0,0,0,769,770,5,7,0,0,770,772,3,88,44,0,771,773,5,34,
  	0,0,772,771,1,0,0,0,772,773,1,0,0,0,773,774,1,0,0,0,774,775,5,8,0,0,775,
  	788,1,0,0,0,776,778,5,35,0,0,777,776,1,0,0,0,777,778,1,0,0,0,778,779,
  	1,0,0,0,779,780,5,7,0,0,780,782,3,88,44,0,781,783,5,36,0,0,782,781,1,
  	0,0,0,782,783,1,0,0,0,783,784,1,0,0,0,784,785,5,8,0,0,785,788,1,0,0,0,
  	786,788,3,90,45,0,787,767,1,0,0,0,787,777,1,0,0,0,787,786,1,0,0,0,788,
  	889,1,0,0,0,789,802,3,80,40,0,790,792,3,96,48,0,791,790,1,0,0,0,791,792,
  	1,0,0,0,792,794,1,0,0,0,793,795,3,98,49,0,794,793,1,0,0,0,794,795,1,0,
  	0,0,795,803,1,0,0,0,796,798,3,98,49,0,797,796,1,0,0,0,797,798,1,0,0,0,
  	798,800,1,0,0,0,799,801,3,96,48,0,800,799,1,0,0,0,800,801,1,0,0,0,801,
  	803,1,0,0,0,802,791,1,0,0,0,802,797,1,0,0,0,803,825,1,0,0,0,804,806,5,
  	33,0,0,805,804,1,0,0,0,805,806,1,0,0,0,806,807,1,0,0,0,807,808,5,7,0,
  	0,808,810,3,92,46,0,809,811,5,34,0,0,810,809,1,0,0,0,810,811,1,0,0,0,
  	811,812,1,0,0,0,812,813,5,8,0,0,813,826,1,0,0,0,814,816,5,35,0,0,815,
  	814,1,0,0,0,815,816,1,0,0,0,816,817,1,0,0,0,817,818,5,7,0,0,818,820,3,
  	92,46,0,819,821,5,36,0,0,820,819,1,0,0,0,820,821,1,0,0,0,821,822,1,0,
  	0,0,822,823,5,8,0,0,823,826,1,0,0,0,824,826,3,94,47,0,825,805,1,0,0,0,
  	825,815,1,0,0,0,825,824,1,0,0,0,826,889,1,0,0,0,827,848,5,39,0,0,828,
  	829,3,96,48,0,829,830,3,98,49,0,830,849,1,0,0,0,831,832,3,98,49,0,832,
  	833,3,96,48,0,833,849,1,0,0,0,834,835,5,102,0,0,835,836,5,11,0,0,836,
  	837,5,12,0,0,837,838,1,0,0,0,838,839,5,103,0,0,839,840,5,11,0,0,840,849,
  	5,12,0,0,841,842,5,103,0,0,842,843,5,11,0,0,843,844,5,12,0,0,844,845,
  	1,0,0,0,845,846,5,102,0,0,846,847,5,11,0,0,847,849,5,12,0,0,848,828,1,
  	0,0,0,848,831,1,0,0,0,848,834,1,0,0,0,848,841,1,0,0,0,848,849,1,0,0,0,
  	849,856,1,0,0,0,850,852,3,18,9,0,851,850,1,0,0,0,851,852,1,0,0,0,852,
  	853,1,0,0,0,853,857,5,108,0,0,854,857,3,66,33,0,855,857,3,18,9,0,856,
  	851,1,0,0,0,856,854,1,0,0,0,856,855,1,0,0,0,857,889,1,0,0,0,858,863,5,
  	76,0,0,859,860,5,17,0,0,860,861,3,16,8,0,861,862,5,18,0,0,862,864,1,0,
  	0,0,863,859,1,0,0,0,863,864,1,0,0,0,864,865,1,0,0,0,865,866,5,11,0,0,
  	866,867,3,16,8,0,867,868,5,12,0,0,868,889,1,0,0,0,869,876,7,10,0,0,870,
  	871,3,100,50,0,871,872,3,98,49,0,872,877,1,0,0,0,873,874,3,98,49,0,874,
  	875,3,100,50,0,875,877,1,0,0,0,876,870,1,0,0,0,876,873,1,0,0,0,877,878,
  	1,0,0,0,878,879,3,20,10,0,879,889,1,0,0,0,880,881,5,37,0,0,881,882,3,
  	86,43,0,882,883,3,20,10,0,883,889,1,0,0,0,884,886,5,109,0,0,885,887,3,
  	98,49,0,886,885,1,0,0,0,886,887,1,0,0,0,887,889,1,0,0,0,888,751,1,0,0,
  	0,888,789,1,0,0,0,888,827,1,0,0,0,888,858,1,0,0,0,888,869,1,0,0,0,888,
  	880,1,0,0,0,888,884,1,0,0,0,889,83,1,0,0,0,890,891,3,16,8,0,891,892,5,
  	106,0,0,892,893,3,84,42,0,893,896,1,0,0,0,894,896,3,16,8,0,895,890,1,
  	0,0,0,895,894,1,0,0,0,896,85,1,0,0,0,897,898,5,102,0,0,898,899,5,11,0,
  	0,899,900,7,11,0,0,900,901,5,38,0,0,901,906,3,16,8,0,902,903,5,103,0,
  	0,903,904,5,11,0,0,904,905,7,2,0,0,905,907,5,12,0,0,906,902,1,0,0,0,906,
  	907,1,0,0,0,907,908,1,0,0,0,908,909,5,12,0,0,909,87,1,0,0,0,910,911,3,
  	16,8,0,911,89,1,0,0,0,912,913,3,22,11,0,913,91,1,0,0,0,914,920,3,16,8,
  	0,915,916,3,16,8,0,916,917,5,106,0,0,917,918,3,92,46,0,918,920,1,0,0,
  	0,919,914,1,0,0,0,919,915,1,0,0,0,920,93,1,0,0,0,921,922,3,22,11,0,922,
  	95,1,0,0,0,923,932,5,102,0,0,924,933,3,60,30,0,925,928,5,11,0,0,926,929,
  	3,16,8,0,927,929,3,84,42,0,928,926,1,0,0,0,928,927,1,0,0,0,929,930,1,
  	0,0,0,930,931,5,12,0,0,931,933,1,0,0,0,932,924,1,0,0,0,932,925,1,0,0,
  	0,933,97,1,0,0,0,934,940,5,103,0,0,935,941,3,60,30,0,936,937,5,11,0,0,
  	937,938,3,16,8,0,938,939,5,12,0,0,939,941,1,0,0,0,940,935,1,0,0,0,940,
  	936,1,0,0,0,941,99,1,0,0,0,942,943,5,102,0,0,943,944,5,11,0,0,944,945,
  	3,14,7,0,945,946,5,12,0,0,946,101,1,0,0,0,72,106,114,124,135,251,260,
  	270,273,289,300,311,319,321,329,332,338,345,350,358,364,372,386,389,393,
  	406,409,413,425,435,549,599,633,667,677,687,699,709,741,749,753,756,759,
  	762,764,767,772,777,782,787,791,794,797,800,802,805,810,815,820,825,848,
  	851,856,863,876,886,888,895,906,919,928,932,940
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  latexParserStaticData = staticData.release();
}

}

LATEXParser::LATEXParser(TokenStream *input) : LATEXParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

LATEXParser::LATEXParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  LATEXParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *latexParserStaticData->atn, latexParserStaticData->decisionToDFA, latexParserStaticData->sharedContextCache, options);
}

LATEXParser::~LATEXParser() {
  delete _interpreter;
}

const atn::ATN& LATEXParser::getATN() const {
  return *latexParserStaticData->atn;
}

std::string LATEXParser::getGrammarFileName() const {
  return "LATEX.g4";
}

const std::vector<std::string>& LATEXParser::getRuleNames() const {
  return latexParserStaticData->ruleNames;
}

const dfa::Vocabulary& LATEXParser::getVocabulary() const {
  return latexParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView LATEXParser::getSerializedATN() const {
  return latexParserStaticData->serializedATN;
}


//----------------- Accent_symbolContext ------------------------------------------------------------------

LATEXParser::Accent_symbolContext::Accent_symbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Accent_symbolContext::ACCENT_BAR() {
  return getToken(LATEXParser::ACCENT_BAR, 0);
}

tree::TerminalNode* LATEXParser::Accent_symbolContext::ACCENT_OVERLINE() {
  return getToken(LATEXParser::ACCENT_OVERLINE, 0);
}


size_t LATEXParser::Accent_symbolContext::getRuleIndex() const {
  return LATEXParser::RuleAccent_symbol;
}


LATEXParser::Accent_symbolContext* LATEXParser::accent_symbol() {
  Accent_symbolContext *_localctx = _tracker.createInstance<Accent_symbolContext>(_ctx, getState());
  enterRule(_localctx, 0, LATEXParser::RuleAccent_symbol);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(102);
    _la = _input->LA(1);
    if (!(_la == LATEXParser::ACCENT_OVERLINE

    || _la == LATEXParser::ACCENT_BAR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MathContext ------------------------------------------------------------------

LATEXParser::MathContext::MathContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::RelationContext* LATEXParser::MathContext::relation() {
  return getRuleContext<LATEXParser::RelationContext>(0);
}

LATEXParser::Relation_listContext* LATEXParser::MathContext::relation_list() {
  return getRuleContext<LATEXParser::Relation_listContext>(0);
}


size_t LATEXParser::MathContext::getRuleIndex() const {
  return LATEXParser::RuleMath;
}


LATEXParser::MathContext* LATEXParser::math() {
  MathContext *_localctx = _tracker.createInstance<MathContext>(_ctx, getState());
  enterRule(_localctx, 2, LATEXParser::RuleMath);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(106);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(104);
      relation(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(105);
      relation_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MatrixContext ------------------------------------------------------------------

LATEXParser::MatrixContext::MatrixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::MatrixContext::CMD_MATRIX_START() {
  return getToken(LATEXParser::CMD_MATRIX_START, 0);
}

std::vector<LATEXParser::Matrix_rowContext *> LATEXParser::MatrixContext::matrix_row() {
  return getRuleContexts<LATEXParser::Matrix_rowContext>();
}

LATEXParser::Matrix_rowContext* LATEXParser::MatrixContext::matrix_row(size_t i) {
  return getRuleContext<LATEXParser::Matrix_rowContext>(i);
}

tree::TerminalNode* LATEXParser::MatrixContext::CMD_MATRIX_END() {
  return getToken(LATEXParser::CMD_MATRIX_END, 0);
}

std::vector<tree::TerminalNode *> LATEXParser::MatrixContext::MATRIX_DEL_ROW() {
  return getTokens(LATEXParser::MATRIX_DEL_ROW);
}

tree::TerminalNode* LATEXParser::MatrixContext::MATRIX_DEL_ROW(size_t i) {
  return getToken(LATEXParser::MATRIX_DEL_ROW, i);
}


size_t LATEXParser::MatrixContext::getRuleIndex() const {
  return LATEXParser::RuleMatrix;
}


LATEXParser::MatrixContext* LATEXParser::matrix() {
  MatrixContext *_localctx = _tracker.createInstance<MatrixContext>(_ctx, getState());
  enterRule(_localctx, 4, LATEXParser::RuleMatrix);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(108);
    match(LATEXParser::CMD_MATRIX_START);
    setState(109);
    matrix_row();
    setState(114);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LATEXParser::MATRIX_DEL_ROW) {
      setState(110);
      match(LATEXParser::MATRIX_DEL_ROW);
      setState(111);
      matrix_row();
      setState(116);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(117);
    match(LATEXParser::CMD_MATRIX_END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Matrix_rowContext ------------------------------------------------------------------

LATEXParser::Matrix_rowContext::Matrix_rowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LATEXParser::ExprContext *> LATEXParser::Matrix_rowContext::expr() {
  return getRuleContexts<LATEXParser::ExprContext>();
}

LATEXParser::ExprContext* LATEXParser::Matrix_rowContext::expr(size_t i) {
  return getRuleContext<LATEXParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> LATEXParser::Matrix_rowContext::MATRIX_DEL_COL() {
  return getTokens(LATEXParser::MATRIX_DEL_COL);
}

tree::TerminalNode* LATEXParser::Matrix_rowContext::MATRIX_DEL_COL(size_t i) {
  return getToken(LATEXParser::MATRIX_DEL_COL, i);
}


size_t LATEXParser::Matrix_rowContext::getRuleIndex() const {
  return LATEXParser::RuleMatrix_row;
}


LATEXParser::Matrix_rowContext* LATEXParser::matrix_row() {
  Matrix_rowContext *_localctx = _tracker.createInstance<Matrix_rowContext>(_ctx, getState());
  enterRule(_localctx, 6, LATEXParser::RuleMatrix_row);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(119);
    expr();
    setState(124);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LATEXParser::MATRIX_DEL_COL) {
      setState(120);
      match(LATEXParser::MATRIX_DEL_COL);
      setState(121);
      expr();
      setState(126);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationContext ------------------------------------------------------------------

LATEXParser::RelationContext::RelationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::ExprContext* LATEXParser::RelationContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

std::vector<LATEXParser::RelationContext *> LATEXParser::RelationContext::relation() {
  return getRuleContexts<LATEXParser::RelationContext>();
}

LATEXParser::RelationContext* LATEXParser::RelationContext::relation(size_t i) {
  return getRuleContext<LATEXParser::RelationContext>(i);
}

tree::TerminalNode* LATEXParser::RelationContext::EQUAL() {
  return getToken(LATEXParser::EQUAL, 0);
}

tree::TerminalNode* LATEXParser::RelationContext::LT() {
  return getToken(LATEXParser::LT, 0);
}

tree::TerminalNode* LATEXParser::RelationContext::LTE() {
  return getToken(LATEXParser::LTE, 0);
}

tree::TerminalNode* LATEXParser::RelationContext::GT() {
  return getToken(LATEXParser::GT, 0);
}

tree::TerminalNode* LATEXParser::RelationContext::GTE() {
  return getToken(LATEXParser::GTE, 0);
}

tree::TerminalNode* LATEXParser::RelationContext::UNEQUAL() {
  return getToken(LATEXParser::UNEQUAL, 0);
}


size_t LATEXParser::RelationContext::getRuleIndex() const {
  return LATEXParser::RuleRelation;
}



LATEXParser::RelationContext* LATEXParser::relation() {
   return relation(0);
}

LATEXParser::RelationContext* LATEXParser::relation(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LATEXParser::RelationContext *_localctx = _tracker.createInstance<RelationContext>(_ctx, parentState);
  LATEXParser::RelationContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 8;
  enterRecursionRule(_localctx, 8, LATEXParser::RuleRelation, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(128);
    expr();
    _ctx->stop = _input->LT(-1);
    setState(135);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<RelationContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleRelation);
        setState(130);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(131);
        _la = _input->LA(1);
        if (!((((_la - 116) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 116)) & 63) != 0)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(132);
        relation(3); 
      }
      setState(137);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Relation_listContext ------------------------------------------------------------------

LATEXParser::Relation_listContext::Relation_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Relation_list_contentContext* LATEXParser::Relation_listContext::relation_list_content() {
  return getRuleContext<LATEXParser::Relation_list_contentContext>(0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::L_PAREN() {
  return getToken(LATEXParser::L_PAREN, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::R_PAREN() {
  return getToken(LATEXParser::R_PAREN, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::L_GROUP() {
  return getToken(LATEXParser::L_GROUP, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::R_GROUP() {
  return getToken(LATEXParser::R_GROUP, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::L_BRACE_VISUAL() {
  return getToken(LATEXParser::L_BRACE_VISUAL, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::R_BRACE_VISUAL() {
  return getToken(LATEXParser::R_BRACE_VISUAL, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::L_BRACE_CMD() {
  return getToken(LATEXParser::L_BRACE_CMD, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::R_BRACE_CMD() {
  return getToken(LATEXParser::R_BRACE_CMD, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::L_BRACKET() {
  return getToken(LATEXParser::L_BRACKET, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::R_BRACKET() {
  return getToken(LATEXParser::R_BRACKET, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::L_BRACK() {
  return getToken(LATEXParser::L_BRACK, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::R_BRACK() {
  return getToken(LATEXParser::R_BRACK, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::L_LEFT() {
  return getToken(LATEXParser::L_LEFT, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::R_RIGHT() {
  return getToken(LATEXParser::R_RIGHT, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::ML_LEFT() {
  return getToken(LATEXParser::ML_LEFT, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::MR_RIGHT() {
  return getToken(LATEXParser::MR_RIGHT, 0);
}


size_t LATEXParser::Relation_listContext::getRuleIndex() const {
  return LATEXParser::RuleRelation_list;
}


LATEXParser::Relation_listContext* LATEXParser::relation_list() {
  Relation_listContext *_localctx = _tracker.createInstance<Relation_listContext>(_ctx, getState());
  enterRule(_localctx, 10, LATEXParser::RuleRelation_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(251);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(138);
      relation_list_content();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(139);
      match(LATEXParser::L_PAREN);
      setState(140);
      relation_list_content();
      setState(141);
      match(LATEXParser::R_PAREN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(143);
      match(LATEXParser::L_GROUP);
      setState(144);
      relation_list_content();
      setState(145);
      match(LATEXParser::R_GROUP);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(147);
      match(LATEXParser::L_BRACE);
      setState(148);
      relation_list_content();
      setState(149);
      match(LATEXParser::R_BRACE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(151);
      match(LATEXParser::L_BRACE_VISUAL);
      setState(152);
      relation_list_content();
      setState(153);
      match(LATEXParser::R_BRACE_VISUAL);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(155);
      match(LATEXParser::L_BRACE_CMD);
      setState(156);
      relation_list_content();
      setState(157);
      match(LATEXParser::R_BRACE_CMD);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(159);
      match(LATEXParser::L_BRACKET);
      setState(160);
      relation_list_content();
      setState(161);
      match(LATEXParser::R_BRACKET);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(163);
      match(LATEXParser::L_BRACK);
      setState(164);
      relation_list_content();
      setState(165);
      match(LATEXParser::R_BRACK);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(167);
      match(LATEXParser::L_LEFT);
      setState(168);
      match(LATEXParser::L_PAREN);
      setState(169);
      relation_list_content();
      setState(170);
      match(LATEXParser::R_RIGHT);
      setState(171);
      match(LATEXParser::R_PAREN);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(173);
      match(LATEXParser::L_LEFT);
      setState(174);
      match(LATEXParser::L_GROUP);
      setState(175);
      relation_list_content();
      setState(176);
      match(LATEXParser::R_RIGHT);
      setState(177);
      match(LATEXParser::R_GROUP);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(179);
      match(LATEXParser::L_LEFT);
      setState(180);
      match(LATEXParser::L_BRACE);
      setState(181);
      relation_list_content();
      setState(182);
      match(LATEXParser::R_RIGHT);
      setState(183);
      match(LATEXParser::R_BRACE);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(185);
      match(LATEXParser::L_LEFT);
      setState(186);
      match(LATEXParser::L_BRACE_VISUAL);
      setState(187);
      relation_list_content();
      setState(188);
      match(LATEXParser::R_RIGHT);
      setState(189);
      match(LATEXParser::R_BRACE_VISUAL);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(191);
      match(LATEXParser::L_LEFT);
      setState(192);
      match(LATEXParser::L_BRACE_CMD);
      setState(193);
      relation_list_content();
      setState(194);
      match(LATEXParser::R_RIGHT);
      setState(195);
      match(LATEXParser::R_BRACE_CMD);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(197);
      match(LATEXParser::L_LEFT);
      setState(198);
      match(LATEXParser::L_BRACKET);
      setState(199);
      relation_list_content();
      setState(200);
      match(LATEXParser::R_RIGHT);
      setState(201);
      match(LATEXParser::R_BRACKET);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(203);
      match(LATEXParser::L_LEFT);
      setState(204);
      match(LATEXParser::L_BRACK);
      setState(205);
      relation_list_content();
      setState(206);
      match(LATEXParser::R_RIGHT);
      setState(207);
      match(LATEXParser::R_BRACK);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(209);
      match(LATEXParser::ML_LEFT);
      setState(210);
      match(LATEXParser::L_PAREN);
      setState(211);
      relation_list_content();
      setState(212);
      match(LATEXParser::MR_RIGHT);
      setState(213);
      match(LATEXParser::R_PAREN);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(215);
      match(LATEXParser::ML_LEFT);
      setState(216);
      match(LATEXParser::L_GROUP);
      setState(217);
      relation_list_content();
      setState(218);
      match(LATEXParser::MR_RIGHT);
      setState(219);
      match(LATEXParser::R_GROUP);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(221);
      match(LATEXParser::ML_LEFT);
      setState(222);
      match(LATEXParser::L_BRACE);
      setState(223);
      relation_list_content();
      setState(224);
      match(LATEXParser::MR_RIGHT);
      setState(225);
      match(LATEXParser::R_BRACE);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(227);
      match(LATEXParser::ML_LEFT);
      setState(228);
      match(LATEXParser::L_BRACE_VISUAL);
      setState(229);
      relation_list_content();
      setState(230);
      match(LATEXParser::MR_RIGHT);
      setState(231);
      match(LATEXParser::R_BRACE_VISUAL);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(233);
      match(LATEXParser::ML_LEFT);
      setState(234);
      match(LATEXParser::L_BRACE_CMD);
      setState(235);
      relation_list_content();
      setState(236);
      match(LATEXParser::MR_RIGHT);
      setState(237);
      match(LATEXParser::R_BRACE_CMD);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(239);
      match(LATEXParser::ML_LEFT);
      setState(240);
      match(LATEXParser::L_BRACKET);
      setState(241);
      relation_list_content();
      setState(242);
      match(LATEXParser::MR_RIGHT);
      setState(243);
      match(LATEXParser::R_BRACKET);
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(245);
      match(LATEXParser::ML_LEFT);
      setState(246);
      match(LATEXParser::L_BRACK);
      setState(247);
      relation_list_content();
      setState(248);
      match(LATEXParser::MR_RIGHT);
      setState(249);
      match(LATEXParser::R_BRACK);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Relation_list_contentContext ------------------------------------------------------------------

LATEXParser::Relation_list_contentContext::Relation_list_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LATEXParser::RelationContext *> LATEXParser::Relation_list_contentContext::relation() {
  return getRuleContexts<LATEXParser::RelationContext>();
}

LATEXParser::RelationContext* LATEXParser::Relation_list_contentContext::relation(size_t i) {
  return getRuleContext<LATEXParser::RelationContext>(i);
}

std::vector<tree::TerminalNode *> LATEXParser::Relation_list_contentContext::COMMA() {
  return getTokens(LATEXParser::COMMA);
}

tree::TerminalNode* LATEXParser::Relation_list_contentContext::COMMA(size_t i) {
  return getToken(LATEXParser::COMMA, i);
}

std::vector<tree::TerminalNode *> LATEXParser::Relation_list_contentContext::SEMICOLON() {
  return getTokens(LATEXParser::SEMICOLON);
}

tree::TerminalNode* LATEXParser::Relation_list_contentContext::SEMICOLON(size_t i) {
  return getToken(LATEXParser::SEMICOLON, i);
}


size_t LATEXParser::Relation_list_contentContext::getRuleIndex() const {
  return LATEXParser::RuleRelation_list_content;
}


LATEXParser::Relation_list_contentContext* LATEXParser::relation_list_content() {
  Relation_list_contentContext *_localctx = _tracker.createInstance<Relation_list_contentContext>(_ctx, getState());
  enterRule(_localctx, 12, LATEXParser::RuleRelation_list_content);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(273);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(253);
      relation(0);
      setState(254);
      match(LATEXParser::COMMA);
      setState(255);
      relation(0);
      setState(260);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LATEXParser::COMMA) {
        setState(256);
        match(LATEXParser::COMMA);
        setState(257);
        relation(0);
        setState(262);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(263);
      relation(0);
      setState(264);
      match(LATEXParser::SEMICOLON);
      setState(265);
      relation(0);
      setState(270);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LATEXParser::SEMICOLON) {
        setState(266);
        match(LATEXParser::SEMICOLON);
        setState(267);
        relation(0);
        setState(272);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EqualityContext ------------------------------------------------------------------

LATEXParser::EqualityContext::EqualityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LATEXParser::ExprContext *> LATEXParser::EqualityContext::expr() {
  return getRuleContexts<LATEXParser::ExprContext>();
}

LATEXParser::ExprContext* LATEXParser::EqualityContext::expr(size_t i) {
  return getRuleContext<LATEXParser::ExprContext>(i);
}

tree::TerminalNode* LATEXParser::EqualityContext::EQUAL() {
  return getToken(LATEXParser::EQUAL, 0);
}


size_t LATEXParser::EqualityContext::getRuleIndex() const {
  return LATEXParser::RuleEquality;
}


LATEXParser::EqualityContext* LATEXParser::equality() {
  EqualityContext *_localctx = _tracker.createInstance<EqualityContext>(_ctx, getState());
  enterRule(_localctx, 14, LATEXParser::RuleEquality);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(275);
    expr();
    setState(276);
    match(LATEXParser::EQUAL);
    setState(277);
    expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

LATEXParser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::AdditiveContext* LATEXParser::ExprContext::additive() {
  return getRuleContext<LATEXParser::AdditiveContext>(0);
}


size_t LATEXParser::ExprContext::getRuleIndex() const {
  return LATEXParser::RuleExpr;
}


LATEXParser::ExprContext* LATEXParser::expr() {
  ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, getState());
  enterRule(_localctx, 16, LATEXParser::RuleExpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(279);
    additive(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AdditiveContext ------------------------------------------------------------------

LATEXParser::AdditiveContext::AdditiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::MpContext* LATEXParser::AdditiveContext::mp() {
  return getRuleContext<LATEXParser::MpContext>(0);
}

std::vector<LATEXParser::AdditiveContext *> LATEXParser::AdditiveContext::additive() {
  return getRuleContexts<LATEXParser::AdditiveContext>();
}

LATEXParser::AdditiveContext* LATEXParser::AdditiveContext::additive(size_t i) {
  return getRuleContext<LATEXParser::AdditiveContext>(i);
}

tree::TerminalNode* LATEXParser::AdditiveContext::ADD() {
  return getToken(LATEXParser::ADD, 0);
}

tree::TerminalNode* LATEXParser::AdditiveContext::SUB() {
  return getToken(LATEXParser::SUB, 0);
}


size_t LATEXParser::AdditiveContext::getRuleIndex() const {
  return LATEXParser::RuleAdditive;
}



LATEXParser::AdditiveContext* LATEXParser::additive() {
   return additive(0);
}

LATEXParser::AdditiveContext* LATEXParser::additive(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LATEXParser::AdditiveContext *_localctx = _tracker.createInstance<AdditiveContext>(_ctx, parentState);
  LATEXParser::AdditiveContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 18;
  enterRecursionRule(_localctx, 18, LATEXParser::RuleAdditive, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(282);
    mp(0);
    _ctx->stop = _input->LT(-1);
    setState(289);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<AdditiveContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleAdditive);
        setState(284);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(285);
        _la = _input->LA(1);
        if (!(_la == LATEXParser::ADD

        || _la == LATEXParser::SUB)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(286);
        additive(3); 
      }
      setState(291);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- MpContext ------------------------------------------------------------------

LATEXParser::MpContext::MpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::UnaryContext* LATEXParser::MpContext::unary() {
  return getRuleContext<LATEXParser::UnaryContext>(0);
}

std::vector<LATEXParser::MpContext *> LATEXParser::MpContext::mp() {
  return getRuleContexts<LATEXParser::MpContext>();
}

LATEXParser::MpContext* LATEXParser::MpContext::mp(size_t i) {
  return getRuleContext<LATEXParser::MpContext>(i);
}

tree::TerminalNode* LATEXParser::MpContext::MUL() {
  return getToken(LATEXParser::MUL, 0);
}

tree::TerminalNode* LATEXParser::MpContext::CMD_TIMES() {
  return getToken(LATEXParser::CMD_TIMES, 0);
}

tree::TerminalNode* LATEXParser::MpContext::CMD_CDOT() {
  return getToken(LATEXParser::CMD_CDOT, 0);
}

tree::TerminalNode* LATEXParser::MpContext::DIV() {
  return getToken(LATEXParser::DIV, 0);
}

tree::TerminalNode* LATEXParser::MpContext::CMD_DIV() {
  return getToken(LATEXParser::CMD_DIV, 0);
}

tree::TerminalNode* LATEXParser::MpContext::COLON() {
  return getToken(LATEXParser::COLON, 0);
}

tree::TerminalNode* LATEXParser::MpContext::CMD_MOD() {
  return getToken(LATEXParser::CMD_MOD, 0);
}


size_t LATEXParser::MpContext::getRuleIndex() const {
  return LATEXParser::RuleMp;
}



LATEXParser::MpContext* LATEXParser::mp() {
   return mp(0);
}

LATEXParser::MpContext* LATEXParser::mp(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LATEXParser::MpContext *_localctx = _tracker.createInstance<MpContext>(_ctx, parentState);
  LATEXParser::MpContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 20;
  enterRecursionRule(_localctx, 20, LATEXParser::RuleMp, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(293);
    unary();
    _ctx->stop = _input->LT(-1);
    setState(300);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<MpContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleMp);
        setState(295);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(296);
        _la = _input->LA(1);
        if (!(_la == LATEXParser::MUL

        || _la == LATEXParser::DIV || (((_la - 83) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 83)) & 2097223) != 0)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(297);
        mp(3); 
      }
      setState(302);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Mp_nofuncContext ------------------------------------------------------------------

LATEXParser::Mp_nofuncContext::Mp_nofuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Unary_nofuncContext* LATEXParser::Mp_nofuncContext::unary_nofunc() {
  return getRuleContext<LATEXParser::Unary_nofuncContext>(0);
}

std::vector<LATEXParser::Mp_nofuncContext *> LATEXParser::Mp_nofuncContext::mp_nofunc() {
  return getRuleContexts<LATEXParser::Mp_nofuncContext>();
}

LATEXParser::Mp_nofuncContext* LATEXParser::Mp_nofuncContext::mp_nofunc(size_t i) {
  return getRuleContext<LATEXParser::Mp_nofuncContext>(i);
}

tree::TerminalNode* LATEXParser::Mp_nofuncContext::MUL() {
  return getToken(LATEXParser::MUL, 0);
}

tree::TerminalNode* LATEXParser::Mp_nofuncContext::CMD_TIMES() {
  return getToken(LATEXParser::CMD_TIMES, 0);
}

tree::TerminalNode* LATEXParser::Mp_nofuncContext::CMD_CDOT() {
  return getToken(LATEXParser::CMD_CDOT, 0);
}

tree::TerminalNode* LATEXParser::Mp_nofuncContext::DIV() {
  return getToken(LATEXParser::DIV, 0);
}

tree::TerminalNode* LATEXParser::Mp_nofuncContext::CMD_DIV() {
  return getToken(LATEXParser::CMD_DIV, 0);
}

tree::TerminalNode* LATEXParser::Mp_nofuncContext::COLON() {
  return getToken(LATEXParser::COLON, 0);
}

tree::TerminalNode* LATEXParser::Mp_nofuncContext::CMD_MOD() {
  return getToken(LATEXParser::CMD_MOD, 0);
}


size_t LATEXParser::Mp_nofuncContext::getRuleIndex() const {
  return LATEXParser::RuleMp_nofunc;
}



LATEXParser::Mp_nofuncContext* LATEXParser::mp_nofunc() {
   return mp_nofunc(0);
}

LATEXParser::Mp_nofuncContext* LATEXParser::mp_nofunc(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LATEXParser::Mp_nofuncContext *_localctx = _tracker.createInstance<Mp_nofuncContext>(_ctx, parentState);
  LATEXParser::Mp_nofuncContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 22;
  enterRecursionRule(_localctx, 22, LATEXParser::RuleMp_nofunc, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(304);
    unary_nofunc();
    _ctx->stop = _input->LT(-1);
    setState(311);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Mp_nofuncContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleMp_nofunc);
        setState(306);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(307);
        _la = _input->LA(1);
        if (!(_la == LATEXParser::MUL

        || _la == LATEXParser::DIV || (((_la - 83) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 83)) & 2097223) != 0)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(308);
        mp_nofunc(3); 
      }
      setState(313);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- UnaryContext ------------------------------------------------------------------

LATEXParser::UnaryContext::UnaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::UnaryContext* LATEXParser::UnaryContext::unary() {
  return getRuleContext<LATEXParser::UnaryContext>(0);
}

tree::TerminalNode* LATEXParser::UnaryContext::ADD() {
  return getToken(LATEXParser::ADD, 0);
}

tree::TerminalNode* LATEXParser::UnaryContext::SUB() {
  return getToken(LATEXParser::SUB, 0);
}

std::vector<LATEXParser::PostfixContext *> LATEXParser::UnaryContext::postfix() {
  return getRuleContexts<LATEXParser::PostfixContext>();
}

LATEXParser::PostfixContext* LATEXParser::UnaryContext::postfix(size_t i) {
  return getRuleContext<LATEXParser::PostfixContext>(i);
}


size_t LATEXParser::UnaryContext::getRuleIndex() const {
  return LATEXParser::RuleUnary;
}


LATEXParser::UnaryContext* LATEXParser::unary() {
  UnaryContext *_localctx = _tracker.createInstance<UnaryContext>(_ctx, getState());
  enterRule(_localctx, 24, LATEXParser::RuleUnary);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(321);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::ADD:
      case LATEXParser::SUB: {
        enterOuterAlt(_localctx, 1);
        setState(314);
        _la = _input->LA(1);
        if (!(_la == LATEXParser::ADD

        || _la == LATEXParser::SUB)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(315);
        unary();
        break;
      }

      case LATEXParser::L_PAREN:
      case LATEXParser::L_GROUP:
      case LATEXParser::L_BRACE:
      case LATEXParser::L_BRACE_VISUAL:
      case LATEXParser::L_BRACE_CMD:
      case LATEXParser::L_BRACKET:
      case LATEXParser::L_BRACK:
      case LATEXParser::BAR:
      case LATEXParser::L_VERT:
      case LATEXParser::VERT:
      case LATEXParser::L_FLOOR:
      case LATEXParser::LL_CORNER:
      case LATEXParser::L_CEIL:
      case LATEXParser::UL_CORNER:
      case LATEXParser::L_LEFT:
      case LATEXParser::ML_LEFT:
      case LATEXParser::FUNC_LIM:
      case LATEXParser::FUNC_INT:
      case LATEXParser::FUNC_SUM:
      case LATEXParser::FUNC_PROD:
      case LATEXParser::FUNC_LOG:
      case LATEXParser::FUNC_LN:
      case LATEXParser::FUNC_EXP:
      case LATEXParser::FUNC_SIN:
      case LATEXParser::FUNC_COS:
      case LATEXParser::FUNC_TAN:
      case LATEXParser::FUNC_CSC:
      case LATEXParser::FUNC_SEC:
      case LATEXParser::FUNC_COT:
      case LATEXParser::FUNC_ARCSIN:
      case LATEXParser::FUNC_ARCCOS:
      case LATEXParser::FUNC_ARCTAN:
      case LATEXParser::FUNC_ARCCSC:
      case LATEXParser::FUNC_ARCSEC:
      case LATEXParser::FUNC_ARCCOT:
      case LATEXParser::FUNC_SINH:
      case LATEXParser::FUNC_COSH:
      case LATEXParser::FUNC_TANH:
      case LATEXParser::FUNC_ARSINH:
      case LATEXParser::FUNC_ARCOSH:
      case LATEXParser::FUNC_ARTANH:
      case LATEXParser::FUNC_ARCSINH:
      case LATEXParser::FUNC_ARCCOSH:
      case LATEXParser::FUNC_ARCTANH:
      case LATEXParser::FUNC_SQRT:
      case LATEXParser::FUNC_GCD:
      case LATEXParser::FUNC_LCM:
      case LATEXParser::FUNC_FLOOR:
      case LATEXParser::FUNC_CEIL:
      case LATEXParser::FUNC_MAX:
      case LATEXParser::FUNC_MIN:
      case LATEXParser::CMD_FRAC:
      case LATEXParser::CMD_BINOM:
      case LATEXParser::CMD_CHOOSE:
      case LATEXParser::CMD_MATHIT:
      case LATEXParser::CMD_OPERATORNAME:
      case LATEXParser::CMD_MATRIX_START:
      case LATEXParser::ACCENT_OVERLINE:
      case LATEXParser::ACCENT_BAR:
      case LATEXParser::DIFFERENTIAL:
      case LATEXParser::EXP_E:
      case LATEXParser::LETTER_NO_E:
      case LATEXParser::NUMBER:
      case LATEXParser::FRACTION_NUMBER:
      case LATEXParser::SCI_NOTATION_NUMBER:
      case LATEXParser::E_NOTATION:
      case LATEXParser::PERCENT_NUMBER:
      case LATEXParser::GREEK_CMD:
      case LATEXParser::SYMBOL:
      case LATEXParser::VARIABLE: {
        enterOuterAlt(_localctx, 2);
        setState(317); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(316);
                  postfix();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(319); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_nofuncContext ------------------------------------------------------------------

LATEXParser::Unary_nofuncContext::Unary_nofuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Unary_nofuncContext* LATEXParser::Unary_nofuncContext::unary_nofunc() {
  return getRuleContext<LATEXParser::Unary_nofuncContext>(0);
}

tree::TerminalNode* LATEXParser::Unary_nofuncContext::ADD() {
  return getToken(LATEXParser::ADD, 0);
}

tree::TerminalNode* LATEXParser::Unary_nofuncContext::SUB() {
  return getToken(LATEXParser::SUB, 0);
}

LATEXParser::PostfixContext* LATEXParser::Unary_nofuncContext::postfix() {
  return getRuleContext<LATEXParser::PostfixContext>(0);
}

std::vector<LATEXParser::Postfix_nofuncContext *> LATEXParser::Unary_nofuncContext::postfix_nofunc() {
  return getRuleContexts<LATEXParser::Postfix_nofuncContext>();
}

LATEXParser::Postfix_nofuncContext* LATEXParser::Unary_nofuncContext::postfix_nofunc(size_t i) {
  return getRuleContext<LATEXParser::Postfix_nofuncContext>(i);
}


size_t LATEXParser::Unary_nofuncContext::getRuleIndex() const {
  return LATEXParser::RuleUnary_nofunc;
}


LATEXParser::Unary_nofuncContext* LATEXParser::unary_nofunc() {
  Unary_nofuncContext *_localctx = _tracker.createInstance<Unary_nofuncContext>(_ctx, getState());
  enterRule(_localctx, 26, LATEXParser::RuleUnary_nofunc);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(332);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::ADD:
      case LATEXParser::SUB: {
        enterOuterAlt(_localctx, 1);
        setState(323);
        _la = _input->LA(1);
        if (!(_la == LATEXParser::ADD

        || _la == LATEXParser::SUB)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(324);
        unary_nofunc();
        break;
      }

      case LATEXParser::L_PAREN:
      case LATEXParser::L_GROUP:
      case LATEXParser::L_BRACE:
      case LATEXParser::L_BRACE_VISUAL:
      case LATEXParser::L_BRACE_CMD:
      case LATEXParser::L_BRACKET:
      case LATEXParser::L_BRACK:
      case LATEXParser::BAR:
      case LATEXParser::L_VERT:
      case LATEXParser::VERT:
      case LATEXParser::L_FLOOR:
      case LATEXParser::LL_CORNER:
      case LATEXParser::L_CEIL:
      case LATEXParser::UL_CORNER:
      case LATEXParser::L_LEFT:
      case LATEXParser::ML_LEFT:
      case LATEXParser::FUNC_LIM:
      case LATEXParser::FUNC_INT:
      case LATEXParser::FUNC_SUM:
      case LATEXParser::FUNC_PROD:
      case LATEXParser::FUNC_LOG:
      case LATEXParser::FUNC_LN:
      case LATEXParser::FUNC_EXP:
      case LATEXParser::FUNC_SIN:
      case LATEXParser::FUNC_COS:
      case LATEXParser::FUNC_TAN:
      case LATEXParser::FUNC_CSC:
      case LATEXParser::FUNC_SEC:
      case LATEXParser::FUNC_COT:
      case LATEXParser::FUNC_ARCSIN:
      case LATEXParser::FUNC_ARCCOS:
      case LATEXParser::FUNC_ARCTAN:
      case LATEXParser::FUNC_ARCCSC:
      case LATEXParser::FUNC_ARCSEC:
      case LATEXParser::FUNC_ARCCOT:
      case LATEXParser::FUNC_SINH:
      case LATEXParser::FUNC_COSH:
      case LATEXParser::FUNC_TANH:
      case LATEXParser::FUNC_ARSINH:
      case LATEXParser::FUNC_ARCOSH:
      case LATEXParser::FUNC_ARTANH:
      case LATEXParser::FUNC_ARCSINH:
      case LATEXParser::FUNC_ARCCOSH:
      case LATEXParser::FUNC_ARCTANH:
      case LATEXParser::FUNC_SQRT:
      case LATEXParser::FUNC_GCD:
      case LATEXParser::FUNC_LCM:
      case LATEXParser::FUNC_FLOOR:
      case LATEXParser::FUNC_CEIL:
      case LATEXParser::FUNC_MAX:
      case LATEXParser::FUNC_MIN:
      case LATEXParser::CMD_FRAC:
      case LATEXParser::CMD_BINOM:
      case LATEXParser::CMD_CHOOSE:
      case LATEXParser::CMD_MATHIT:
      case LATEXParser::CMD_OPERATORNAME:
      case LATEXParser::CMD_MATRIX_START:
      case LATEXParser::ACCENT_OVERLINE:
      case LATEXParser::ACCENT_BAR:
      case LATEXParser::DIFFERENTIAL:
      case LATEXParser::EXP_E:
      case LATEXParser::LETTER_NO_E:
      case LATEXParser::NUMBER:
      case LATEXParser::FRACTION_NUMBER:
      case LATEXParser::SCI_NOTATION_NUMBER:
      case LATEXParser::E_NOTATION:
      case LATEXParser::PERCENT_NUMBER:
      case LATEXParser::GREEK_CMD:
      case LATEXParser::SYMBOL:
      case LATEXParser::VARIABLE: {
        enterOuterAlt(_localctx, 2);
        setState(325);
        postfix();
        setState(329);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(326);
            postfix_nofunc(); 
          }
          setState(331);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PostfixContext ------------------------------------------------------------------

LATEXParser::PostfixContext::PostfixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::ExpContext* LATEXParser::PostfixContext::exp() {
  return getRuleContext<LATEXParser::ExpContext>(0);
}

std::vector<LATEXParser::Postfix_opContext *> LATEXParser::PostfixContext::postfix_op() {
  return getRuleContexts<LATEXParser::Postfix_opContext>();
}

LATEXParser::Postfix_opContext* LATEXParser::PostfixContext::postfix_op(size_t i) {
  return getRuleContext<LATEXParser::Postfix_opContext>(i);
}


size_t LATEXParser::PostfixContext::getRuleIndex() const {
  return LATEXParser::RulePostfix;
}


LATEXParser::PostfixContext* LATEXParser::postfix() {
  PostfixContext *_localctx = _tracker.createInstance<PostfixContext>(_ctx, getState());
  enterRule(_localctx, 28, LATEXParser::RulePostfix);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(334);
    exp(0);
    setState(338);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(335);
        postfix_op(); 
      }
      setState(340);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Postfix_nofuncContext ------------------------------------------------------------------

LATEXParser::Postfix_nofuncContext::Postfix_nofuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Exp_nofuncContext* LATEXParser::Postfix_nofuncContext::exp_nofunc() {
  return getRuleContext<LATEXParser::Exp_nofuncContext>(0);
}

std::vector<LATEXParser::Postfix_opContext *> LATEXParser::Postfix_nofuncContext::postfix_op() {
  return getRuleContexts<LATEXParser::Postfix_opContext>();
}

LATEXParser::Postfix_opContext* LATEXParser::Postfix_nofuncContext::postfix_op(size_t i) {
  return getRuleContext<LATEXParser::Postfix_opContext>(i);
}


size_t LATEXParser::Postfix_nofuncContext::getRuleIndex() const {
  return LATEXParser::RulePostfix_nofunc;
}


LATEXParser::Postfix_nofuncContext* LATEXParser::postfix_nofunc() {
  Postfix_nofuncContext *_localctx = _tracker.createInstance<Postfix_nofuncContext>(_ctx, getState());
  enterRule(_localctx, 30, LATEXParser::RulePostfix_nofunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(341);
    exp_nofunc(0);
    setState(345);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(342);
        postfix_op(); 
      }
      setState(347);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Postfix_opContext ------------------------------------------------------------------

LATEXParser::Postfix_opContext::Postfix_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Postfix_opContext::BANG() {
  return getToken(LATEXParser::BANG, 0);
}

LATEXParser::Eval_atContext* LATEXParser::Postfix_opContext::eval_at() {
  return getRuleContext<LATEXParser::Eval_atContext>(0);
}


size_t LATEXParser::Postfix_opContext::getRuleIndex() const {
  return LATEXParser::RulePostfix_op;
}


LATEXParser::Postfix_opContext* LATEXParser::postfix_op() {
  Postfix_opContext *_localctx = _tracker.createInstance<Postfix_opContext>(_ctx, getState());
  enterRule(_localctx, 32, LATEXParser::RulePostfix_op);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(350);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::BANG: {
        enterOuterAlt(_localctx, 1);
        setState(348);
        match(LATEXParser::BANG);
        break;
      }

      case LATEXParser::BAR: {
        enterOuterAlt(_localctx, 2);
        setState(349);
        eval_at();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Eval_atContext ------------------------------------------------------------------

LATEXParser::Eval_atContext::Eval_atContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Eval_atContext::BAR() {
  return getToken(LATEXParser::BAR, 0);
}

LATEXParser::Eval_at_supContext* LATEXParser::Eval_atContext::eval_at_sup() {
  return getRuleContext<LATEXParser::Eval_at_supContext>(0);
}

LATEXParser::Eval_at_subContext* LATEXParser::Eval_atContext::eval_at_sub() {
  return getRuleContext<LATEXParser::Eval_at_subContext>(0);
}


size_t LATEXParser::Eval_atContext::getRuleIndex() const {
  return LATEXParser::RuleEval_at;
}


LATEXParser::Eval_atContext* LATEXParser::eval_at() {
  Eval_atContext *_localctx = _tracker.createInstance<Eval_atContext>(_ctx, getState());
  enterRule(_localctx, 34, LATEXParser::RuleEval_at);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(352);
    match(LATEXParser::BAR);
    setState(358);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      setState(353);
      eval_at_sup();
      break;
    }

    case 2: {
      setState(354);
      eval_at_sub();
      break;
    }

    case 3: {
      setState(355);
      eval_at_sup();
      setState(356);
      eval_at_sub();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Eval_at_subContext ------------------------------------------------------------------

LATEXParser::Eval_at_subContext::Eval_at_subContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Eval_at_subContext::UNDERSCORE() {
  return getToken(LATEXParser::UNDERSCORE, 0);
}

tree::TerminalNode* LATEXParser::Eval_at_subContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

tree::TerminalNode* LATEXParser::Eval_at_subContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

LATEXParser::ExprContext* LATEXParser::Eval_at_subContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

LATEXParser::EqualityContext* LATEXParser::Eval_at_subContext::equality() {
  return getRuleContext<LATEXParser::EqualityContext>(0);
}


size_t LATEXParser::Eval_at_subContext::getRuleIndex() const {
  return LATEXParser::RuleEval_at_sub;
}


LATEXParser::Eval_at_subContext* LATEXParser::eval_at_sub() {
  Eval_at_subContext *_localctx = _tracker.createInstance<Eval_at_subContext>(_ctx, getState());
  enterRule(_localctx, 36, LATEXParser::RuleEval_at_sub);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(360);
    match(LATEXParser::UNDERSCORE);
    setState(361);
    match(LATEXParser::L_BRACE);
    setState(364);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      setState(362);
      expr();
      break;
    }

    case 2: {
      setState(363);
      equality();
      break;
    }

    default:
      break;
    }
    setState(366);
    match(LATEXParser::R_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Eval_at_supContext ------------------------------------------------------------------

LATEXParser::Eval_at_supContext::Eval_at_supContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Eval_at_supContext::CARET() {
  return getToken(LATEXParser::CARET, 0);
}

tree::TerminalNode* LATEXParser::Eval_at_supContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

tree::TerminalNode* LATEXParser::Eval_at_supContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

LATEXParser::ExprContext* LATEXParser::Eval_at_supContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

LATEXParser::EqualityContext* LATEXParser::Eval_at_supContext::equality() {
  return getRuleContext<LATEXParser::EqualityContext>(0);
}


size_t LATEXParser::Eval_at_supContext::getRuleIndex() const {
  return LATEXParser::RuleEval_at_sup;
}


LATEXParser::Eval_at_supContext* LATEXParser::eval_at_sup() {
  Eval_at_supContext *_localctx = _tracker.createInstance<Eval_at_supContext>(_ctx, getState());
  enterRule(_localctx, 38, LATEXParser::RuleEval_at_sup);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(368);
    match(LATEXParser::CARET);
    setState(369);
    match(LATEXParser::L_BRACE);
    setState(372);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
    case 1: {
      setState(370);
      expr();
      break;
    }

    case 2: {
      setState(371);
      equality();
      break;
    }

    default:
      break;
    }
    setState(374);
    match(LATEXParser::R_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpContext ------------------------------------------------------------------

LATEXParser::ExpContext::ExpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::CompContext* LATEXParser::ExpContext::comp() {
  return getRuleContext<LATEXParser::CompContext>(0);
}

LATEXParser::ExpContext* LATEXParser::ExpContext::exp() {
  return getRuleContext<LATEXParser::ExpContext>(0);
}

tree::TerminalNode* LATEXParser::ExpContext::CARET() {
  return getToken(LATEXParser::CARET, 0);
}

LATEXParser::AtomContext* LATEXParser::ExpContext::atom() {
  return getRuleContext<LATEXParser::AtomContext>(0);
}

tree::TerminalNode* LATEXParser::ExpContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

LATEXParser::ExprContext* LATEXParser::ExpContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::ExpContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

LATEXParser::SubexprContext* LATEXParser::ExpContext::subexpr() {
  return getRuleContext<LATEXParser::SubexprContext>(0);
}


size_t LATEXParser::ExpContext::getRuleIndex() const {
  return LATEXParser::RuleExp;
}



LATEXParser::ExpContext* LATEXParser::exp() {
   return exp(0);
}

LATEXParser::ExpContext* LATEXParser::exp(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LATEXParser::ExpContext *_localctx = _tracker.createInstance<ExpContext>(_ctx, parentState);
  LATEXParser::ExpContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 40;
  enterRecursionRule(_localctx, 40, LATEXParser::RuleExp, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(377);
    comp();
    _ctx->stop = _input->LT(-1);
    setState(393);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<ExpContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleExp);
        setState(379);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(380);
        match(LATEXParser::CARET);
        setState(386);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case LATEXParser::CMD_MATHIT:
          case LATEXParser::ACCENT_OVERLINE:
          case LATEXParser::ACCENT_BAR:
          case LATEXParser::DIFFERENTIAL:
          case LATEXParser::LETTER_NO_E:
          case LATEXParser::NUMBER:
          case LATEXParser::FRACTION_NUMBER:
          case LATEXParser::SCI_NOTATION_NUMBER:
          case LATEXParser::E_NOTATION:
          case LATEXParser::PERCENT_NUMBER:
          case LATEXParser::GREEK_CMD:
          case LATEXParser::SYMBOL:
          case LATEXParser::VARIABLE: {
            setState(381);
            atom();
            break;
          }

          case LATEXParser::L_BRACE: {
            setState(382);
            match(LATEXParser::L_BRACE);
            setState(383);
            expr();
            setState(384);
            match(LATEXParser::R_BRACE);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(389);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
        case 1: {
          setState(388);
          subexpr();
          break;
        }

        default:
          break;
        } 
      }
      setState(395);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Exp_nofuncContext ------------------------------------------------------------------

LATEXParser::Exp_nofuncContext::Exp_nofuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Comp_nofuncContext* LATEXParser::Exp_nofuncContext::comp_nofunc() {
  return getRuleContext<LATEXParser::Comp_nofuncContext>(0);
}

LATEXParser::Exp_nofuncContext* LATEXParser::Exp_nofuncContext::exp_nofunc() {
  return getRuleContext<LATEXParser::Exp_nofuncContext>(0);
}

tree::TerminalNode* LATEXParser::Exp_nofuncContext::CARET() {
  return getToken(LATEXParser::CARET, 0);
}

LATEXParser::AtomContext* LATEXParser::Exp_nofuncContext::atom() {
  return getRuleContext<LATEXParser::AtomContext>(0);
}

tree::TerminalNode* LATEXParser::Exp_nofuncContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

LATEXParser::ExprContext* LATEXParser::Exp_nofuncContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::Exp_nofuncContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

LATEXParser::SubexprContext* LATEXParser::Exp_nofuncContext::subexpr() {
  return getRuleContext<LATEXParser::SubexprContext>(0);
}


size_t LATEXParser::Exp_nofuncContext::getRuleIndex() const {
  return LATEXParser::RuleExp_nofunc;
}



LATEXParser::Exp_nofuncContext* LATEXParser::exp_nofunc() {
   return exp_nofunc(0);
}

LATEXParser::Exp_nofuncContext* LATEXParser::exp_nofunc(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LATEXParser::Exp_nofuncContext *_localctx = _tracker.createInstance<Exp_nofuncContext>(_ctx, parentState);
  LATEXParser::Exp_nofuncContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 42;
  enterRecursionRule(_localctx, 42, LATEXParser::RuleExp_nofunc, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(397);
    comp_nofunc();
    _ctx->stop = _input->LT(-1);
    setState(413);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Exp_nofuncContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleExp_nofunc);
        setState(399);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(400);
        match(LATEXParser::CARET);
        setState(406);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case LATEXParser::CMD_MATHIT:
          case LATEXParser::ACCENT_OVERLINE:
          case LATEXParser::ACCENT_BAR:
          case LATEXParser::DIFFERENTIAL:
          case LATEXParser::LETTER_NO_E:
          case LATEXParser::NUMBER:
          case LATEXParser::FRACTION_NUMBER:
          case LATEXParser::SCI_NOTATION_NUMBER:
          case LATEXParser::E_NOTATION:
          case LATEXParser::PERCENT_NUMBER:
          case LATEXParser::GREEK_CMD:
          case LATEXParser::SYMBOL:
          case LATEXParser::VARIABLE: {
            setState(401);
            atom();
            break;
          }

          case LATEXParser::L_BRACE: {
            setState(402);
            match(LATEXParser::L_BRACE);
            setState(403);
            expr();
            setState(404);
            match(LATEXParser::R_BRACE);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(409);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
        case 1: {
          setState(408);
          subexpr();
          break;
        }

        default:
          break;
        } 
      }
      setState(415);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- CompContext ------------------------------------------------------------------

LATEXParser::CompContext::CompContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::GroupContext* LATEXParser::CompContext::group() {
  return getRuleContext<LATEXParser::GroupContext>(0);
}

LATEXParser::Abs_groupContext* LATEXParser::CompContext::abs_group() {
  return getRuleContext<LATEXParser::Abs_groupContext>(0);
}

LATEXParser::Floor_groupContext* LATEXParser::CompContext::floor_group() {
  return getRuleContext<LATEXParser::Floor_groupContext>(0);
}

LATEXParser::Ceil_groupContext* LATEXParser::CompContext::ceil_group() {
  return getRuleContext<LATEXParser::Ceil_groupContext>(0);
}

LATEXParser::FuncContext* LATEXParser::CompContext::func() {
  return getRuleContext<LATEXParser::FuncContext>(0);
}

LATEXParser::AtomContext* LATEXParser::CompContext::atom() {
  return getRuleContext<LATEXParser::AtomContext>(0);
}

LATEXParser::FracContext* LATEXParser::CompContext::frac() {
  return getRuleContext<LATEXParser::FracContext>(0);
}

LATEXParser::BinomContext* LATEXParser::CompContext::binom() {
  return getRuleContext<LATEXParser::BinomContext>(0);
}

LATEXParser::MatrixContext* LATEXParser::CompContext::matrix() {
  return getRuleContext<LATEXParser::MatrixContext>(0);
}


size_t LATEXParser::CompContext::getRuleIndex() const {
  return LATEXParser::RuleComp;
}


LATEXParser::CompContext* LATEXParser::comp() {
  CompContext *_localctx = _tracker.createInstance<CompContext>(_ctx, getState());
  enterRule(_localctx, 44, LATEXParser::RuleComp);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(425);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(416);
      group();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(417);
      abs_group();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(418);
      floor_group();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(419);
      ceil_group();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(420);
      func();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(421);
      atom();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(422);
      frac();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(423);
      binom();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(424);
      matrix();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comp_nofuncContext ------------------------------------------------------------------

LATEXParser::Comp_nofuncContext::Comp_nofuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::GroupContext* LATEXParser::Comp_nofuncContext::group() {
  return getRuleContext<LATEXParser::GroupContext>(0);
}

LATEXParser::Abs_groupContext* LATEXParser::Comp_nofuncContext::abs_group() {
  return getRuleContext<LATEXParser::Abs_groupContext>(0);
}

LATEXParser::Floor_groupContext* LATEXParser::Comp_nofuncContext::floor_group() {
  return getRuleContext<LATEXParser::Floor_groupContext>(0);
}

LATEXParser::Ceil_groupContext* LATEXParser::Comp_nofuncContext::ceil_group() {
  return getRuleContext<LATEXParser::Ceil_groupContext>(0);
}

LATEXParser::AtomContext* LATEXParser::Comp_nofuncContext::atom() {
  return getRuleContext<LATEXParser::AtomContext>(0);
}

LATEXParser::FracContext* LATEXParser::Comp_nofuncContext::frac() {
  return getRuleContext<LATEXParser::FracContext>(0);
}

LATEXParser::BinomContext* LATEXParser::Comp_nofuncContext::binom() {
  return getRuleContext<LATEXParser::BinomContext>(0);
}

LATEXParser::MatrixContext* LATEXParser::Comp_nofuncContext::matrix() {
  return getRuleContext<LATEXParser::MatrixContext>(0);
}


size_t LATEXParser::Comp_nofuncContext::getRuleIndex() const {
  return LATEXParser::RuleComp_nofunc;
}


LATEXParser::Comp_nofuncContext* LATEXParser::comp_nofunc() {
  Comp_nofuncContext *_localctx = _tracker.createInstance<Comp_nofuncContext>(_ctx, getState());
  enterRule(_localctx, 46, LATEXParser::RuleComp_nofunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(435);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(427);
      group();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(428);
      abs_group();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(429);
      floor_group();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(430);
      ceil_group();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(431);
      atom();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(432);
      frac();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(433);
      binom();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(434);
      matrix();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupContext ------------------------------------------------------------------

LATEXParser::GroupContext::GroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::GroupContext::L_PAREN() {
  return getToken(LATEXParser::L_PAREN, 0);
}

LATEXParser::ExprContext* LATEXParser::GroupContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::GroupContext::R_PAREN() {
  return getToken(LATEXParser::R_PAREN, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::L_GROUP() {
  return getToken(LATEXParser::L_GROUP, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::R_GROUP() {
  return getToken(LATEXParser::R_GROUP, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::L_BRACE_VISUAL() {
  return getToken(LATEXParser::L_BRACE_VISUAL, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::R_BRACE_VISUAL() {
  return getToken(LATEXParser::R_BRACE_VISUAL, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::L_BRACE_CMD() {
  return getToken(LATEXParser::L_BRACE_CMD, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::R_BRACE_CMD() {
  return getToken(LATEXParser::R_BRACE_CMD, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::L_BRACKET() {
  return getToken(LATEXParser::L_BRACKET, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::R_BRACKET() {
  return getToken(LATEXParser::R_BRACKET, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::L_BRACK() {
  return getToken(LATEXParser::L_BRACK, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::R_BRACK() {
  return getToken(LATEXParser::R_BRACK, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::L_LEFT() {
  return getToken(LATEXParser::L_LEFT, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::R_RIGHT() {
  return getToken(LATEXParser::R_RIGHT, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::ML_LEFT() {
  return getToken(LATEXParser::ML_LEFT, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::MR_RIGHT() {
  return getToken(LATEXParser::MR_RIGHT, 0);
}


size_t LATEXParser::GroupContext::getRuleIndex() const {
  return LATEXParser::RuleGroup;
}


LATEXParser::GroupContext* LATEXParser::group() {
  GroupContext *_localctx = _tracker.createInstance<GroupContext>(_ctx, getState());
  enterRule(_localctx, 48, LATEXParser::RuleGroup);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(549);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(437);
      match(LATEXParser::L_PAREN);
      setState(438);
      expr();
      setState(439);
      match(LATEXParser::R_PAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(441);
      match(LATEXParser::L_GROUP);
      setState(442);
      expr();
      setState(443);
      match(LATEXParser::R_GROUP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(445);
      match(LATEXParser::L_BRACE);
      setState(446);
      expr();
      setState(447);
      match(LATEXParser::R_BRACE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(449);
      match(LATEXParser::L_BRACE_VISUAL);
      setState(450);
      expr();
      setState(451);
      match(LATEXParser::R_BRACE_VISUAL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(453);
      match(LATEXParser::L_BRACE_CMD);
      setState(454);
      expr();
      setState(455);
      match(LATEXParser::R_BRACE_CMD);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(457);
      match(LATEXParser::L_BRACKET);
      setState(458);
      expr();
      setState(459);
      match(LATEXParser::R_BRACKET);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(461);
      match(LATEXParser::L_BRACK);
      setState(462);
      expr();
      setState(463);
      match(LATEXParser::R_BRACK);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(465);
      match(LATEXParser::L_LEFT);
      setState(466);
      match(LATEXParser::L_PAREN);
      setState(467);
      expr();
      setState(468);
      match(LATEXParser::R_RIGHT);
      setState(469);
      match(LATEXParser::R_PAREN);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(471);
      match(LATEXParser::L_LEFT);
      setState(472);
      match(LATEXParser::L_GROUP);
      setState(473);
      expr();
      setState(474);
      match(LATEXParser::R_RIGHT);
      setState(475);
      match(LATEXParser::R_GROUP);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(477);
      match(LATEXParser::L_LEFT);
      setState(478);
      match(LATEXParser::L_BRACE);
      setState(479);
      expr();
      setState(480);
      match(LATEXParser::R_RIGHT);
      setState(481);
      match(LATEXParser::R_BRACE);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(483);
      match(LATEXParser::L_LEFT);
      setState(484);
      match(LATEXParser::L_BRACE_VISUAL);
      setState(485);
      expr();
      setState(486);
      match(LATEXParser::R_RIGHT);
      setState(487);
      match(LATEXParser::R_BRACE_VISUAL);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(489);
      match(LATEXParser::L_LEFT);
      setState(490);
      match(LATEXParser::L_BRACE_CMD);
      setState(491);
      expr();
      setState(492);
      match(LATEXParser::R_RIGHT);
      setState(493);
      match(LATEXParser::R_BRACE_CMD);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(495);
      match(LATEXParser::L_LEFT);
      setState(496);
      match(LATEXParser::L_BRACKET);
      setState(497);
      expr();
      setState(498);
      match(LATEXParser::R_RIGHT);
      setState(499);
      match(LATEXParser::R_BRACKET);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(501);
      match(LATEXParser::L_LEFT);
      setState(502);
      match(LATEXParser::L_BRACK);
      setState(503);
      expr();
      setState(504);
      match(LATEXParser::R_RIGHT);
      setState(505);
      match(LATEXParser::R_BRACK);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(507);
      match(LATEXParser::ML_LEFT);
      setState(508);
      match(LATEXParser::L_PAREN);
      setState(509);
      expr();
      setState(510);
      match(LATEXParser::MR_RIGHT);
      setState(511);
      match(LATEXParser::R_PAREN);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(513);
      match(LATEXParser::ML_LEFT);
      setState(514);
      match(LATEXParser::L_GROUP);
      setState(515);
      expr();
      setState(516);
      match(LATEXParser::MR_RIGHT);
      setState(517);
      match(LATEXParser::R_GROUP);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(519);
      match(LATEXParser::ML_LEFT);
      setState(520);
      match(LATEXParser::L_BRACE);
      setState(521);
      expr();
      setState(522);
      match(LATEXParser::MR_RIGHT);
      setState(523);
      match(LATEXParser::R_BRACE);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(525);
      match(LATEXParser::ML_LEFT);
      setState(526);
      match(LATEXParser::L_BRACE_VISUAL);
      setState(527);
      expr();
      setState(528);
      match(LATEXParser::MR_RIGHT);
      setState(529);
      match(LATEXParser::R_BRACE_VISUAL);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(531);
      match(LATEXParser::ML_LEFT);
      setState(532);
      match(LATEXParser::L_BRACE_CMD);
      setState(533);
      expr();
      setState(534);
      match(LATEXParser::MR_RIGHT);
      setState(535);
      match(LATEXParser::R_BRACE_CMD);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(537);
      match(LATEXParser::ML_LEFT);
      setState(538);
      match(LATEXParser::L_BRACKET);
      setState(539);
      expr();
      setState(540);
      match(LATEXParser::MR_RIGHT);
      setState(541);
      match(LATEXParser::R_BRACKET);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(543);
      match(LATEXParser::ML_LEFT);
      setState(544);
      match(LATEXParser::L_BRACK);
      setState(545);
      expr();
      setState(546);
      match(LATEXParser::MR_RIGHT);
      setState(547);
      match(LATEXParser::R_BRACK);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Abs_groupContext ------------------------------------------------------------------

LATEXParser::Abs_groupContext::Abs_groupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LATEXParser::Abs_groupContext::BAR() {
  return getTokens(LATEXParser::BAR);
}

tree::TerminalNode* LATEXParser::Abs_groupContext::BAR(size_t i) {
  return getToken(LATEXParser::BAR, i);
}

LATEXParser::ExprContext* LATEXParser::Abs_groupContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::Abs_groupContext::L_VERT() {
  return getToken(LATEXParser::L_VERT, 0);
}

tree::TerminalNode* LATEXParser::Abs_groupContext::R_VERT() {
  return getToken(LATEXParser::R_VERT, 0);
}

std::vector<tree::TerminalNode *> LATEXParser::Abs_groupContext::VERT() {
  return getTokens(LATEXParser::VERT);
}

tree::TerminalNode* LATEXParser::Abs_groupContext::VERT(size_t i) {
  return getToken(LATEXParser::VERT, i);
}

tree::TerminalNode* LATEXParser::Abs_groupContext::L_LEFT() {
  return getToken(LATEXParser::L_LEFT, 0);
}

tree::TerminalNode* LATEXParser::Abs_groupContext::R_RIGHT() {
  return getToken(LATEXParser::R_RIGHT, 0);
}

tree::TerminalNode* LATEXParser::Abs_groupContext::ML_LEFT() {
  return getToken(LATEXParser::ML_LEFT, 0);
}

tree::TerminalNode* LATEXParser::Abs_groupContext::MR_RIGHT() {
  return getToken(LATEXParser::MR_RIGHT, 0);
}


size_t LATEXParser::Abs_groupContext::getRuleIndex() const {
  return LATEXParser::RuleAbs_group;
}


LATEXParser::Abs_groupContext* LATEXParser::abs_group() {
  Abs_groupContext *_localctx = _tracker.createInstance<Abs_groupContext>(_ctx, getState());
  enterRule(_localctx, 50, LATEXParser::RuleAbs_group);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(599);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(551);
      match(LATEXParser::BAR);
      setState(552);
      expr();
      setState(553);
      match(LATEXParser::BAR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(555);
      match(LATEXParser::L_VERT);
      setState(556);
      expr();
      setState(557);
      match(LATEXParser::R_VERT);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(559);
      match(LATEXParser::VERT);
      setState(560);
      expr();
      setState(561);
      match(LATEXParser::VERT);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(563);
      match(LATEXParser::L_LEFT);
      setState(564);
      match(LATEXParser::BAR);
      setState(565);
      expr();
      setState(566);
      match(LATEXParser::R_RIGHT);
      setState(567);
      match(LATEXParser::BAR);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(569);
      match(LATEXParser::L_LEFT);
      setState(570);
      match(LATEXParser::L_VERT);
      setState(571);
      expr();
      setState(572);
      match(LATEXParser::R_RIGHT);
      setState(573);
      match(LATEXParser::R_VERT);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(575);
      match(LATEXParser::L_LEFT);
      setState(576);
      match(LATEXParser::VERT);
      setState(577);
      expr();
      setState(578);
      match(LATEXParser::R_RIGHT);
      setState(579);
      match(LATEXParser::VERT);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(581);
      match(LATEXParser::ML_LEFT);
      setState(582);
      match(LATEXParser::BAR);
      setState(583);
      expr();
      setState(584);
      match(LATEXParser::MR_RIGHT);
      setState(585);
      match(LATEXParser::BAR);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(587);
      match(LATEXParser::ML_LEFT);
      setState(588);
      match(LATEXParser::L_VERT);
      setState(589);
      expr();
      setState(590);
      match(LATEXParser::MR_RIGHT);
      setState(591);
      match(LATEXParser::R_VERT);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(593);
      match(LATEXParser::ML_LEFT);
      setState(594);
      match(LATEXParser::VERT);
      setState(595);
      expr();
      setState(596);
      match(LATEXParser::MR_RIGHT);
      setState(597);
      match(LATEXParser::VERT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Floor_groupContext ------------------------------------------------------------------

LATEXParser::Floor_groupContext::Floor_groupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Floor_groupContext::L_FLOOR() {
  return getToken(LATEXParser::L_FLOOR, 0);
}

LATEXParser::ExprContext* LATEXParser::Floor_groupContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::Floor_groupContext::R_FLOOR() {
  return getToken(LATEXParser::R_FLOOR, 0);
}

tree::TerminalNode* LATEXParser::Floor_groupContext::LL_CORNER() {
  return getToken(LATEXParser::LL_CORNER, 0);
}

tree::TerminalNode* LATEXParser::Floor_groupContext::LR_CORNER() {
  return getToken(LATEXParser::LR_CORNER, 0);
}

tree::TerminalNode* LATEXParser::Floor_groupContext::L_LEFT() {
  return getToken(LATEXParser::L_LEFT, 0);
}

tree::TerminalNode* LATEXParser::Floor_groupContext::R_RIGHT() {
  return getToken(LATEXParser::R_RIGHT, 0);
}

tree::TerminalNode* LATEXParser::Floor_groupContext::ML_LEFT() {
  return getToken(LATEXParser::ML_LEFT, 0);
}

tree::TerminalNode* LATEXParser::Floor_groupContext::MR_RIGHT() {
  return getToken(LATEXParser::MR_RIGHT, 0);
}


size_t LATEXParser::Floor_groupContext::getRuleIndex() const {
  return LATEXParser::RuleFloor_group;
}


LATEXParser::Floor_groupContext* LATEXParser::floor_group() {
  Floor_groupContext *_localctx = _tracker.createInstance<Floor_groupContext>(_ctx, getState());
  enterRule(_localctx, 52, LATEXParser::RuleFloor_group);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(633);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(601);
      match(LATEXParser::L_FLOOR);
      setState(602);
      expr();
      setState(603);
      match(LATEXParser::R_FLOOR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(605);
      match(LATEXParser::LL_CORNER);
      setState(606);
      expr();
      setState(607);
      match(LATEXParser::LR_CORNER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(609);
      match(LATEXParser::L_LEFT);
      setState(610);
      match(LATEXParser::L_FLOOR);
      setState(611);
      expr();
      setState(612);
      match(LATEXParser::R_RIGHT);
      setState(613);
      match(LATEXParser::R_FLOOR);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(615);
      match(LATEXParser::L_LEFT);
      setState(616);
      match(LATEXParser::LL_CORNER);
      setState(617);
      expr();
      setState(618);
      match(LATEXParser::R_RIGHT);
      setState(619);
      match(LATEXParser::LR_CORNER);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(621);
      match(LATEXParser::ML_LEFT);
      setState(622);
      match(LATEXParser::L_FLOOR);
      setState(623);
      expr();
      setState(624);
      match(LATEXParser::MR_RIGHT);
      setState(625);
      match(LATEXParser::R_FLOOR);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(627);
      match(LATEXParser::ML_LEFT);
      setState(628);
      match(LATEXParser::LL_CORNER);
      setState(629);
      expr();
      setState(630);
      match(LATEXParser::MR_RIGHT);
      setState(631);
      match(LATEXParser::LR_CORNER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ceil_groupContext ------------------------------------------------------------------

LATEXParser::Ceil_groupContext::Ceil_groupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Ceil_groupContext::L_CEIL() {
  return getToken(LATEXParser::L_CEIL, 0);
}

LATEXParser::ExprContext* LATEXParser::Ceil_groupContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::Ceil_groupContext::R_CEIL() {
  return getToken(LATEXParser::R_CEIL, 0);
}

tree::TerminalNode* LATEXParser::Ceil_groupContext::UL_CORNER() {
  return getToken(LATEXParser::UL_CORNER, 0);
}

tree::TerminalNode* LATEXParser::Ceil_groupContext::UR_CORNER() {
  return getToken(LATEXParser::UR_CORNER, 0);
}

tree::TerminalNode* LATEXParser::Ceil_groupContext::L_LEFT() {
  return getToken(LATEXParser::L_LEFT, 0);
}

tree::TerminalNode* LATEXParser::Ceil_groupContext::R_RIGHT() {
  return getToken(LATEXParser::R_RIGHT, 0);
}

tree::TerminalNode* LATEXParser::Ceil_groupContext::ML_LEFT() {
  return getToken(LATEXParser::ML_LEFT, 0);
}

tree::TerminalNode* LATEXParser::Ceil_groupContext::MR_RIGHT() {
  return getToken(LATEXParser::MR_RIGHT, 0);
}


size_t LATEXParser::Ceil_groupContext::getRuleIndex() const {
  return LATEXParser::RuleCeil_group;
}


LATEXParser::Ceil_groupContext* LATEXParser::ceil_group() {
  Ceil_groupContext *_localctx = _tracker.createInstance<Ceil_groupContext>(_ctx, getState());
  enterRule(_localctx, 54, LATEXParser::RuleCeil_group);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(667);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(635);
      match(LATEXParser::L_CEIL);
      setState(636);
      expr();
      setState(637);
      match(LATEXParser::R_CEIL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(639);
      match(LATEXParser::UL_CORNER);
      setState(640);
      expr();
      setState(641);
      match(LATEXParser::UR_CORNER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(643);
      match(LATEXParser::L_LEFT);
      setState(644);
      match(LATEXParser::L_CEIL);
      setState(645);
      expr();
      setState(646);
      match(LATEXParser::R_RIGHT);
      setState(647);
      match(LATEXParser::R_CEIL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(649);
      match(LATEXParser::L_LEFT);
      setState(650);
      match(LATEXParser::UL_CORNER);
      setState(651);
      expr();
      setState(652);
      match(LATEXParser::R_RIGHT);
      setState(653);
      match(LATEXParser::UR_CORNER);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(655);
      match(LATEXParser::ML_LEFT);
      setState(656);
      match(LATEXParser::L_CEIL);
      setState(657);
      expr();
      setState(658);
      match(LATEXParser::MR_RIGHT);
      setState(659);
      match(LATEXParser::R_CEIL);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(661);
      match(LATEXParser::ML_LEFT);
      setState(662);
      match(LATEXParser::UL_CORNER);
      setState(663);
      expr();
      setState(664);
      match(LATEXParser::MR_RIGHT);
      setState(665);
      match(LATEXParser::UR_CORNER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccentContext ------------------------------------------------------------------

LATEXParser::AccentContext::AccentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Accent_symbolContext* LATEXParser::AccentContext::accent_symbol() {
  return getRuleContext<LATEXParser::Accent_symbolContext>(0);
}

tree::TerminalNode* LATEXParser::AccentContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

tree::TerminalNode* LATEXParser::AccentContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

LATEXParser::ExprContext* LATEXParser::AccentContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}


size_t LATEXParser::AccentContext::getRuleIndex() const {
  return LATEXParser::RuleAccent;
}


LATEXParser::AccentContext* LATEXParser::accent() {
  AccentContext *_localctx = _tracker.createInstance<AccentContext>(_ctx, getState());
  enterRule(_localctx, 56, LATEXParser::RuleAccent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(669);
    accent_symbol();
    setState(670);
    match(LATEXParser::L_BRACE);
    setState(671);
    antlrcpp::downCast<AccentContext *>(_localctx)->base = expr();
    setState(672);
    match(LATEXParser::R_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Atom_exprContext ------------------------------------------------------------------

LATEXParser::Atom_exprContext::Atom_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Atom_exprContext::LETTER_NO_E() {
  return getToken(LATEXParser::LETTER_NO_E, 0);
}

tree::TerminalNode* LATEXParser::Atom_exprContext::GREEK_CMD() {
  return getToken(LATEXParser::GREEK_CMD, 0);
}

LATEXParser::AccentContext* LATEXParser::Atom_exprContext::accent() {
  return getRuleContext<LATEXParser::AccentContext>(0);
}

LATEXParser::SupexprContext* LATEXParser::Atom_exprContext::supexpr() {
  return getRuleContext<LATEXParser::SupexprContext>(0);
}

LATEXParser::SubexprContext* LATEXParser::Atom_exprContext::subexpr() {
  return getRuleContext<LATEXParser::SubexprContext>(0);
}


size_t LATEXParser::Atom_exprContext::getRuleIndex() const {
  return LATEXParser::RuleAtom_expr;
}


LATEXParser::Atom_exprContext* LATEXParser::atom_expr() {
  Atom_exprContext *_localctx = _tracker.createInstance<Atom_exprContext>(_ctx, getState());
  enterRule(_localctx, 58, LATEXParser::RuleAtom_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(677);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::LETTER_NO_E: {
        setState(674);
        match(LATEXParser::LETTER_NO_E);
        break;
      }

      case LATEXParser::GREEK_CMD: {
        setState(675);
        match(LATEXParser::GREEK_CMD);
        break;
      }

      case LATEXParser::ACCENT_OVERLINE:
      case LATEXParser::ACCENT_BAR: {
        setState(676);
        accent();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(687);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
    case 1: {
      setState(679);
      supexpr();
      setState(680);
      subexpr();
      break;
    }

    case 2: {
      setState(682);
      subexpr();
      setState(683);
      supexpr();
      break;
    }

    case 3: {
      setState(685);
      subexpr();
      break;
    }

    case 4: {
      setState(686);
      supexpr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AtomContext ------------------------------------------------------------------

LATEXParser::AtomContext::AtomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Atom_exprContext* LATEXParser::AtomContext::atom_expr() {
  return getRuleContext<LATEXParser::Atom_exprContext>(0);
}

tree::TerminalNode* LATEXParser::AtomContext::SYMBOL() {
  return getToken(LATEXParser::SYMBOL, 0);
}

tree::TerminalNode* LATEXParser::AtomContext::NUMBER() {
  return getToken(LATEXParser::NUMBER, 0);
}

tree::TerminalNode* LATEXParser::AtomContext::SCI_NOTATION_NUMBER() {
  return getToken(LATEXParser::SCI_NOTATION_NUMBER, 0);
}

tree::TerminalNode* LATEXParser::AtomContext::FRACTION_NUMBER() {
  return getToken(LATEXParser::FRACTION_NUMBER, 0);
}

tree::TerminalNode* LATEXParser::AtomContext::PERCENT_NUMBER() {
  return getToken(LATEXParser::PERCENT_NUMBER, 0);
}

tree::TerminalNode* LATEXParser::AtomContext::E_NOTATION() {
  return getToken(LATEXParser::E_NOTATION, 0);
}

tree::TerminalNode* LATEXParser::AtomContext::DIFFERENTIAL() {
  return getToken(LATEXParser::DIFFERENTIAL, 0);
}

LATEXParser::MathitContext* LATEXParser::AtomContext::mathit() {
  return getRuleContext<LATEXParser::MathitContext>(0);
}

tree::TerminalNode* LATEXParser::AtomContext::VARIABLE() {
  return getToken(LATEXParser::VARIABLE, 0);
}


size_t LATEXParser::AtomContext::getRuleIndex() const {
  return LATEXParser::RuleAtom;
}


LATEXParser::AtomContext* LATEXParser::atom() {
  AtomContext *_localctx = _tracker.createInstance<AtomContext>(_ctx, getState());
  enterRule(_localctx, 60, LATEXParser::RuleAtom);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(699);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::ACCENT_OVERLINE:
      case LATEXParser::ACCENT_BAR:
      case LATEXParser::LETTER_NO_E:
      case LATEXParser::GREEK_CMD: {
        enterOuterAlt(_localctx, 1);
        setState(689);
        atom_expr();
        break;
      }

      case LATEXParser::SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(690);
        match(LATEXParser::SYMBOL);
        break;
      }

      case LATEXParser::NUMBER: {
        enterOuterAlt(_localctx, 3);
        setState(691);
        match(LATEXParser::NUMBER);
        break;
      }

      case LATEXParser::SCI_NOTATION_NUMBER: {
        enterOuterAlt(_localctx, 4);
        setState(692);
        match(LATEXParser::SCI_NOTATION_NUMBER);
        break;
      }

      case LATEXParser::FRACTION_NUMBER: {
        enterOuterAlt(_localctx, 5);
        setState(693);
        match(LATEXParser::FRACTION_NUMBER);
        break;
      }

      case LATEXParser::PERCENT_NUMBER: {
        enterOuterAlt(_localctx, 6);
        setState(694);
        match(LATEXParser::PERCENT_NUMBER);
        break;
      }

      case LATEXParser::E_NOTATION: {
        enterOuterAlt(_localctx, 7);
        setState(695);
        match(LATEXParser::E_NOTATION);
        break;
      }

      case LATEXParser::DIFFERENTIAL: {
        enterOuterAlt(_localctx, 8);
        setState(696);
        match(LATEXParser::DIFFERENTIAL);
        break;
      }

      case LATEXParser::CMD_MATHIT: {
        enterOuterAlt(_localctx, 9);
        setState(697);
        mathit();
        break;
      }

      case LATEXParser::VARIABLE: {
        enterOuterAlt(_localctx, 10);
        setState(698);
        match(LATEXParser::VARIABLE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MathitContext ------------------------------------------------------------------

LATEXParser::MathitContext::MathitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::MathitContext::CMD_MATHIT() {
  return getToken(LATEXParser::CMD_MATHIT, 0);
}

tree::TerminalNode* LATEXParser::MathitContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

LATEXParser::Mathit_textContext* LATEXParser::MathitContext::mathit_text() {
  return getRuleContext<LATEXParser::Mathit_textContext>(0);
}

tree::TerminalNode* LATEXParser::MathitContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}


size_t LATEXParser::MathitContext::getRuleIndex() const {
  return LATEXParser::RuleMathit;
}


LATEXParser::MathitContext* LATEXParser::mathit() {
  MathitContext *_localctx = _tracker.createInstance<MathitContext>(_ctx, getState());
  enterRule(_localctx, 62, LATEXParser::RuleMathit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(701);
    match(LATEXParser::CMD_MATHIT);
    setState(702);
    match(LATEXParser::L_BRACE);
    setState(703);
    mathit_text();
    setState(704);
    match(LATEXParser::R_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mathit_textContext ------------------------------------------------------------------

LATEXParser::Mathit_textContext::Mathit_textContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LATEXParser::Mathit_textContext::LETTER_NO_E() {
  return getTokens(LATEXParser::LETTER_NO_E);
}

tree::TerminalNode* LATEXParser::Mathit_textContext::LETTER_NO_E(size_t i) {
  return getToken(LATEXParser::LETTER_NO_E, i);
}

std::vector<tree::TerminalNode *> LATEXParser::Mathit_textContext::E_NOTATION_E() {
  return getTokens(LATEXParser::E_NOTATION_E);
}

tree::TerminalNode* LATEXParser::Mathit_textContext::E_NOTATION_E(size_t i) {
  return getToken(LATEXParser::E_NOTATION_E, i);
}

std::vector<tree::TerminalNode *> LATEXParser::Mathit_textContext::EXP_E() {
  return getTokens(LATEXParser::EXP_E);
}

tree::TerminalNode* LATEXParser::Mathit_textContext::EXP_E(size_t i) {
  return getToken(LATEXParser::EXP_E, i);
}


size_t LATEXParser::Mathit_textContext::getRuleIndex() const {
  return LATEXParser::RuleMathit_text;
}


LATEXParser::Mathit_textContext* LATEXParser::mathit_text() {
  Mathit_textContext *_localctx = _tracker.createInstance<Mathit_textContext>(_ctx, getState());
  enterRule(_localctx, 64, LATEXParser::RuleMathit_text);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(707); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(706);
      _la = _input->LA(1);
      if (!((((_la - 109) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 109)) & 7) != 0)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(709); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la - 109) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 109)) & 7) != 0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FracContext ------------------------------------------------------------------

LATEXParser::FracContext::FracContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::FracContext::CMD_FRAC() {
  return getToken(LATEXParser::CMD_FRAC, 0);
}

std::vector<tree::TerminalNode *> LATEXParser::FracContext::L_BRACE() {
  return getTokens(LATEXParser::L_BRACE);
}

tree::TerminalNode* LATEXParser::FracContext::L_BRACE(size_t i) {
  return getToken(LATEXParser::L_BRACE, i);
}

std::vector<tree::TerminalNode *> LATEXParser::FracContext::R_BRACE() {
  return getTokens(LATEXParser::R_BRACE);
}

tree::TerminalNode* LATEXParser::FracContext::R_BRACE(size_t i) {
  return getToken(LATEXParser::R_BRACE, i);
}

std::vector<LATEXParser::ExprContext *> LATEXParser::FracContext::expr() {
  return getRuleContexts<LATEXParser::ExprContext>();
}

LATEXParser::ExprContext* LATEXParser::FracContext::expr(size_t i) {
  return getRuleContext<LATEXParser::ExprContext>(i);
}


size_t LATEXParser::FracContext::getRuleIndex() const {
  return LATEXParser::RuleFrac;
}


LATEXParser::FracContext* LATEXParser::frac() {
  FracContext *_localctx = _tracker.createInstance<FracContext>(_ctx, getState());
  enterRule(_localctx, 66, LATEXParser::RuleFrac);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(711);
    match(LATEXParser::CMD_FRAC);
    setState(712);
    match(LATEXParser::L_BRACE);
    setState(713);
    antlrcpp::downCast<FracContext *>(_localctx)->upper = expr();
    setState(714);
    match(LATEXParser::R_BRACE);
    setState(715);
    match(LATEXParser::L_BRACE);
    setState(716);
    antlrcpp::downCast<FracContext *>(_localctx)->lower = expr();
    setState(717);
    match(LATEXParser::R_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinomContext ------------------------------------------------------------------

LATEXParser::BinomContext::BinomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LATEXParser::BinomContext::L_BRACE() {
  return getTokens(LATEXParser::L_BRACE);
}

tree::TerminalNode* LATEXParser::BinomContext::L_BRACE(size_t i) {
  return getToken(LATEXParser::L_BRACE, i);
}

std::vector<tree::TerminalNode *> LATEXParser::BinomContext::R_BRACE() {
  return getTokens(LATEXParser::R_BRACE);
}

tree::TerminalNode* LATEXParser::BinomContext::R_BRACE(size_t i) {
  return getToken(LATEXParser::R_BRACE, i);
}

tree::TerminalNode* LATEXParser::BinomContext::CMD_BINOM() {
  return getToken(LATEXParser::CMD_BINOM, 0);
}

tree::TerminalNode* LATEXParser::BinomContext::CMD_CHOOSE() {
  return getToken(LATEXParser::CMD_CHOOSE, 0);
}

std::vector<LATEXParser::ExprContext *> LATEXParser::BinomContext::expr() {
  return getRuleContexts<LATEXParser::ExprContext>();
}

LATEXParser::ExprContext* LATEXParser::BinomContext::expr(size_t i) {
  return getRuleContext<LATEXParser::ExprContext>(i);
}


size_t LATEXParser::BinomContext::getRuleIndex() const {
  return LATEXParser::RuleBinom;
}


LATEXParser::BinomContext* LATEXParser::binom() {
  BinomContext *_localctx = _tracker.createInstance<BinomContext>(_ctx, getState());
  enterRule(_localctx, 68, LATEXParser::RuleBinom);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(719);
    _la = _input->LA(1);
    if (!(_la == LATEXParser::CMD_BINOM

    || _la == LATEXParser::CMD_CHOOSE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(720);
    match(LATEXParser::L_BRACE);
    setState(721);
    antlrcpp::downCast<BinomContext *>(_localctx)->upper = expr();
    setState(722);
    match(LATEXParser::R_BRACE);
    setState(723);
    match(LATEXParser::L_BRACE);
    setState(724);
    antlrcpp::downCast<BinomContext *>(_localctx)->lower = expr();
    setState(725);
    match(LATEXParser::R_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_normal_functions_single_argContext ------------------------------------------------------------------

LATEXParser::Func_normal_functions_single_argContext::Func_normal_functions_single_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_LOG() {
  return getToken(LATEXParser::FUNC_LOG, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_LN() {
  return getToken(LATEXParser::FUNC_LN, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_EXP() {
  return getToken(LATEXParser::FUNC_EXP, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_SIN() {
  return getToken(LATEXParser::FUNC_SIN, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_COS() {
  return getToken(LATEXParser::FUNC_COS, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_TAN() {
  return getToken(LATEXParser::FUNC_TAN, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_CSC() {
  return getToken(LATEXParser::FUNC_CSC, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_SEC() {
  return getToken(LATEXParser::FUNC_SEC, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_COT() {
  return getToken(LATEXParser::FUNC_COT, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCSIN() {
  return getToken(LATEXParser::FUNC_ARCSIN, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCCOS() {
  return getToken(LATEXParser::FUNC_ARCCOS, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCTAN() {
  return getToken(LATEXParser::FUNC_ARCTAN, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCCSC() {
  return getToken(LATEXParser::FUNC_ARCCSC, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCSEC() {
  return getToken(LATEXParser::FUNC_ARCSEC, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCCOT() {
  return getToken(LATEXParser::FUNC_ARCCOT, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_SINH() {
  return getToken(LATEXParser::FUNC_SINH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_COSH() {
  return getToken(LATEXParser::FUNC_COSH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_TANH() {
  return getToken(LATEXParser::FUNC_TANH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARSINH() {
  return getToken(LATEXParser::FUNC_ARSINH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCOSH() {
  return getToken(LATEXParser::FUNC_ARCOSH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARTANH() {
  return getToken(LATEXParser::FUNC_ARTANH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCSINH() {
  return getToken(LATEXParser::FUNC_ARCSINH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCCOSH() {
  return getToken(LATEXParser::FUNC_ARCCOSH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCTANH() {
  return getToken(LATEXParser::FUNC_ARCTANH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_FLOOR() {
  return getToken(LATEXParser::FUNC_FLOOR, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_CEIL() {
  return getToken(LATEXParser::FUNC_CEIL, 0);
}


size_t LATEXParser::Func_normal_functions_single_argContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_normal_functions_single_arg;
}


LATEXParser::Func_normal_functions_single_argContext* LATEXParser::func_normal_functions_single_arg() {
  Func_normal_functions_single_argContext *_localctx = _tracker.createInstance<Func_normal_functions_single_argContext>(_ctx, getState());
  enterRule(_localctx, 70, LATEXParser::RuleFunc_normal_functions_single_arg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(727);
    _la = _input->LA(1);
    if (!((((_la - 42) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 42)) & 412333637631) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_normal_functions_multi_argContext ------------------------------------------------------------------

LATEXParser::Func_normal_functions_multi_argContext::Func_normal_functions_multi_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Func_normal_functions_multi_argContext::FUNC_GCD() {
  return getToken(LATEXParser::FUNC_GCD, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_multi_argContext::FUNC_LCM() {
  return getToken(LATEXParser::FUNC_LCM, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_multi_argContext::FUNC_MAX() {
  return getToken(LATEXParser::FUNC_MAX, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_multi_argContext::FUNC_MIN() {
  return getToken(LATEXParser::FUNC_MIN, 0);
}


size_t LATEXParser::Func_normal_functions_multi_argContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_normal_functions_multi_arg;
}


LATEXParser::Func_normal_functions_multi_argContext* LATEXParser::func_normal_functions_multi_arg() {
  Func_normal_functions_multi_argContext *_localctx = _tracker.createInstance<Func_normal_functions_multi_argContext>(_ctx, getState());
  enterRule(_localctx, 72, LATEXParser::RuleFunc_normal_functions_multi_arg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(729);
    _la = _input->LA(1);
    if (!((((_la - 77) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 77)) & 51) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_operator_names_single_argContext ------------------------------------------------------------------

LATEXParser::Func_operator_names_single_argContext::Func_operator_names_single_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Func_operator_names_single_argContext::FUNC_ARSINH_NAME() {
  return getToken(LATEXParser::FUNC_ARSINH_NAME, 0);
}

tree::TerminalNode* LATEXParser::Func_operator_names_single_argContext::FUNC_ARCOSH_NAME() {
  return getToken(LATEXParser::FUNC_ARCOSH_NAME, 0);
}

tree::TerminalNode* LATEXParser::Func_operator_names_single_argContext::FUNC_ARTANH_NAME() {
  return getToken(LATEXParser::FUNC_ARTANH_NAME, 0);
}

tree::TerminalNode* LATEXParser::Func_operator_names_single_argContext::FUNC_ARCSINH_NAME() {
  return getToken(LATEXParser::FUNC_ARCSINH_NAME, 0);
}

tree::TerminalNode* LATEXParser::Func_operator_names_single_argContext::FUNC_ARCCOSH_NAME() {
  return getToken(LATEXParser::FUNC_ARCCOSH_NAME, 0);
}

tree::TerminalNode* LATEXParser::Func_operator_names_single_argContext::FUNC_ARCTANH_NAME() {
  return getToken(LATEXParser::FUNC_ARCTANH_NAME, 0);
}

tree::TerminalNode* LATEXParser::Func_operator_names_single_argContext::FUNC_FLOOR_NAME() {
  return getToken(LATEXParser::FUNC_FLOOR_NAME, 0);
}

tree::TerminalNode* LATEXParser::Func_operator_names_single_argContext::FUNC_CEIL_NAME() {
  return getToken(LATEXParser::FUNC_CEIL_NAME, 0);
}


size_t LATEXParser::Func_operator_names_single_argContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_operator_names_single_arg;
}


LATEXParser::Func_operator_names_single_argContext* LATEXParser::func_operator_names_single_arg() {
  Func_operator_names_single_argContext *_localctx = _tracker.createInstance<Func_operator_names_single_argContext>(_ctx, getState());
  enterRule(_localctx, 74, LATEXParser::RuleFunc_operator_names_single_arg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(731);
    _la = _input->LA(1);
    if (!((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 831) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_operator_names_multi_argContext ------------------------------------------------------------------

LATEXParser::Func_operator_names_multi_argContext::Func_operator_names_multi_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Func_operator_names_multi_argContext::FUNC_GCD_NAME() {
  return getToken(LATEXParser::FUNC_GCD_NAME, 0);
}

tree::TerminalNode* LATEXParser::Func_operator_names_multi_argContext::FUNC_LCM_NAME() {
  return getToken(LATEXParser::FUNC_LCM_NAME, 0);
}


size_t LATEXParser::Func_operator_names_multi_argContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_operator_names_multi_arg;
}


LATEXParser::Func_operator_names_multi_argContext* LATEXParser::func_operator_names_multi_arg() {
  Func_operator_names_multi_argContext *_localctx = _tracker.createInstance<Func_operator_names_multi_argContext>(_ctx, getState());
  enterRule(_localctx, 76, LATEXParser::RuleFunc_operator_names_multi_arg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(733);
    _la = _input->LA(1);
    if (!(_la == LATEXParser::FUNC_GCD_NAME

    || _la == LATEXParser::FUNC_LCM_NAME)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_normal_single_argContext ------------------------------------------------------------------

LATEXParser::Func_normal_single_argContext::Func_normal_single_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Func_normal_functions_single_argContext* LATEXParser::Func_normal_single_argContext::func_normal_functions_single_arg() {
  return getRuleContext<LATEXParser::Func_normal_functions_single_argContext>(0);
}

tree::TerminalNode* LATEXParser::Func_normal_single_argContext::CMD_OPERATORNAME() {
  return getToken(LATEXParser::CMD_OPERATORNAME, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_single_argContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_single_argContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

LATEXParser::Func_operator_names_single_argContext* LATEXParser::Func_normal_single_argContext::func_operator_names_single_arg() {
  return getRuleContext<LATEXParser::Func_operator_names_single_argContext>(0);
}


size_t LATEXParser::Func_normal_single_argContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_normal_single_arg;
}


LATEXParser::Func_normal_single_argContext* LATEXParser::func_normal_single_arg() {
  Func_normal_single_argContext *_localctx = _tracker.createInstance<Func_normal_single_argContext>(_ctx, getState());
  enterRule(_localctx, 78, LATEXParser::RuleFunc_normal_single_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(741);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::FUNC_LOG:
      case LATEXParser::FUNC_LN:
      case LATEXParser::FUNC_EXP:
      case LATEXParser::FUNC_SIN:
      case LATEXParser::FUNC_COS:
      case LATEXParser::FUNC_TAN:
      case LATEXParser::FUNC_CSC:
      case LATEXParser::FUNC_SEC:
      case LATEXParser::FUNC_COT:
      case LATEXParser::FUNC_ARCSIN:
      case LATEXParser::FUNC_ARCCOS:
      case LATEXParser::FUNC_ARCTAN:
      case LATEXParser::FUNC_ARCCSC:
      case LATEXParser::FUNC_ARCSEC:
      case LATEXParser::FUNC_ARCCOT:
      case LATEXParser::FUNC_SINH:
      case LATEXParser::FUNC_COSH:
      case LATEXParser::FUNC_TANH:
      case LATEXParser::FUNC_ARSINH:
      case LATEXParser::FUNC_ARCOSH:
      case LATEXParser::FUNC_ARTANH:
      case LATEXParser::FUNC_ARCSINH:
      case LATEXParser::FUNC_ARCCOSH:
      case LATEXParser::FUNC_ARCTANH:
      case LATEXParser::FUNC_FLOOR:
      case LATEXParser::FUNC_CEIL: {
        enterOuterAlt(_localctx, 1);
        setState(735);
        func_normal_functions_single_arg();
        break;
      }

      case LATEXParser::CMD_OPERATORNAME: {
        enterOuterAlt(_localctx, 2);
        setState(736);
        match(LATEXParser::CMD_OPERATORNAME);
        setState(737);
        match(LATEXParser::L_BRACE);
        setState(738);
        antlrcpp::downCast<Func_normal_single_argContext *>(_localctx)->func_operator_name = func_operator_names_single_arg();
        setState(739);
        match(LATEXParser::R_BRACE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_normal_multi_argContext ------------------------------------------------------------------

LATEXParser::Func_normal_multi_argContext::Func_normal_multi_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Func_normal_functions_multi_argContext* LATEXParser::Func_normal_multi_argContext::func_normal_functions_multi_arg() {
  return getRuleContext<LATEXParser::Func_normal_functions_multi_argContext>(0);
}

tree::TerminalNode* LATEXParser::Func_normal_multi_argContext::CMD_OPERATORNAME() {
  return getToken(LATEXParser::CMD_OPERATORNAME, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_multi_argContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_multi_argContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

LATEXParser::Func_operator_names_multi_argContext* LATEXParser::Func_normal_multi_argContext::func_operator_names_multi_arg() {
  return getRuleContext<LATEXParser::Func_operator_names_multi_argContext>(0);
}


size_t LATEXParser::Func_normal_multi_argContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_normal_multi_arg;
}


LATEXParser::Func_normal_multi_argContext* LATEXParser::func_normal_multi_arg() {
  Func_normal_multi_argContext *_localctx = _tracker.createInstance<Func_normal_multi_argContext>(_ctx, getState());
  enterRule(_localctx, 80, LATEXParser::RuleFunc_normal_multi_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(749);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::FUNC_GCD:
      case LATEXParser::FUNC_LCM:
      case LATEXParser::FUNC_MAX:
      case LATEXParser::FUNC_MIN: {
        enterOuterAlt(_localctx, 1);
        setState(743);
        func_normal_functions_multi_arg();
        break;
      }

      case LATEXParser::CMD_OPERATORNAME: {
        enterOuterAlt(_localctx, 2);
        setState(744);
        match(LATEXParser::CMD_OPERATORNAME);
        setState(745);
        match(LATEXParser::L_BRACE);
        setState(746);
        antlrcpp::downCast<Func_normal_multi_argContext *>(_localctx)->func_operator_name = func_operator_names_multi_arg();
        setState(747);
        match(LATEXParser::R_BRACE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FuncContext ------------------------------------------------------------------

LATEXParser::FuncContext::FuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Func_normal_single_argContext* LATEXParser::FuncContext::func_normal_single_arg() {
  return getRuleContext<LATEXParser::Func_normal_single_argContext>(0);
}

tree::TerminalNode* LATEXParser::FuncContext::L_PAREN() {
  return getToken(LATEXParser::L_PAREN, 0);
}

LATEXParser::Func_single_argContext* LATEXParser::FuncContext::func_single_arg() {
  return getRuleContext<LATEXParser::Func_single_argContext>(0);
}

tree::TerminalNode* LATEXParser::FuncContext::R_PAREN() {
  return getToken(LATEXParser::R_PAREN, 0);
}

LATEXParser::Func_single_arg_noparensContext* LATEXParser::FuncContext::func_single_arg_noparens() {
  return getRuleContext<LATEXParser::Func_single_arg_noparensContext>(0);
}

LATEXParser::SubexprContext* LATEXParser::FuncContext::subexpr() {
  return getRuleContext<LATEXParser::SubexprContext>(0);
}

LATEXParser::SupexprContext* LATEXParser::FuncContext::supexpr() {
  return getRuleContext<LATEXParser::SupexprContext>(0);
}

tree::TerminalNode* LATEXParser::FuncContext::L_LEFT() {
  return getToken(LATEXParser::L_LEFT, 0);
}

tree::TerminalNode* LATEXParser::FuncContext::R_RIGHT() {
  return getToken(LATEXParser::R_RIGHT, 0);
}

tree::TerminalNode* LATEXParser::FuncContext::ML_LEFT() {
  return getToken(LATEXParser::ML_LEFT, 0);
}

tree::TerminalNode* LATEXParser::FuncContext::MR_RIGHT() {
  return getToken(LATEXParser::MR_RIGHT, 0);
}

LATEXParser::Func_normal_multi_argContext* LATEXParser::FuncContext::func_normal_multi_arg() {
  return getRuleContext<LATEXParser::Func_normal_multi_argContext>(0);
}

LATEXParser::Func_multi_argContext* LATEXParser::FuncContext::func_multi_arg() {
  return getRuleContext<LATEXParser::Func_multi_argContext>(0);
}

LATEXParser::Func_multi_arg_noparensContext* LATEXParser::FuncContext::func_multi_arg_noparens() {
  return getRuleContext<LATEXParser::Func_multi_arg_noparensContext>(0);
}

tree::TerminalNode* LATEXParser::FuncContext::FUNC_INT() {
  return getToken(LATEXParser::FUNC_INT, 0);
}

tree::TerminalNode* LATEXParser::FuncContext::DIFFERENTIAL() {
  return getToken(LATEXParser::DIFFERENTIAL, 0);
}

LATEXParser::FracContext* LATEXParser::FuncContext::frac() {
  return getRuleContext<LATEXParser::FracContext>(0);
}

LATEXParser::AdditiveContext* LATEXParser::FuncContext::additive() {
  return getRuleContext<LATEXParser::AdditiveContext>(0);
}

tree::TerminalNode* LATEXParser::FuncContext::UNDERSCORE() {
  return getToken(LATEXParser::UNDERSCORE, 0);
}

std::vector<tree::TerminalNode *> LATEXParser::FuncContext::L_BRACE() {
  return getTokens(LATEXParser::L_BRACE);
}

tree::TerminalNode* LATEXParser::FuncContext::L_BRACE(size_t i) {
  return getToken(LATEXParser::L_BRACE, i);
}

std::vector<tree::TerminalNode *> LATEXParser::FuncContext::R_BRACE() {
  return getTokens(LATEXParser::R_BRACE);
}

tree::TerminalNode* LATEXParser::FuncContext::R_BRACE(size_t i) {
  return getToken(LATEXParser::R_BRACE, i);
}

tree::TerminalNode* LATEXParser::FuncContext::CARET() {
  return getToken(LATEXParser::CARET, 0);
}

tree::TerminalNode* LATEXParser::FuncContext::FUNC_SQRT() {
  return getToken(LATEXParser::FUNC_SQRT, 0);
}

std::vector<LATEXParser::ExprContext *> LATEXParser::FuncContext::expr() {
  return getRuleContexts<LATEXParser::ExprContext>();
}

LATEXParser::ExprContext* LATEXParser::FuncContext::expr(size_t i) {
  return getRuleContext<LATEXParser::ExprContext>(i);
}

tree::TerminalNode* LATEXParser::FuncContext::L_BRACKET() {
  return getToken(LATEXParser::L_BRACKET, 0);
}

tree::TerminalNode* LATEXParser::FuncContext::R_BRACKET() {
  return getToken(LATEXParser::R_BRACKET, 0);
}

LATEXParser::MpContext* LATEXParser::FuncContext::mp() {
  return getRuleContext<LATEXParser::MpContext>(0);
}

tree::TerminalNode* LATEXParser::FuncContext::FUNC_SUM() {
  return getToken(LATEXParser::FUNC_SUM, 0);
}

tree::TerminalNode* LATEXParser::FuncContext::FUNC_PROD() {
  return getToken(LATEXParser::FUNC_PROD, 0);
}

LATEXParser::SubeqContext* LATEXParser::FuncContext::subeq() {
  return getRuleContext<LATEXParser::SubeqContext>(0);
}

tree::TerminalNode* LATEXParser::FuncContext::FUNC_LIM() {
  return getToken(LATEXParser::FUNC_LIM, 0);
}

LATEXParser::Limit_subContext* LATEXParser::FuncContext::limit_sub() {
  return getRuleContext<LATEXParser::Limit_subContext>(0);
}

tree::TerminalNode* LATEXParser::FuncContext::EXP_E() {
  return getToken(LATEXParser::EXP_E, 0);
}


size_t LATEXParser::FuncContext::getRuleIndex() const {
  return LATEXParser::RuleFunc;
}


LATEXParser::FuncContext* LATEXParser::func() {
  FuncContext *_localctx = _tracker.createInstance<FuncContext>(_ctx, getState());
  enterRule(_localctx, 82, LATEXParser::RuleFunc);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(888);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(751);
      func_normal_single_arg();
      setState(764);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
      case 1: {
        setState(753);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::UNDERSCORE) {
          setState(752);
          subexpr();
        }
        setState(756);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::CARET) {
          setState(755);
          supexpr();
        }
        break;
      }

      case 2: {
        setState(759);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::CARET) {
          setState(758);
          supexpr();
        }
        setState(762);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::UNDERSCORE) {
          setState(761);
          subexpr();
        }
        break;
      }

      default:
        break;
      }
      setState(787);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
      case 1: {
        setState(767);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::L_LEFT) {
          setState(766);
          match(LATEXParser::L_LEFT);
        }
        setState(769);
        match(LATEXParser::L_PAREN);
        setState(770);
        func_single_arg();
        setState(772);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::R_RIGHT) {
          setState(771);
          match(LATEXParser::R_RIGHT);
        }
        setState(774);
        match(LATEXParser::R_PAREN);
        break;
      }

      case 2: {
        setState(777);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::ML_LEFT) {
          setState(776);
          match(LATEXParser::ML_LEFT);
        }
        setState(779);
        match(LATEXParser::L_PAREN);
        setState(780);
        func_single_arg();
        setState(782);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::MR_RIGHT) {
          setState(781);
          match(LATEXParser::MR_RIGHT);
        }
        setState(784);
        match(LATEXParser::R_PAREN);
        break;
      }

      case 3: {
        setState(786);
        func_single_arg_noparens();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(789);
      func_normal_multi_arg();
      setState(802);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
      case 1: {
        setState(791);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::UNDERSCORE) {
          setState(790);
          subexpr();
        }
        setState(794);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::CARET) {
          setState(793);
          supexpr();
        }
        break;
      }

      case 2: {
        setState(797);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::CARET) {
          setState(796);
          supexpr();
        }
        setState(800);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::UNDERSCORE) {
          setState(799);
          subexpr();
        }
        break;
      }

      default:
        break;
      }
      setState(825);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
      case 1: {
        setState(805);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::L_LEFT) {
          setState(804);
          match(LATEXParser::L_LEFT);
        }
        setState(807);
        match(LATEXParser::L_PAREN);
        setState(808);
        func_multi_arg();
        setState(810);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::R_RIGHT) {
          setState(809);
          match(LATEXParser::R_RIGHT);
        }
        setState(812);
        match(LATEXParser::R_PAREN);
        break;
      }

      case 2: {
        setState(815);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::ML_LEFT) {
          setState(814);
          match(LATEXParser::ML_LEFT);
        }
        setState(817);
        match(LATEXParser::L_PAREN);
        setState(818);
        func_multi_arg();
        setState(820);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::MR_RIGHT) {
          setState(819);
          match(LATEXParser::MR_RIGHT);
        }
        setState(822);
        match(LATEXParser::R_PAREN);
        break;
      }

      case 3: {
        setState(824);
        func_multi_arg_noparens();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(827);
      match(LATEXParser::FUNC_INT);
      setState(848);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
      case 1: {
        setState(828);
        subexpr();
        setState(829);
        supexpr();
        break;
      }

      case 2: {
        setState(831);
        supexpr();
        setState(832);
        subexpr();
        break;
      }

      case 3: {
        setState(834);
        match(LATEXParser::UNDERSCORE);
        setState(835);
        match(LATEXParser::L_BRACE);
        setState(836);
        match(LATEXParser::R_BRACE);

        setState(838);
        match(LATEXParser::CARET);
        setState(839);
        match(LATEXParser::L_BRACE);
        setState(840);
        match(LATEXParser::R_BRACE);
        break;
      }

      case 4: {
        setState(841);
        match(LATEXParser::CARET);
        setState(842);
        match(LATEXParser::L_BRACE);
        setState(843);
        match(LATEXParser::R_BRACE);

        setState(845);
        match(LATEXParser::UNDERSCORE);
        setState(846);
        match(LATEXParser::L_BRACE);
        setState(847);
        match(LATEXParser::R_BRACE);
        break;
      }

      default:
        break;
      }
      setState(856);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
      case 1: {
        setState(851);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
        case 1: {
          setState(850);
          additive(0);
          break;
        }

        default:
          break;
        }
        setState(853);
        match(LATEXParser::DIFFERENTIAL);
        break;
      }

      case 2: {
        setState(854);
        frac();
        break;
      }

      case 3: {
        setState(855);
        additive(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(858);
      match(LATEXParser::FUNC_SQRT);
      setState(863);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == LATEXParser::L_BRACKET) {
        setState(859);
        match(LATEXParser::L_BRACKET);
        setState(860);
        antlrcpp::downCast<FuncContext *>(_localctx)->root = expr();
        setState(861);
        match(LATEXParser::R_BRACKET);
      }
      setState(865);
      match(LATEXParser::L_BRACE);
      setState(866);
      antlrcpp::downCast<FuncContext *>(_localctx)->base = expr();
      setState(867);
      match(LATEXParser::R_BRACE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(869);
      _la = _input->LA(1);
      if (!(_la == LATEXParser::FUNC_SUM

      || _la == LATEXParser::FUNC_PROD)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(876);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case LATEXParser::UNDERSCORE: {
          setState(870);
          subeq();
          setState(871);
          supexpr();
          break;
        }

        case LATEXParser::CARET: {
          setState(873);
          supexpr();
          setState(874);
          subeq();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(878);
      mp(0);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(880);
      match(LATEXParser::FUNC_LIM);
      setState(881);
      limit_sub();
      setState(882);
      mp(0);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(884);
      match(LATEXParser::EXP_E);
      setState(886);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
      case 1: {
        setState(885);
        supexpr();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgsContext ------------------------------------------------------------------

LATEXParser::ArgsContext::ArgsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::ExprContext* LATEXParser::ArgsContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::ArgsContext::COMMA() {
  return getToken(LATEXParser::COMMA, 0);
}

LATEXParser::ArgsContext* LATEXParser::ArgsContext::args() {
  return getRuleContext<LATEXParser::ArgsContext>(0);
}


size_t LATEXParser::ArgsContext::getRuleIndex() const {
  return LATEXParser::RuleArgs;
}


LATEXParser::ArgsContext* LATEXParser::args() {
  ArgsContext *_localctx = _tracker.createInstance<ArgsContext>(_ctx, getState());
  enterRule(_localctx, 84, LATEXParser::RuleArgs);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(895);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(890);
      expr();
      setState(891);
      match(LATEXParser::COMMA);
      setState(892);
      args();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(894);
      expr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Limit_subContext ------------------------------------------------------------------

LATEXParser::Limit_subContext::Limit_subContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Limit_subContext::UNDERSCORE() {
  return getToken(LATEXParser::UNDERSCORE, 0);
}

std::vector<tree::TerminalNode *> LATEXParser::Limit_subContext::L_BRACE() {
  return getTokens(LATEXParser::L_BRACE);
}

tree::TerminalNode* LATEXParser::Limit_subContext::L_BRACE(size_t i) {
  return getToken(LATEXParser::L_BRACE, i);
}

tree::TerminalNode* LATEXParser::Limit_subContext::LIM_APPROACH_SYM() {
  return getToken(LATEXParser::LIM_APPROACH_SYM, 0);
}

LATEXParser::ExprContext* LATEXParser::Limit_subContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

std::vector<tree::TerminalNode *> LATEXParser::Limit_subContext::R_BRACE() {
  return getTokens(LATEXParser::R_BRACE);
}

tree::TerminalNode* LATEXParser::Limit_subContext::R_BRACE(size_t i) {
  return getToken(LATEXParser::R_BRACE, i);
}

tree::TerminalNode* LATEXParser::Limit_subContext::LETTER_NO_E() {
  return getToken(LATEXParser::LETTER_NO_E, 0);
}

tree::TerminalNode* LATEXParser::Limit_subContext::GREEK_CMD() {
  return getToken(LATEXParser::GREEK_CMD, 0);
}

tree::TerminalNode* LATEXParser::Limit_subContext::CARET() {
  return getToken(LATEXParser::CARET, 0);
}

tree::TerminalNode* LATEXParser::Limit_subContext::ADD() {
  return getToken(LATEXParser::ADD, 0);
}

tree::TerminalNode* LATEXParser::Limit_subContext::SUB() {
  return getToken(LATEXParser::SUB, 0);
}


size_t LATEXParser::Limit_subContext::getRuleIndex() const {
  return LATEXParser::RuleLimit_sub;
}


LATEXParser::Limit_subContext* LATEXParser::limit_sub() {
  Limit_subContext *_localctx = _tracker.createInstance<Limit_subContext>(_ctx, getState());
  enterRule(_localctx, 86, LATEXParser::RuleLimit_sub);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(897);
    match(LATEXParser::UNDERSCORE);
    setState(898);
    match(LATEXParser::L_BRACE);
    setState(899);
    _la = _input->LA(1);
    if (!(_la == LATEXParser::LETTER_NO_E

    || _la == LATEXParser::GREEK_CMD)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(900);
    match(LATEXParser::LIM_APPROACH_SYM);
    setState(901);
    expr();
    setState(906);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LATEXParser::CARET) {
      setState(902);
      match(LATEXParser::CARET);
      setState(903);
      match(LATEXParser::L_BRACE);
      setState(904);
      _la = _input->LA(1);
      if (!(_la == LATEXParser::ADD

      || _la == LATEXParser::SUB)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(905);
      match(LATEXParser::R_BRACE);
    }
    setState(908);
    match(LATEXParser::R_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_single_argContext ------------------------------------------------------------------

LATEXParser::Func_single_argContext::Func_single_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::ExprContext* LATEXParser::Func_single_argContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}


size_t LATEXParser::Func_single_argContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_single_arg;
}


LATEXParser::Func_single_argContext* LATEXParser::func_single_arg() {
  Func_single_argContext *_localctx = _tracker.createInstance<Func_single_argContext>(_ctx, getState());
  enterRule(_localctx, 88, LATEXParser::RuleFunc_single_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(910);
    expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_single_arg_noparensContext ------------------------------------------------------------------

LATEXParser::Func_single_arg_noparensContext::Func_single_arg_noparensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Mp_nofuncContext* LATEXParser::Func_single_arg_noparensContext::mp_nofunc() {
  return getRuleContext<LATEXParser::Mp_nofuncContext>(0);
}


size_t LATEXParser::Func_single_arg_noparensContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_single_arg_noparens;
}


LATEXParser::Func_single_arg_noparensContext* LATEXParser::func_single_arg_noparens() {
  Func_single_arg_noparensContext *_localctx = _tracker.createInstance<Func_single_arg_noparensContext>(_ctx, getState());
  enterRule(_localctx, 90, LATEXParser::RuleFunc_single_arg_noparens);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(912);
    mp_nofunc(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_multi_argContext ------------------------------------------------------------------

LATEXParser::Func_multi_argContext::Func_multi_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::ExprContext* LATEXParser::Func_multi_argContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::Func_multi_argContext::COMMA() {
  return getToken(LATEXParser::COMMA, 0);
}

LATEXParser::Func_multi_argContext* LATEXParser::Func_multi_argContext::func_multi_arg() {
  return getRuleContext<LATEXParser::Func_multi_argContext>(0);
}


size_t LATEXParser::Func_multi_argContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_multi_arg;
}


LATEXParser::Func_multi_argContext* LATEXParser::func_multi_arg() {
  Func_multi_argContext *_localctx = _tracker.createInstance<Func_multi_argContext>(_ctx, getState());
  enterRule(_localctx, 92, LATEXParser::RuleFunc_multi_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(919);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(914);
      expr();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(915);
      expr();
      setState(916);
      match(LATEXParser::COMMA);
      setState(917);
      func_multi_arg();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_multi_arg_noparensContext ------------------------------------------------------------------

LATEXParser::Func_multi_arg_noparensContext::Func_multi_arg_noparensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Mp_nofuncContext* LATEXParser::Func_multi_arg_noparensContext::mp_nofunc() {
  return getRuleContext<LATEXParser::Mp_nofuncContext>(0);
}


size_t LATEXParser::Func_multi_arg_noparensContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_multi_arg_noparens;
}


LATEXParser::Func_multi_arg_noparensContext* LATEXParser::func_multi_arg_noparens() {
  Func_multi_arg_noparensContext *_localctx = _tracker.createInstance<Func_multi_arg_noparensContext>(_ctx, getState());
  enterRule(_localctx, 94, LATEXParser::RuleFunc_multi_arg_noparens);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(921);
    mp_nofunc(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubexprContext ------------------------------------------------------------------

LATEXParser::SubexprContext::SubexprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::SubexprContext::UNDERSCORE() {
  return getToken(LATEXParser::UNDERSCORE, 0);
}

LATEXParser::AtomContext* LATEXParser::SubexprContext::atom() {
  return getRuleContext<LATEXParser::AtomContext>(0);
}

tree::TerminalNode* LATEXParser::SubexprContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

tree::TerminalNode* LATEXParser::SubexprContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

LATEXParser::ExprContext* LATEXParser::SubexprContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

LATEXParser::ArgsContext* LATEXParser::SubexprContext::args() {
  return getRuleContext<LATEXParser::ArgsContext>(0);
}


size_t LATEXParser::SubexprContext::getRuleIndex() const {
  return LATEXParser::RuleSubexpr;
}


LATEXParser::SubexprContext* LATEXParser::subexpr() {
  SubexprContext *_localctx = _tracker.createInstance<SubexprContext>(_ctx, getState());
  enterRule(_localctx, 96, LATEXParser::RuleSubexpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(923);
    match(LATEXParser::UNDERSCORE);
    setState(932);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::CMD_MATHIT:
      case LATEXParser::ACCENT_OVERLINE:
      case LATEXParser::ACCENT_BAR:
      case LATEXParser::DIFFERENTIAL:
      case LATEXParser::LETTER_NO_E:
      case LATEXParser::NUMBER:
      case LATEXParser::FRACTION_NUMBER:
      case LATEXParser::SCI_NOTATION_NUMBER:
      case LATEXParser::E_NOTATION:
      case LATEXParser::PERCENT_NUMBER:
      case LATEXParser::GREEK_CMD:
      case LATEXParser::SYMBOL:
      case LATEXParser::VARIABLE: {
        setState(924);
        atom();
        break;
      }

      case LATEXParser::L_BRACE: {
        setState(925);
        match(LATEXParser::L_BRACE);
        setState(928);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
        case 1: {
          setState(926);
          expr();
          break;
        }

        case 2: {
          setState(927);
          args();
          break;
        }

        default:
          break;
        }
        setState(930);
        match(LATEXParser::R_BRACE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SupexprContext ------------------------------------------------------------------

LATEXParser::SupexprContext::SupexprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::SupexprContext::CARET() {
  return getToken(LATEXParser::CARET, 0);
}

LATEXParser::AtomContext* LATEXParser::SupexprContext::atom() {
  return getRuleContext<LATEXParser::AtomContext>(0);
}

tree::TerminalNode* LATEXParser::SupexprContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

LATEXParser::ExprContext* LATEXParser::SupexprContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::SupexprContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}


size_t LATEXParser::SupexprContext::getRuleIndex() const {
  return LATEXParser::RuleSupexpr;
}


LATEXParser::SupexprContext* LATEXParser::supexpr() {
  SupexprContext *_localctx = _tracker.createInstance<SupexprContext>(_ctx, getState());
  enterRule(_localctx, 98, LATEXParser::RuleSupexpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(934);
    match(LATEXParser::CARET);
    setState(940);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::CMD_MATHIT:
      case LATEXParser::ACCENT_OVERLINE:
      case LATEXParser::ACCENT_BAR:
      case LATEXParser::DIFFERENTIAL:
      case LATEXParser::LETTER_NO_E:
      case LATEXParser::NUMBER:
      case LATEXParser::FRACTION_NUMBER:
      case LATEXParser::SCI_NOTATION_NUMBER:
      case LATEXParser::E_NOTATION:
      case LATEXParser::PERCENT_NUMBER:
      case LATEXParser::GREEK_CMD:
      case LATEXParser::SYMBOL:
      case LATEXParser::VARIABLE: {
        setState(935);
        atom();
        break;
      }

      case LATEXParser::L_BRACE: {
        setState(936);
        match(LATEXParser::L_BRACE);
        setState(937);
        expr();
        setState(938);
        match(LATEXParser::R_BRACE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubeqContext ------------------------------------------------------------------

LATEXParser::SubeqContext::SubeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::SubeqContext::UNDERSCORE() {
  return getToken(LATEXParser::UNDERSCORE, 0);
}

tree::TerminalNode* LATEXParser::SubeqContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

LATEXParser::EqualityContext* LATEXParser::SubeqContext::equality() {
  return getRuleContext<LATEXParser::EqualityContext>(0);
}

tree::TerminalNode* LATEXParser::SubeqContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}


size_t LATEXParser::SubeqContext::getRuleIndex() const {
  return LATEXParser::RuleSubeq;
}


LATEXParser::SubeqContext* LATEXParser::subeq() {
  SubeqContext *_localctx = _tracker.createInstance<SubeqContext>(_ctx, getState());
  enterRule(_localctx, 100, LATEXParser::RuleSubeq);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(942);
    match(LATEXParser::UNDERSCORE);
    setState(943);
    match(LATEXParser::L_BRACE);
    setState(944);
    equality();
    setState(945);
    match(LATEXParser::R_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool LATEXParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 4: return relationSempred(antlrcpp::downCast<RelationContext *>(context), predicateIndex);
    case 9: return additiveSempred(antlrcpp::downCast<AdditiveContext *>(context), predicateIndex);
    case 10: return mpSempred(antlrcpp::downCast<MpContext *>(context), predicateIndex);
    case 11: return mp_nofuncSempred(antlrcpp::downCast<Mp_nofuncContext *>(context), predicateIndex);
    case 20: return expSempred(antlrcpp::downCast<ExpContext *>(context), predicateIndex);
    case 21: return exp_nofuncSempred(antlrcpp::downCast<Exp_nofuncContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool LATEXParser::relationSempred(RelationContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool LATEXParser::additiveSempred(AdditiveContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool LATEXParser::mpSempred(MpContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool LATEXParser::mp_nofuncSempred(Mp_nofuncContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 3: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool LATEXParser::expSempred(ExpContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool LATEXParser::exp_nofuncSempred(Exp_nofuncContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 5: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

void LATEXParser::initialize() {
  ::antlr4::internal::call_once(latexParserOnceFlag, latexParserInitialize);
}
