
// Generated from LATEX.g4 by ANTLR 4.11.1



#include "LATEXParser.h"


using namespace antlrcpp;
using namespace latex2antlr;

using namespace antlr4;

namespace {

struct LATEXParserStaticData final {
  LATEXParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  LATEXParserStaticData(const LATEXParserStaticData&) = delete;
  LATEXParserStaticData(LATEXParserStaticData&&) = delete;
  LATEXParserStaticData& operator=(const LATEXParserStaticData&) = delete;
  LATEXParserStaticData& operator=(LATEXParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag latexParserOnceFlag;
LATEXParserStaticData *latexParserStaticData = nullptr;

void latexParserInitialize() {
  assert(latexParserStaticData == nullptr);
  auto staticData = std::make_unique<LATEXParserStaticData>(
    std::vector<std::string>{
      "accent_symbol", "math", "matrix", "matrix_row", "relation", "relation_list", 
      "relation_list_content", "equality", "expr", "additive", "mp", "mp_nofunc", 
      "unary", "unary_nofunc", "postfix", "postfix_nofunc", "postfix_op", 
      "eval_at", "eval_at_sub", "eval_at_sup", "exp", "exp_nofunc", "comp", 
      "comp_nofunc", "group", "abs_group", "floor_group", "ceil_group", 
      "accent", "atom_expr", "atom", "mathit", "mathit_text", "frac", "binom", 
      "func_normal_functions_single_arg", "func_normal_functions_multi_arg", 
      "func_operator_names_single_arg", "func_operator_names_multi_arg", 
      "func_normal_single_arg", "func_normal_multi_arg", "func", "args", 
      "limit_sub", "func_single_arg", "func_single_arg_noparens", "func_multi_arg", 
      "subexpr", "supexpr", "subeq"
    },
    std::vector<std::string>{
      "", "", "'\\$'", "'+'", "'-'", "'*'", "'/'", "'('", "')'", "'\\lgroup'", 
      "'\\rgroup'", "'{'", "'}'", "'\\{'", "'\\}'", "'\\lbrace'", "'\\rbrace'", 
      "'['", "']'", "'\\lbrack'", "'\\rbrack'", "'|'", "'\\lvert'", "'\\rvert'", 
      "'\\vert'", "'\\lfloor'", "'\\rfloor'", "'\\llcorner'", "'\\lrcorner'", 
      "'\\lceil'", "'\\rceil'", "'\\ulcorner'", "'\\urcorner'", "'\\left'", 
      "'\\right'", "'\\mleft'", "'\\mright'", "'\\lim'", "", "'\\int'", 
      "'\\sum'", "'\\prod'", "'\\log'", "'\\ln'", "'\\exp'", "'\\sin'", 
      "'\\cos'", "'\\tan'", "'\\csc'", "'\\sec'", "'\\cot'", "'\\arcsin'", 
      "'\\arccos'", "'\\arctan'", "'\\arccsc'", "'\\arcsec'", "'\\arccot'", 
      "'\\sinh'", "'\\cosh'", "'\\tanh'", "'\\arsinh'", "'\\arcosh'", "'\\artanh'", 
      "'\\arcsinh'", "'\\arccosh'", "'\\arctanh'", "'arsinh'", "'arcsinh'", 
      "'arcosh'", "'arccosh'", "'artanh'", "'arctanh'", "'gcd'", "'lcm'", 
      "'floor'", "'ceil'", "'\\sqrt'", "'\\gcd'", "'\\lcm'", "'\\floor'", 
      "'\\ceil'", "'\\max'", "'\\min'", "'\\times'", "'\\cdot'", "'\\div'", 
      "'\\frac'", "'\\binom'", "'\\choose'", "'\\mod'", "'\\mathit'", "'\\operatorname'", 
      "'matrix'", "'pmatrix'", "'bmatrix'", "", "", "", "'&'", "'\\\\'", 
      "'\\overline'", "'\\bar'", "'_'", "'^'", "':'", "';'", "','", "'.'", 
      "", "", "'E'", "", "", "", "", "", "'='", "'<'", "", "'>'", "", "", 
      "'!'"
    },
    std::vector<std::string>{
      "", "WS", "DOLLAR_SIGN", "ADD", "SUB", "MUL", "DIV", "L_PAREN", "R_PAREN", 
      "L_GROUP", "R_GROUP", "L_BRACE", "R_BRACE", "L_BRACE_VISUAL", "R_BRACE_VISUAL", 
      "L_BRACE_CMD", "R_BRACE_CMD", "L_BRACKET", "R_BRACKET", "L_BRACK", 
      "R_BRACK", "BAR", "L_VERT", "R_VERT", "VERT", "L_FLOOR", "R_FLOOR", 
      "LL_CORNER", "LR_CORNER", "L_CEIL", "R_CEIL", "UL_CORNER", "UR_CORNER", 
      "L_LEFT", "R_RIGHT", "ML_LEFT", "MR_RIGHT", "FUNC_LIM", "LIM_APPROACH_SYM", 
      "FUNC_INT", "FUNC_SUM", "FUNC_PROD", "FUNC_LOG", "FUNC_LN", "FUNC_EXP", 
      "FUNC_SIN", "FUNC_COS", "FUNC_TAN", "FUNC_CSC", "FUNC_SEC", "FUNC_COT", 
      "FUNC_ARCSIN", "FUNC_ARCCOS", "FUNC_ARCTAN", "FUNC_ARCCSC", "FUNC_ARCSEC", 
      "FUNC_ARCCOT", "FUNC_SINH", "FUNC_COSH", "FUNC_TANH", "FUNC_ARSINH", 
      "FUNC_ARCOSH", "FUNC_ARTANH", "FUNC_ARCSINH", "FUNC_ARCCOSH", "FUNC_ARCTANH", 
      "FUNC_ARSINH_NAME", "FUNC_ARCSINH_NAME", "FUNC_ARCOSH_NAME", "FUNC_ARCCOSH_NAME", 
      "FUNC_ARTANH_NAME", "FUNC_ARCTANH_NAME", "FUNC_GCD_NAME", "FUNC_LCM_NAME", 
      "FUNC_FLOOR_NAME", "FUNC_CEIL_NAME", "FUNC_SQRT", "FUNC_GCD", "FUNC_LCM", 
      "FUNC_FLOOR", "FUNC_CEIL", "FUNC_MAX", "FUNC_MIN", "CMD_TIMES", "CMD_CDOT", 
      "CMD_DIV", "CMD_FRAC", "CMD_BINOM", "CMD_CHOOSE", "CMD_MOD", "CMD_MATHIT", 
      "CMD_OPERATORNAME", "MATRIX_TYPE_MATRIX", "MATRIX_TYPE_PMATRIX", "MATRIX_TYPE_BMATRIX", 
      "MATRIX_TYPES", "CMD_MATRIX_START", "CMD_MATRIX_END", "MATRIX_DEL_COL", 
      "MATRIX_DEL_ROW", "ACCENT_OVERLINE", "ACCENT_BAR", "UNDERSCORE", "CARET", 
      "COLON", "SEMICOLON", "COMMA", "PERIOD", "DIFFERENTIAL", "EXP_E", 
      "E_NOTATION_E", "LETTER_NO_E", "NUMBER", "FRACTION_NUMBER", "SCI_NOTATION_NUMBER", 
      "E_NOTATION", "EQUAL", "LT", "LTE", "GT", "GTE", "UNEQUAL", "BANG", 
      "PERCENT_NUMBER", "GREEK_CMD", "SYMBOL", "VARIABLE"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,126,943,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,1,0,1,0,1,1,1,1,3,1,105,8,1,1,2,1,2,1,2,1,2,5,2,111,8,2,10,2,12,2,
  	114,9,2,1,2,1,2,1,3,1,3,1,3,5,3,121,8,3,10,3,12,3,124,9,3,1,4,1,4,1,4,
  	1,4,1,4,1,4,5,4,132,8,4,10,4,12,4,135,9,4,1,5,1,5,1,5,1,5,1,5,1,5,1,5,
  	1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,
  	5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,
  	1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,
  	5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,
  	1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,
  	5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,
  	1,5,3,5,250,8,5,1,6,1,6,1,6,1,6,1,6,5,6,257,8,6,10,6,12,6,260,9,6,1,6,
  	1,6,1,6,1,6,1,6,5,6,267,8,6,10,6,12,6,270,9,6,3,6,272,8,6,1,7,1,7,1,7,
  	1,7,1,8,1,8,1,9,1,9,1,9,1,9,1,9,1,9,5,9,286,8,9,10,9,12,9,289,9,9,1,10,
  	1,10,1,10,1,10,1,10,1,10,5,10,297,8,10,10,10,12,10,300,9,10,1,11,1,11,
  	1,11,1,11,1,11,1,11,5,11,308,8,11,10,11,12,11,311,9,11,1,12,1,12,1,12,
  	4,12,316,8,12,11,12,12,12,317,3,12,320,8,12,1,13,1,13,1,13,1,13,5,13,
  	326,8,13,10,13,12,13,329,9,13,3,13,331,8,13,1,14,1,14,5,14,335,8,14,10,
  	14,12,14,338,9,14,1,15,1,15,5,15,342,8,15,10,15,12,15,345,9,15,1,16,1,
  	16,3,16,349,8,16,1,17,1,17,1,17,1,17,1,17,1,17,3,17,357,8,17,1,18,1,18,
  	1,18,1,18,3,18,363,8,18,1,18,1,18,1,19,1,19,1,19,1,19,3,19,371,8,19,1,
  	19,1,19,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,3,20,385,8,
  	20,1,20,3,20,388,8,20,5,20,390,8,20,10,20,12,20,393,9,20,1,21,1,21,1,
  	21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,3,21,405,8,21,1,21,3,21,408,8,21,
  	5,21,410,8,21,10,21,12,21,413,9,21,1,22,1,22,1,22,1,22,1,22,1,22,1,22,
  	1,22,1,22,3,22,424,8,22,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,3,23,
  	434,8,23,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
  	1,24,1,24,3,24,548,8,24,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,
  	1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,
  	1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,
  	1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,3,25,598,8,25,
  	1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,
  	1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,
  	1,26,1,26,1,26,1,26,3,26,632,8,26,1,27,1,27,1,27,1,27,1,27,1,27,1,27,
  	1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,
  	1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,3,27,666,8,27,
  	1,28,1,28,1,28,1,28,1,28,1,29,1,29,1,29,3,29,676,8,29,1,29,1,29,1,29,
  	1,29,1,29,1,29,1,29,1,29,3,29,686,8,29,1,30,1,30,1,30,1,30,1,30,1,30,
  	1,30,1,30,1,30,1,30,3,30,698,8,30,1,31,1,31,1,31,1,31,1,31,1,32,4,32,
  	706,8,32,11,32,12,32,707,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,34,
  	1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,35,1,35,1,36,1,36,1,37,1,37,1,38,
  	1,38,1,39,1,39,1,39,1,39,1,39,1,39,3,39,740,8,39,1,40,1,40,1,40,1,40,
  	1,40,1,40,3,40,748,8,40,1,41,1,41,3,41,752,8,41,1,41,3,41,755,8,41,1,
  	41,3,41,758,8,41,1,41,3,41,761,8,41,3,41,763,8,41,1,41,3,41,766,8,41,
  	1,41,1,41,1,41,3,41,771,8,41,1,41,1,41,1,41,3,41,776,8,41,1,41,1,41,1,
  	41,3,41,781,8,41,1,41,1,41,1,41,3,41,786,8,41,1,41,1,41,3,41,790,8,41,
  	1,41,3,41,793,8,41,1,41,3,41,796,8,41,1,41,3,41,799,8,41,3,41,801,8,41,
  	1,41,3,41,804,8,41,1,41,1,41,1,41,3,41,809,8,41,1,41,1,41,1,41,3,41,814,
  	8,41,1,41,1,41,1,41,3,41,819,8,41,1,41,1,41,3,41,823,8,41,1,41,1,41,1,
  	41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,
  	41,1,41,1,41,1,41,1,41,3,41,846,8,41,1,41,3,41,849,8,41,1,41,1,41,1,41,
  	3,41,854,8,41,1,41,1,41,1,41,1,41,1,41,3,41,861,8,41,1,41,1,41,1,41,1,
  	41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,3,41,874,8,41,1,41,1,41,1,41,1,
  	41,1,41,1,41,1,41,1,41,3,41,884,8,41,3,41,886,8,41,1,42,1,42,1,42,1,42,
  	1,42,3,42,893,8,42,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,3,43,
  	904,8,43,1,43,1,43,1,44,1,44,1,45,1,45,1,46,1,46,1,46,1,46,1,46,3,46,
  	917,8,46,1,47,1,47,1,47,1,47,1,47,3,47,924,8,47,1,47,1,47,3,47,928,8,
  	47,1,48,1,48,1,48,1,48,1,48,1,48,3,48,936,8,48,1,49,1,49,1,49,1,49,1,
  	49,1,49,0,6,8,18,20,22,40,42,50,0,2,4,6,8,10,12,14,16,18,20,22,24,26,
  	28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,
  	74,76,78,80,82,84,86,88,90,92,94,96,98,0,12,1,0,100,101,1,0,116,121,1,
  	0,3,4,4,0,5,6,83,85,89,89,104,104,1,0,109,111,1,0,87,88,2,0,42,65,79,
  	80,2,0,77,78,81,82,2,0,66,71,74,75,1,0,72,73,1,0,40,41,2,0,111,111,124,
  	124,1054,0,100,1,0,0,0,2,104,1,0,0,0,4,106,1,0,0,0,6,117,1,0,0,0,8,125,
  	1,0,0,0,10,249,1,0,0,0,12,271,1,0,0,0,14,273,1,0,0,0,16,277,1,0,0,0,18,
  	279,1,0,0,0,20,290,1,0,0,0,22,301,1,0,0,0,24,319,1,0,0,0,26,330,1,0,0,
  	0,28,332,1,0,0,0,30,339,1,0,0,0,32,348,1,0,0,0,34,350,1,0,0,0,36,358,
  	1,0,0,0,38,366,1,0,0,0,40,374,1,0,0,0,42,394,1,0,0,0,44,423,1,0,0,0,46,
  	433,1,0,0,0,48,547,1,0,0,0,50,597,1,0,0,0,52,631,1,0,0,0,54,665,1,0,0,
  	0,56,667,1,0,0,0,58,675,1,0,0,0,60,697,1,0,0,0,62,699,1,0,0,0,64,705,
  	1,0,0,0,66,709,1,0,0,0,68,717,1,0,0,0,70,725,1,0,0,0,72,727,1,0,0,0,74,
  	729,1,0,0,0,76,731,1,0,0,0,78,739,1,0,0,0,80,747,1,0,0,0,82,885,1,0,0,
  	0,84,892,1,0,0,0,86,894,1,0,0,0,88,907,1,0,0,0,90,909,1,0,0,0,92,916,
  	1,0,0,0,94,918,1,0,0,0,96,929,1,0,0,0,98,937,1,0,0,0,100,101,7,0,0,0,
  	101,1,1,0,0,0,102,105,3,8,4,0,103,105,3,10,5,0,104,102,1,0,0,0,104,103,
  	1,0,0,0,105,3,1,0,0,0,106,107,5,96,0,0,107,112,3,6,3,0,108,109,5,99,0,
  	0,109,111,3,6,3,0,110,108,1,0,0,0,111,114,1,0,0,0,112,110,1,0,0,0,112,
  	113,1,0,0,0,113,115,1,0,0,0,114,112,1,0,0,0,115,116,5,97,0,0,116,5,1,
  	0,0,0,117,122,3,16,8,0,118,119,5,98,0,0,119,121,3,16,8,0,120,118,1,0,
  	0,0,121,124,1,0,0,0,122,120,1,0,0,0,122,123,1,0,0,0,123,7,1,0,0,0,124,
  	122,1,0,0,0,125,126,6,4,-1,0,126,127,3,16,8,0,127,133,1,0,0,0,128,129,
  	10,2,0,0,129,130,7,1,0,0,130,132,3,8,4,3,131,128,1,0,0,0,132,135,1,0,
  	0,0,133,131,1,0,0,0,133,134,1,0,0,0,134,9,1,0,0,0,135,133,1,0,0,0,136,
  	250,3,12,6,0,137,138,5,7,0,0,138,139,3,12,6,0,139,140,5,8,0,0,140,250,
  	1,0,0,0,141,142,5,9,0,0,142,143,3,12,6,0,143,144,5,10,0,0,144,250,1,0,
  	0,0,145,146,5,11,0,0,146,147,3,12,6,0,147,148,5,12,0,0,148,250,1,0,0,
  	0,149,150,5,13,0,0,150,151,3,12,6,0,151,152,5,14,0,0,152,250,1,0,0,0,
  	153,154,5,15,0,0,154,155,3,12,6,0,155,156,5,16,0,0,156,250,1,0,0,0,157,
  	158,5,17,0,0,158,159,3,12,6,0,159,160,5,18,0,0,160,250,1,0,0,0,161,162,
  	5,19,0,0,162,163,3,12,6,0,163,164,5,20,0,0,164,250,1,0,0,0,165,166,5,
  	33,0,0,166,167,5,7,0,0,167,168,3,12,6,0,168,169,5,34,0,0,169,170,5,8,
  	0,0,170,250,1,0,0,0,171,172,5,33,0,0,172,173,5,9,0,0,173,174,3,12,6,0,
  	174,175,5,34,0,0,175,176,5,10,0,0,176,250,1,0,0,0,177,178,5,33,0,0,178,
  	179,5,11,0,0,179,180,3,12,6,0,180,181,5,34,0,0,181,182,5,12,0,0,182,250,
  	1,0,0,0,183,184,5,33,0,0,184,185,5,13,0,0,185,186,3,12,6,0,186,187,5,
  	34,0,0,187,188,5,14,0,0,188,250,1,0,0,0,189,190,5,33,0,0,190,191,5,15,
  	0,0,191,192,3,12,6,0,192,193,5,34,0,0,193,194,5,16,0,0,194,250,1,0,0,
  	0,195,196,5,33,0,0,196,197,5,17,0,0,197,198,3,12,6,0,198,199,5,34,0,0,
  	199,200,5,18,0,0,200,250,1,0,0,0,201,202,5,33,0,0,202,203,5,19,0,0,203,
  	204,3,12,6,0,204,205,5,34,0,0,205,206,5,20,0,0,206,250,1,0,0,0,207,208,
  	5,35,0,0,208,209,5,7,0,0,209,210,3,12,6,0,210,211,5,36,0,0,211,212,5,
  	8,0,0,212,250,1,0,0,0,213,214,5,35,0,0,214,215,5,9,0,0,215,216,3,12,6,
  	0,216,217,5,36,0,0,217,218,5,10,0,0,218,250,1,0,0,0,219,220,5,35,0,0,
  	220,221,5,11,0,0,221,222,3,12,6,0,222,223,5,36,0,0,223,224,5,12,0,0,224,
  	250,1,0,0,0,225,226,5,35,0,0,226,227,5,13,0,0,227,228,3,12,6,0,228,229,
  	5,36,0,0,229,230,5,14,0,0,230,250,1,0,0,0,231,232,5,35,0,0,232,233,5,
  	15,0,0,233,234,3,12,6,0,234,235,5,36,0,0,235,236,5,16,0,0,236,250,1,0,
  	0,0,237,238,5,35,0,0,238,239,5,17,0,0,239,240,3,12,6,0,240,241,5,36,0,
  	0,241,242,5,18,0,0,242,250,1,0,0,0,243,244,5,35,0,0,244,245,5,19,0,0,
  	245,246,3,12,6,0,246,247,5,36,0,0,247,248,5,20,0,0,248,250,1,0,0,0,249,
  	136,1,0,0,0,249,137,1,0,0,0,249,141,1,0,0,0,249,145,1,0,0,0,249,149,1,
  	0,0,0,249,153,1,0,0,0,249,157,1,0,0,0,249,161,1,0,0,0,249,165,1,0,0,0,
  	249,171,1,0,0,0,249,177,1,0,0,0,249,183,1,0,0,0,249,189,1,0,0,0,249,195,
  	1,0,0,0,249,201,1,0,0,0,249,207,1,0,0,0,249,213,1,0,0,0,249,219,1,0,0,
  	0,249,225,1,0,0,0,249,231,1,0,0,0,249,237,1,0,0,0,249,243,1,0,0,0,250,
  	11,1,0,0,0,251,252,3,8,4,0,252,253,5,106,0,0,253,258,3,8,4,0,254,255,
  	5,106,0,0,255,257,3,8,4,0,256,254,1,0,0,0,257,260,1,0,0,0,258,256,1,0,
  	0,0,258,259,1,0,0,0,259,272,1,0,0,0,260,258,1,0,0,0,261,262,3,8,4,0,262,
  	263,5,105,0,0,263,268,3,8,4,0,264,265,5,105,0,0,265,267,3,8,4,0,266,264,
  	1,0,0,0,267,270,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,272,1,0,0,
  	0,270,268,1,0,0,0,271,251,1,0,0,0,271,261,1,0,0,0,272,13,1,0,0,0,273,
  	274,3,16,8,0,274,275,5,116,0,0,275,276,3,16,8,0,276,15,1,0,0,0,277,278,
  	3,18,9,0,278,17,1,0,0,0,279,280,6,9,-1,0,280,281,3,20,10,0,281,287,1,
  	0,0,0,282,283,10,2,0,0,283,284,7,2,0,0,284,286,3,18,9,3,285,282,1,0,0,
  	0,286,289,1,0,0,0,287,285,1,0,0,0,287,288,1,0,0,0,288,19,1,0,0,0,289,
  	287,1,0,0,0,290,291,6,10,-1,0,291,292,3,24,12,0,292,298,1,0,0,0,293,294,
  	10,2,0,0,294,295,7,3,0,0,295,297,3,20,10,3,296,293,1,0,0,0,297,300,1,
  	0,0,0,298,296,1,0,0,0,298,299,1,0,0,0,299,21,1,0,0,0,300,298,1,0,0,0,
  	301,302,6,11,-1,0,302,303,3,26,13,0,303,309,1,0,0,0,304,305,10,2,0,0,
  	305,306,7,3,0,0,306,308,3,22,11,3,307,304,1,0,0,0,308,311,1,0,0,0,309,
  	307,1,0,0,0,309,310,1,0,0,0,310,23,1,0,0,0,311,309,1,0,0,0,312,313,7,
  	2,0,0,313,320,3,24,12,0,314,316,3,28,14,0,315,314,1,0,0,0,316,317,1,0,
  	0,0,317,315,1,0,0,0,317,318,1,0,0,0,318,320,1,0,0,0,319,312,1,0,0,0,319,
  	315,1,0,0,0,320,25,1,0,0,0,321,322,7,2,0,0,322,331,3,26,13,0,323,327,
  	3,28,14,0,324,326,3,30,15,0,325,324,1,0,0,0,326,329,1,0,0,0,327,325,1,
  	0,0,0,327,328,1,0,0,0,328,331,1,0,0,0,329,327,1,0,0,0,330,321,1,0,0,0,
  	330,323,1,0,0,0,331,27,1,0,0,0,332,336,3,40,20,0,333,335,3,32,16,0,334,
  	333,1,0,0,0,335,338,1,0,0,0,336,334,1,0,0,0,336,337,1,0,0,0,337,29,1,
  	0,0,0,338,336,1,0,0,0,339,343,3,42,21,0,340,342,3,32,16,0,341,340,1,0,
  	0,0,342,345,1,0,0,0,343,341,1,0,0,0,343,344,1,0,0,0,344,31,1,0,0,0,345,
  	343,1,0,0,0,346,349,5,122,0,0,347,349,3,34,17,0,348,346,1,0,0,0,348,347,
  	1,0,0,0,349,33,1,0,0,0,350,356,5,21,0,0,351,357,3,38,19,0,352,357,3,36,
  	18,0,353,354,3,38,19,0,354,355,3,36,18,0,355,357,1,0,0,0,356,351,1,0,
  	0,0,356,352,1,0,0,0,356,353,1,0,0,0,357,35,1,0,0,0,358,359,5,102,0,0,
  	359,362,5,11,0,0,360,363,3,16,8,0,361,363,3,14,7,0,362,360,1,0,0,0,362,
  	361,1,0,0,0,363,364,1,0,0,0,364,365,5,12,0,0,365,37,1,0,0,0,366,367,5,
  	103,0,0,367,370,5,11,0,0,368,371,3,16,8,0,369,371,3,14,7,0,370,368,1,
  	0,0,0,370,369,1,0,0,0,371,372,1,0,0,0,372,373,5,12,0,0,373,39,1,0,0,0,
  	374,375,6,20,-1,0,375,376,3,44,22,0,376,391,1,0,0,0,377,378,10,2,0,0,
  	378,384,5,103,0,0,379,385,3,60,30,0,380,381,5,11,0,0,381,382,3,16,8,0,
  	382,383,5,12,0,0,383,385,1,0,0,0,384,379,1,0,0,0,384,380,1,0,0,0,385,
  	387,1,0,0,0,386,388,3,94,47,0,387,386,1,0,0,0,387,388,1,0,0,0,388,390,
  	1,0,0,0,389,377,1,0,0,0,390,393,1,0,0,0,391,389,1,0,0,0,391,392,1,0,0,
  	0,392,41,1,0,0,0,393,391,1,0,0,0,394,395,6,21,-1,0,395,396,3,46,23,0,
  	396,411,1,0,0,0,397,398,10,2,0,0,398,404,5,103,0,0,399,405,3,60,30,0,
  	400,401,5,11,0,0,401,402,3,16,8,0,402,403,5,12,0,0,403,405,1,0,0,0,404,
  	399,1,0,0,0,404,400,1,0,0,0,405,407,1,0,0,0,406,408,3,94,47,0,407,406,
  	1,0,0,0,407,408,1,0,0,0,408,410,1,0,0,0,409,397,1,0,0,0,410,413,1,0,0,
  	0,411,409,1,0,0,0,411,412,1,0,0,0,412,43,1,0,0,0,413,411,1,0,0,0,414,
  	424,3,48,24,0,415,424,3,50,25,0,416,424,3,52,26,0,417,424,3,54,27,0,418,
  	424,3,82,41,0,419,424,3,60,30,0,420,424,3,66,33,0,421,424,3,68,34,0,422,
  	424,3,4,2,0,423,414,1,0,0,0,423,415,1,0,0,0,423,416,1,0,0,0,423,417,1,
  	0,0,0,423,418,1,0,0,0,423,419,1,0,0,0,423,420,1,0,0,0,423,421,1,0,0,0,
  	423,422,1,0,0,0,424,45,1,0,0,0,425,434,3,48,24,0,426,434,3,50,25,0,427,
  	434,3,52,26,0,428,434,3,54,27,0,429,434,3,60,30,0,430,434,3,66,33,0,431,
  	434,3,68,34,0,432,434,3,4,2,0,433,425,1,0,0,0,433,426,1,0,0,0,433,427,
  	1,0,0,0,433,428,1,0,0,0,433,429,1,0,0,0,433,430,1,0,0,0,433,431,1,0,0,
  	0,433,432,1,0,0,0,434,47,1,0,0,0,435,436,5,7,0,0,436,437,3,16,8,0,437,
  	438,5,8,0,0,438,548,1,0,0,0,439,440,5,9,0,0,440,441,3,16,8,0,441,442,
  	5,10,0,0,442,548,1,0,0,0,443,444,5,11,0,0,444,445,3,16,8,0,445,446,5,
  	12,0,0,446,548,1,0,0,0,447,448,5,13,0,0,448,449,3,16,8,0,449,450,5,14,
  	0,0,450,548,1,0,0,0,451,452,5,15,0,0,452,453,3,16,8,0,453,454,5,16,0,
  	0,454,548,1,0,0,0,455,456,5,17,0,0,456,457,3,16,8,0,457,458,5,18,0,0,
  	458,548,1,0,0,0,459,460,5,19,0,0,460,461,3,16,8,0,461,462,5,20,0,0,462,
  	548,1,0,0,0,463,464,5,33,0,0,464,465,5,7,0,0,465,466,3,16,8,0,466,467,
  	5,34,0,0,467,468,5,8,0,0,468,548,1,0,0,0,469,470,5,33,0,0,470,471,5,9,
  	0,0,471,472,3,16,8,0,472,473,5,34,0,0,473,474,5,10,0,0,474,548,1,0,0,
  	0,475,476,5,33,0,0,476,477,5,11,0,0,477,478,3,16,8,0,478,479,5,34,0,0,
  	479,480,5,12,0,0,480,548,1,0,0,0,481,482,5,33,0,0,482,483,5,13,0,0,483,
  	484,3,16,8,0,484,485,5,34,0,0,485,486,5,14,0,0,486,548,1,0,0,0,487,488,
  	5,33,0,0,488,489,5,15,0,0,489,490,3,16,8,0,490,491,5,34,0,0,491,492,5,
  	16,0,0,492,548,1,0,0,0,493,494,5,33,0,0,494,495,5,17,0,0,495,496,3,16,
  	8,0,496,497,5,34,0,0,497,498,5,18,0,0,498,548,1,0,0,0,499,500,5,33,0,
  	0,500,501,5,19,0,0,501,502,3,16,8,0,502,503,5,34,0,0,503,504,5,20,0,0,
  	504,548,1,0,0,0,505,506,5,35,0,0,506,507,5,7,0,0,507,508,3,16,8,0,508,
  	509,5,36,0,0,509,510,5,8,0,0,510,548,1,0,0,0,511,512,5,35,0,0,512,513,
  	5,9,0,0,513,514,3,16,8,0,514,515,5,36,0,0,515,516,5,10,0,0,516,548,1,
  	0,0,0,517,518,5,35,0,0,518,519,5,11,0,0,519,520,3,16,8,0,520,521,5,36,
  	0,0,521,522,5,12,0,0,522,548,1,0,0,0,523,524,5,35,0,0,524,525,5,13,0,
  	0,525,526,3,16,8,0,526,527,5,36,0,0,527,528,5,14,0,0,528,548,1,0,0,0,
  	529,530,5,35,0,0,530,531,5,15,0,0,531,532,3,16,8,0,532,533,5,36,0,0,533,
  	534,5,16,0,0,534,548,1,0,0,0,535,536,5,35,0,0,536,537,5,17,0,0,537,538,
  	3,16,8,0,538,539,5,36,0,0,539,540,5,18,0,0,540,548,1,0,0,0,541,542,5,
  	35,0,0,542,543,5,19,0,0,543,544,3,16,8,0,544,545,5,36,0,0,545,546,5,20,
  	0,0,546,548,1,0,0,0,547,435,1,0,0,0,547,439,1,0,0,0,547,443,1,0,0,0,547,
  	447,1,0,0,0,547,451,1,0,0,0,547,455,1,0,0,0,547,459,1,0,0,0,547,463,1,
  	0,0,0,547,469,1,0,0,0,547,475,1,0,0,0,547,481,1,0,0,0,547,487,1,0,0,0,
  	547,493,1,0,0,0,547,499,1,0,0,0,547,505,1,0,0,0,547,511,1,0,0,0,547,517,
  	1,0,0,0,547,523,1,0,0,0,547,529,1,0,0,0,547,535,1,0,0,0,547,541,1,0,0,
  	0,548,49,1,0,0,0,549,550,5,21,0,0,550,551,3,16,8,0,551,552,5,21,0,0,552,
  	598,1,0,0,0,553,554,5,22,0,0,554,555,3,16,8,0,555,556,5,23,0,0,556,598,
  	1,0,0,0,557,558,5,24,0,0,558,559,3,16,8,0,559,560,5,24,0,0,560,598,1,
  	0,0,0,561,562,5,33,0,0,562,563,5,21,0,0,563,564,3,16,8,0,564,565,5,34,
  	0,0,565,566,5,21,0,0,566,598,1,0,0,0,567,568,5,33,0,0,568,569,5,22,0,
  	0,569,570,3,16,8,0,570,571,5,34,0,0,571,572,5,23,0,0,572,598,1,0,0,0,
  	573,574,5,33,0,0,574,575,5,24,0,0,575,576,3,16,8,0,576,577,5,34,0,0,577,
  	578,5,24,0,0,578,598,1,0,0,0,579,580,5,35,0,0,580,581,5,21,0,0,581,582,
  	3,16,8,0,582,583,5,36,0,0,583,584,5,21,0,0,584,598,1,0,0,0,585,586,5,
  	35,0,0,586,587,5,22,0,0,587,588,3,16,8,0,588,589,5,36,0,0,589,590,5,23,
  	0,0,590,598,1,0,0,0,591,592,5,35,0,0,592,593,5,24,0,0,593,594,3,16,8,
  	0,594,595,5,36,0,0,595,596,5,24,0,0,596,598,1,0,0,0,597,549,1,0,0,0,597,
  	553,1,0,0,0,597,557,1,0,0,0,597,561,1,0,0,0,597,567,1,0,0,0,597,573,1,
  	0,0,0,597,579,1,0,0,0,597,585,1,0,0,0,597,591,1,0,0,0,598,51,1,0,0,0,
  	599,600,5,25,0,0,600,601,3,16,8,0,601,602,5,26,0,0,602,632,1,0,0,0,603,
  	604,5,27,0,0,604,605,3,16,8,0,605,606,5,28,0,0,606,632,1,0,0,0,607,608,
  	5,33,0,0,608,609,5,25,0,0,609,610,3,16,8,0,610,611,5,34,0,0,611,612,5,
  	26,0,0,612,632,1,0,0,0,613,614,5,33,0,0,614,615,5,27,0,0,615,616,3,16,
  	8,0,616,617,5,34,0,0,617,618,5,28,0,0,618,632,1,0,0,0,619,620,5,35,0,
  	0,620,621,5,25,0,0,621,622,3,16,8,0,622,623,5,36,0,0,623,624,5,26,0,0,
  	624,632,1,0,0,0,625,626,5,35,0,0,626,627,5,27,0,0,627,628,3,16,8,0,628,
  	629,5,36,0,0,629,630,5,28,0,0,630,632,1,0,0,0,631,599,1,0,0,0,631,603,
  	1,0,0,0,631,607,1,0,0,0,631,613,1,0,0,0,631,619,1,0,0,0,631,625,1,0,0,
  	0,632,53,1,0,0,0,633,634,5,29,0,0,634,635,3,16,8,0,635,636,5,30,0,0,636,
  	666,1,0,0,0,637,638,5,31,0,0,638,639,3,16,8,0,639,640,5,32,0,0,640,666,
  	1,0,0,0,641,642,5,33,0,0,642,643,5,29,0,0,643,644,3,16,8,0,644,645,5,
  	34,0,0,645,646,5,30,0,0,646,666,1,0,0,0,647,648,5,33,0,0,648,649,5,31,
  	0,0,649,650,3,16,8,0,650,651,5,34,0,0,651,652,5,32,0,0,652,666,1,0,0,
  	0,653,654,5,35,0,0,654,655,5,29,0,0,655,656,3,16,8,0,656,657,5,36,0,0,
  	657,658,5,30,0,0,658,666,1,0,0,0,659,660,5,35,0,0,660,661,5,31,0,0,661,
  	662,3,16,8,0,662,663,5,36,0,0,663,664,5,32,0,0,664,666,1,0,0,0,665,633,
  	1,0,0,0,665,637,1,0,0,0,665,641,1,0,0,0,665,647,1,0,0,0,665,653,1,0,0,
  	0,665,659,1,0,0,0,666,55,1,0,0,0,667,668,3,0,0,0,668,669,5,11,0,0,669,
  	670,3,16,8,0,670,671,5,12,0,0,671,57,1,0,0,0,672,676,5,111,0,0,673,676,
  	5,124,0,0,674,676,3,56,28,0,675,672,1,0,0,0,675,673,1,0,0,0,675,674,1,
  	0,0,0,676,685,1,0,0,0,677,678,3,96,48,0,678,679,3,94,47,0,679,686,1,0,
  	0,0,680,681,3,94,47,0,681,682,3,96,48,0,682,686,1,0,0,0,683,686,3,94,
  	47,0,684,686,3,96,48,0,685,677,1,0,0,0,685,680,1,0,0,0,685,683,1,0,0,
  	0,685,684,1,0,0,0,685,686,1,0,0,0,686,59,1,0,0,0,687,698,3,58,29,0,688,
  	698,5,125,0,0,689,698,5,112,0,0,690,698,5,114,0,0,691,698,5,113,0,0,692,
  	698,5,123,0,0,693,698,5,115,0,0,694,698,5,108,0,0,695,698,3,62,31,0,696,
  	698,5,126,0,0,697,687,1,0,0,0,697,688,1,0,0,0,697,689,1,0,0,0,697,690,
  	1,0,0,0,697,691,1,0,0,0,697,692,1,0,0,0,697,693,1,0,0,0,697,694,1,0,0,
  	0,697,695,1,0,0,0,697,696,1,0,0,0,698,61,1,0,0,0,699,700,5,90,0,0,700,
  	701,5,11,0,0,701,702,3,64,32,0,702,703,5,12,0,0,703,63,1,0,0,0,704,706,
  	7,4,0,0,705,704,1,0,0,0,706,707,1,0,0,0,707,705,1,0,0,0,707,708,1,0,0,
  	0,708,65,1,0,0,0,709,710,5,86,0,0,710,711,5,11,0,0,711,712,3,16,8,0,712,
  	713,5,12,0,0,713,714,5,11,0,0,714,715,3,16,8,0,715,716,5,12,0,0,716,67,
  	1,0,0,0,717,718,7,5,0,0,718,719,5,11,0,0,719,720,3,16,8,0,720,721,5,12,
  	0,0,721,722,5,11,0,0,722,723,3,16,8,0,723,724,5,12,0,0,724,69,1,0,0,0,
  	725,726,7,6,0,0,726,71,1,0,0,0,727,728,7,7,0,0,728,73,1,0,0,0,729,730,
  	7,8,0,0,730,75,1,0,0,0,731,732,7,9,0,0,732,77,1,0,0,0,733,740,3,70,35,
  	0,734,735,5,91,0,0,735,736,5,11,0,0,736,737,3,74,37,0,737,738,5,12,0,
  	0,738,740,1,0,0,0,739,733,1,0,0,0,739,734,1,0,0,0,740,79,1,0,0,0,741,
  	748,3,72,36,0,742,743,5,91,0,0,743,744,5,11,0,0,744,745,3,76,38,0,745,
  	746,5,12,0,0,746,748,1,0,0,0,747,741,1,0,0,0,747,742,1,0,0,0,748,81,1,
  	0,0,0,749,762,3,78,39,0,750,752,3,94,47,0,751,750,1,0,0,0,751,752,1,0,
  	0,0,752,754,1,0,0,0,753,755,3,96,48,0,754,753,1,0,0,0,754,755,1,0,0,0,
  	755,763,1,0,0,0,756,758,3,96,48,0,757,756,1,0,0,0,757,758,1,0,0,0,758,
  	760,1,0,0,0,759,761,3,94,47,0,760,759,1,0,0,0,760,761,1,0,0,0,761,763,
  	1,0,0,0,762,751,1,0,0,0,762,757,1,0,0,0,763,785,1,0,0,0,764,766,5,33,
  	0,0,765,764,1,0,0,0,765,766,1,0,0,0,766,767,1,0,0,0,767,768,5,7,0,0,768,
  	770,3,88,44,0,769,771,5,34,0,0,770,769,1,0,0,0,770,771,1,0,0,0,771,772,
  	1,0,0,0,772,773,5,8,0,0,773,786,1,0,0,0,774,776,5,35,0,0,775,774,1,0,
  	0,0,775,776,1,0,0,0,776,777,1,0,0,0,777,778,5,7,0,0,778,780,3,88,44,0,
  	779,781,5,36,0,0,780,779,1,0,0,0,780,781,1,0,0,0,781,782,1,0,0,0,782,
  	783,5,8,0,0,783,786,1,0,0,0,784,786,3,90,45,0,785,765,1,0,0,0,785,775,
  	1,0,0,0,785,784,1,0,0,0,786,886,1,0,0,0,787,800,3,80,40,0,788,790,3,94,
  	47,0,789,788,1,0,0,0,789,790,1,0,0,0,790,792,1,0,0,0,791,793,3,96,48,
  	0,792,791,1,0,0,0,792,793,1,0,0,0,793,801,1,0,0,0,794,796,3,96,48,0,795,
  	794,1,0,0,0,795,796,1,0,0,0,796,798,1,0,0,0,797,799,3,94,47,0,798,797,
  	1,0,0,0,798,799,1,0,0,0,799,801,1,0,0,0,800,789,1,0,0,0,800,795,1,0,0,
  	0,801,822,1,0,0,0,802,804,5,33,0,0,803,802,1,0,0,0,803,804,1,0,0,0,804,
  	805,1,0,0,0,805,806,5,7,0,0,806,808,3,92,46,0,807,809,5,34,0,0,808,807,
  	1,0,0,0,808,809,1,0,0,0,809,810,1,0,0,0,810,811,5,8,0,0,811,823,1,0,0,
  	0,812,814,5,35,0,0,813,812,1,0,0,0,813,814,1,0,0,0,814,815,1,0,0,0,815,
  	816,5,7,0,0,816,818,3,92,46,0,817,819,5,36,0,0,818,817,1,0,0,0,818,819,
  	1,0,0,0,819,820,1,0,0,0,820,821,5,8,0,0,821,823,1,0,0,0,822,803,1,0,0,
  	0,822,813,1,0,0,0,823,886,1,0,0,0,824,845,5,39,0,0,825,826,3,94,47,0,
  	826,827,3,96,48,0,827,846,1,0,0,0,828,829,3,96,48,0,829,830,3,94,47,0,
  	830,846,1,0,0,0,831,832,5,102,0,0,832,833,5,11,0,0,833,834,5,12,0,0,834,
  	835,1,0,0,0,835,836,5,103,0,0,836,837,5,11,0,0,837,846,5,12,0,0,838,839,
  	5,103,0,0,839,840,5,11,0,0,840,841,5,12,0,0,841,842,1,0,0,0,842,843,5,
  	102,0,0,843,844,5,11,0,0,844,846,5,12,0,0,845,825,1,0,0,0,845,828,1,0,
  	0,0,845,831,1,0,0,0,845,838,1,0,0,0,845,846,1,0,0,0,846,853,1,0,0,0,847,
  	849,3,18,9,0,848,847,1,0,0,0,848,849,1,0,0,0,849,850,1,0,0,0,850,854,
  	5,108,0,0,851,854,3,66,33,0,852,854,3,18,9,0,853,848,1,0,0,0,853,851,
  	1,0,0,0,853,852,1,0,0,0,854,886,1,0,0,0,855,860,5,76,0,0,856,857,5,17,
  	0,0,857,858,3,16,8,0,858,859,5,18,0,0,859,861,1,0,0,0,860,856,1,0,0,0,
  	860,861,1,0,0,0,861,862,1,0,0,0,862,863,5,11,0,0,863,864,3,16,8,0,864,
  	865,5,12,0,0,865,886,1,0,0,0,866,873,7,10,0,0,867,868,3,98,49,0,868,869,
  	3,96,48,0,869,874,1,0,0,0,870,871,3,96,48,0,871,872,3,98,49,0,872,874,
  	1,0,0,0,873,867,1,0,0,0,873,870,1,0,0,0,874,875,1,0,0,0,875,876,3,20,
  	10,0,876,886,1,0,0,0,877,878,5,37,0,0,878,879,3,86,43,0,879,880,3,20,
  	10,0,880,886,1,0,0,0,881,883,5,109,0,0,882,884,3,96,48,0,883,882,1,0,
  	0,0,883,884,1,0,0,0,884,886,1,0,0,0,885,749,1,0,0,0,885,787,1,0,0,0,885,
  	824,1,0,0,0,885,855,1,0,0,0,885,866,1,0,0,0,885,877,1,0,0,0,885,881,1,
  	0,0,0,886,83,1,0,0,0,887,888,3,16,8,0,888,889,5,106,0,0,889,890,3,84,
  	42,0,890,893,1,0,0,0,891,893,3,16,8,0,892,887,1,0,0,0,892,891,1,0,0,0,
  	893,85,1,0,0,0,894,895,5,102,0,0,895,896,5,11,0,0,896,897,7,11,0,0,897,
  	898,5,38,0,0,898,903,3,16,8,0,899,900,5,103,0,0,900,901,5,11,0,0,901,
  	902,7,2,0,0,902,904,5,12,0,0,903,899,1,0,0,0,903,904,1,0,0,0,904,905,
  	1,0,0,0,905,906,5,12,0,0,906,87,1,0,0,0,907,908,3,16,8,0,908,89,1,0,0,
  	0,909,910,3,22,11,0,910,91,1,0,0,0,911,917,3,16,8,0,912,913,3,16,8,0,
  	913,914,5,106,0,0,914,915,3,92,46,0,915,917,1,0,0,0,916,911,1,0,0,0,916,
  	912,1,0,0,0,917,93,1,0,0,0,918,927,5,102,0,0,919,928,3,60,30,0,920,923,
  	5,11,0,0,921,924,3,16,8,0,922,924,3,84,42,0,923,921,1,0,0,0,923,922,1,
  	0,0,0,924,925,1,0,0,0,925,926,5,12,0,0,926,928,1,0,0,0,927,919,1,0,0,
  	0,927,920,1,0,0,0,928,95,1,0,0,0,929,935,5,103,0,0,930,936,3,60,30,0,
  	931,932,5,11,0,0,932,933,3,16,8,0,933,934,5,12,0,0,934,936,1,0,0,0,935,
  	930,1,0,0,0,935,931,1,0,0,0,936,97,1,0,0,0,937,938,5,102,0,0,938,939,
  	5,11,0,0,939,940,3,14,7,0,940,941,5,12,0,0,941,99,1,0,0,0,72,104,112,
  	122,133,249,258,268,271,287,298,309,317,319,327,330,336,343,348,356,362,
  	370,384,387,391,404,407,411,423,433,547,597,631,665,675,685,697,707,739,
  	747,751,754,757,760,762,765,770,775,780,785,789,792,795,798,800,803,808,
  	813,818,822,845,848,853,860,873,883,885,892,903,916,923,927,935
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  latexParserStaticData = staticData.release();
}

}

LATEXParser::LATEXParser(TokenStream *input) : LATEXParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

LATEXParser::LATEXParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  LATEXParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *latexParserStaticData->atn, latexParserStaticData->decisionToDFA, latexParserStaticData->sharedContextCache, options);
}

LATEXParser::~LATEXParser() {
  delete _interpreter;
}

const atn::ATN& LATEXParser::getATN() const {
  return *latexParserStaticData->atn;
}

std::string LATEXParser::getGrammarFileName() const {
  return "LATEX.g4";
}

const std::vector<std::string>& LATEXParser::getRuleNames() const {
  return latexParserStaticData->ruleNames;
}

const dfa::Vocabulary& LATEXParser::getVocabulary() const {
  return latexParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView LATEXParser::getSerializedATN() const {
  return latexParserStaticData->serializedATN;
}


//----------------- Accent_symbolContext ------------------------------------------------------------------

LATEXParser::Accent_symbolContext::Accent_symbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Accent_symbolContext::ACCENT_BAR() {
  return getToken(LATEXParser::ACCENT_BAR, 0);
}

tree::TerminalNode* LATEXParser::Accent_symbolContext::ACCENT_OVERLINE() {
  return getToken(LATEXParser::ACCENT_OVERLINE, 0);
}


size_t LATEXParser::Accent_symbolContext::getRuleIndex() const {
  return LATEXParser::RuleAccent_symbol;
}


LATEXParser::Accent_symbolContext* LATEXParser::accent_symbol() {
  Accent_symbolContext *_localctx = _tracker.createInstance<Accent_symbolContext>(_ctx, getState());
  enterRule(_localctx, 0, LATEXParser::RuleAccent_symbol);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(100);
    _la = _input->LA(1);
    if (!(_la == LATEXParser::ACCENT_OVERLINE

    || _la == LATEXParser::ACCENT_BAR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MathContext ------------------------------------------------------------------

LATEXParser::MathContext::MathContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::RelationContext* LATEXParser::MathContext::relation() {
  return getRuleContext<LATEXParser::RelationContext>(0);
}

LATEXParser::Relation_listContext* LATEXParser::MathContext::relation_list() {
  return getRuleContext<LATEXParser::Relation_listContext>(0);
}


size_t LATEXParser::MathContext::getRuleIndex() const {
  return LATEXParser::RuleMath;
}


LATEXParser::MathContext* LATEXParser::math() {
  MathContext *_localctx = _tracker.createInstance<MathContext>(_ctx, getState());
  enterRule(_localctx, 2, LATEXParser::RuleMath);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(104);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(102);
      relation(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(103);
      relation_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MatrixContext ------------------------------------------------------------------

LATEXParser::MatrixContext::MatrixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::MatrixContext::CMD_MATRIX_START() {
  return getToken(LATEXParser::CMD_MATRIX_START, 0);
}

std::vector<LATEXParser::Matrix_rowContext *> LATEXParser::MatrixContext::matrix_row() {
  return getRuleContexts<LATEXParser::Matrix_rowContext>();
}

LATEXParser::Matrix_rowContext* LATEXParser::MatrixContext::matrix_row(size_t i) {
  return getRuleContext<LATEXParser::Matrix_rowContext>(i);
}

tree::TerminalNode* LATEXParser::MatrixContext::CMD_MATRIX_END() {
  return getToken(LATEXParser::CMD_MATRIX_END, 0);
}

std::vector<tree::TerminalNode *> LATEXParser::MatrixContext::MATRIX_DEL_ROW() {
  return getTokens(LATEXParser::MATRIX_DEL_ROW);
}

tree::TerminalNode* LATEXParser::MatrixContext::MATRIX_DEL_ROW(size_t i) {
  return getToken(LATEXParser::MATRIX_DEL_ROW, i);
}


size_t LATEXParser::MatrixContext::getRuleIndex() const {
  return LATEXParser::RuleMatrix;
}


LATEXParser::MatrixContext* LATEXParser::matrix() {
  MatrixContext *_localctx = _tracker.createInstance<MatrixContext>(_ctx, getState());
  enterRule(_localctx, 4, LATEXParser::RuleMatrix);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(106);
    match(LATEXParser::CMD_MATRIX_START);
    setState(107);
    matrix_row();
    setState(112);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LATEXParser::MATRIX_DEL_ROW) {
      setState(108);
      match(LATEXParser::MATRIX_DEL_ROW);
      setState(109);
      matrix_row();
      setState(114);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(115);
    match(LATEXParser::CMD_MATRIX_END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Matrix_rowContext ------------------------------------------------------------------

LATEXParser::Matrix_rowContext::Matrix_rowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LATEXParser::ExprContext *> LATEXParser::Matrix_rowContext::expr() {
  return getRuleContexts<LATEXParser::ExprContext>();
}

LATEXParser::ExprContext* LATEXParser::Matrix_rowContext::expr(size_t i) {
  return getRuleContext<LATEXParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> LATEXParser::Matrix_rowContext::MATRIX_DEL_COL() {
  return getTokens(LATEXParser::MATRIX_DEL_COL);
}

tree::TerminalNode* LATEXParser::Matrix_rowContext::MATRIX_DEL_COL(size_t i) {
  return getToken(LATEXParser::MATRIX_DEL_COL, i);
}


size_t LATEXParser::Matrix_rowContext::getRuleIndex() const {
  return LATEXParser::RuleMatrix_row;
}


LATEXParser::Matrix_rowContext* LATEXParser::matrix_row() {
  Matrix_rowContext *_localctx = _tracker.createInstance<Matrix_rowContext>(_ctx, getState());
  enterRule(_localctx, 6, LATEXParser::RuleMatrix_row);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(117);
    expr();
    setState(122);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LATEXParser::MATRIX_DEL_COL) {
      setState(118);
      match(LATEXParser::MATRIX_DEL_COL);
      setState(119);
      expr();
      setState(124);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationContext ------------------------------------------------------------------

LATEXParser::RelationContext::RelationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::ExprContext* LATEXParser::RelationContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

std::vector<LATEXParser::RelationContext *> LATEXParser::RelationContext::relation() {
  return getRuleContexts<LATEXParser::RelationContext>();
}

LATEXParser::RelationContext* LATEXParser::RelationContext::relation(size_t i) {
  return getRuleContext<LATEXParser::RelationContext>(i);
}

tree::TerminalNode* LATEXParser::RelationContext::EQUAL() {
  return getToken(LATEXParser::EQUAL, 0);
}

tree::TerminalNode* LATEXParser::RelationContext::LT() {
  return getToken(LATEXParser::LT, 0);
}

tree::TerminalNode* LATEXParser::RelationContext::LTE() {
  return getToken(LATEXParser::LTE, 0);
}

tree::TerminalNode* LATEXParser::RelationContext::GT() {
  return getToken(LATEXParser::GT, 0);
}

tree::TerminalNode* LATEXParser::RelationContext::GTE() {
  return getToken(LATEXParser::GTE, 0);
}

tree::TerminalNode* LATEXParser::RelationContext::UNEQUAL() {
  return getToken(LATEXParser::UNEQUAL, 0);
}


size_t LATEXParser::RelationContext::getRuleIndex() const {
  return LATEXParser::RuleRelation;
}



LATEXParser::RelationContext* LATEXParser::relation() {
   return relation(0);
}

LATEXParser::RelationContext* LATEXParser::relation(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LATEXParser::RelationContext *_localctx = _tracker.createInstance<RelationContext>(_ctx, parentState);
  LATEXParser::RelationContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 8;
  enterRecursionRule(_localctx, 8, LATEXParser::RuleRelation, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(126);
    expr();
    _ctx->stop = _input->LT(-1);
    setState(133);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<RelationContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleRelation);
        setState(128);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(129);
        _la = _input->LA(1);
        if (!((((_la - 116) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 116)) & 63) != 0)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(130);
        relation(3); 
      }
      setState(135);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Relation_listContext ------------------------------------------------------------------

LATEXParser::Relation_listContext::Relation_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Relation_list_contentContext* LATEXParser::Relation_listContext::relation_list_content() {
  return getRuleContext<LATEXParser::Relation_list_contentContext>(0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::L_PAREN() {
  return getToken(LATEXParser::L_PAREN, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::R_PAREN() {
  return getToken(LATEXParser::R_PAREN, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::L_GROUP() {
  return getToken(LATEXParser::L_GROUP, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::R_GROUP() {
  return getToken(LATEXParser::R_GROUP, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::L_BRACE_VISUAL() {
  return getToken(LATEXParser::L_BRACE_VISUAL, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::R_BRACE_VISUAL() {
  return getToken(LATEXParser::R_BRACE_VISUAL, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::L_BRACE_CMD() {
  return getToken(LATEXParser::L_BRACE_CMD, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::R_BRACE_CMD() {
  return getToken(LATEXParser::R_BRACE_CMD, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::L_BRACKET() {
  return getToken(LATEXParser::L_BRACKET, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::R_BRACKET() {
  return getToken(LATEXParser::R_BRACKET, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::L_BRACK() {
  return getToken(LATEXParser::L_BRACK, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::R_BRACK() {
  return getToken(LATEXParser::R_BRACK, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::L_LEFT() {
  return getToken(LATEXParser::L_LEFT, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::R_RIGHT() {
  return getToken(LATEXParser::R_RIGHT, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::ML_LEFT() {
  return getToken(LATEXParser::ML_LEFT, 0);
}

tree::TerminalNode* LATEXParser::Relation_listContext::MR_RIGHT() {
  return getToken(LATEXParser::MR_RIGHT, 0);
}


size_t LATEXParser::Relation_listContext::getRuleIndex() const {
  return LATEXParser::RuleRelation_list;
}


LATEXParser::Relation_listContext* LATEXParser::relation_list() {
  Relation_listContext *_localctx = _tracker.createInstance<Relation_listContext>(_ctx, getState());
  enterRule(_localctx, 10, LATEXParser::RuleRelation_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(249);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(136);
      relation_list_content();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(137);
      match(LATEXParser::L_PAREN);
      setState(138);
      relation_list_content();
      setState(139);
      match(LATEXParser::R_PAREN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(141);
      match(LATEXParser::L_GROUP);
      setState(142);
      relation_list_content();
      setState(143);
      match(LATEXParser::R_GROUP);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(145);
      match(LATEXParser::L_BRACE);
      setState(146);
      relation_list_content();
      setState(147);
      match(LATEXParser::R_BRACE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(149);
      match(LATEXParser::L_BRACE_VISUAL);
      setState(150);
      relation_list_content();
      setState(151);
      match(LATEXParser::R_BRACE_VISUAL);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(153);
      match(LATEXParser::L_BRACE_CMD);
      setState(154);
      relation_list_content();
      setState(155);
      match(LATEXParser::R_BRACE_CMD);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(157);
      match(LATEXParser::L_BRACKET);
      setState(158);
      relation_list_content();
      setState(159);
      match(LATEXParser::R_BRACKET);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(161);
      match(LATEXParser::L_BRACK);
      setState(162);
      relation_list_content();
      setState(163);
      match(LATEXParser::R_BRACK);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(165);
      match(LATEXParser::L_LEFT);
      setState(166);
      match(LATEXParser::L_PAREN);
      setState(167);
      relation_list_content();
      setState(168);
      match(LATEXParser::R_RIGHT);
      setState(169);
      match(LATEXParser::R_PAREN);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(171);
      match(LATEXParser::L_LEFT);
      setState(172);
      match(LATEXParser::L_GROUP);
      setState(173);
      relation_list_content();
      setState(174);
      match(LATEXParser::R_RIGHT);
      setState(175);
      match(LATEXParser::R_GROUP);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(177);
      match(LATEXParser::L_LEFT);
      setState(178);
      match(LATEXParser::L_BRACE);
      setState(179);
      relation_list_content();
      setState(180);
      match(LATEXParser::R_RIGHT);
      setState(181);
      match(LATEXParser::R_BRACE);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(183);
      match(LATEXParser::L_LEFT);
      setState(184);
      match(LATEXParser::L_BRACE_VISUAL);
      setState(185);
      relation_list_content();
      setState(186);
      match(LATEXParser::R_RIGHT);
      setState(187);
      match(LATEXParser::R_BRACE_VISUAL);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(189);
      match(LATEXParser::L_LEFT);
      setState(190);
      match(LATEXParser::L_BRACE_CMD);
      setState(191);
      relation_list_content();
      setState(192);
      match(LATEXParser::R_RIGHT);
      setState(193);
      match(LATEXParser::R_BRACE_CMD);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(195);
      match(LATEXParser::L_LEFT);
      setState(196);
      match(LATEXParser::L_BRACKET);
      setState(197);
      relation_list_content();
      setState(198);
      match(LATEXParser::R_RIGHT);
      setState(199);
      match(LATEXParser::R_BRACKET);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(201);
      match(LATEXParser::L_LEFT);
      setState(202);
      match(LATEXParser::L_BRACK);
      setState(203);
      relation_list_content();
      setState(204);
      match(LATEXParser::R_RIGHT);
      setState(205);
      match(LATEXParser::R_BRACK);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(207);
      match(LATEXParser::ML_LEFT);
      setState(208);
      match(LATEXParser::L_PAREN);
      setState(209);
      relation_list_content();
      setState(210);
      match(LATEXParser::MR_RIGHT);
      setState(211);
      match(LATEXParser::R_PAREN);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(213);
      match(LATEXParser::ML_LEFT);
      setState(214);
      match(LATEXParser::L_GROUP);
      setState(215);
      relation_list_content();
      setState(216);
      match(LATEXParser::MR_RIGHT);
      setState(217);
      match(LATEXParser::R_GROUP);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(219);
      match(LATEXParser::ML_LEFT);
      setState(220);
      match(LATEXParser::L_BRACE);
      setState(221);
      relation_list_content();
      setState(222);
      match(LATEXParser::MR_RIGHT);
      setState(223);
      match(LATEXParser::R_BRACE);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(225);
      match(LATEXParser::ML_LEFT);
      setState(226);
      match(LATEXParser::L_BRACE_VISUAL);
      setState(227);
      relation_list_content();
      setState(228);
      match(LATEXParser::MR_RIGHT);
      setState(229);
      match(LATEXParser::R_BRACE_VISUAL);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(231);
      match(LATEXParser::ML_LEFT);
      setState(232);
      match(LATEXParser::L_BRACE_CMD);
      setState(233);
      relation_list_content();
      setState(234);
      match(LATEXParser::MR_RIGHT);
      setState(235);
      match(LATEXParser::R_BRACE_CMD);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(237);
      match(LATEXParser::ML_LEFT);
      setState(238);
      match(LATEXParser::L_BRACKET);
      setState(239);
      relation_list_content();
      setState(240);
      match(LATEXParser::MR_RIGHT);
      setState(241);
      match(LATEXParser::R_BRACKET);
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(243);
      match(LATEXParser::ML_LEFT);
      setState(244);
      match(LATEXParser::L_BRACK);
      setState(245);
      relation_list_content();
      setState(246);
      match(LATEXParser::MR_RIGHT);
      setState(247);
      match(LATEXParser::R_BRACK);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Relation_list_contentContext ------------------------------------------------------------------

LATEXParser::Relation_list_contentContext::Relation_list_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LATEXParser::RelationContext *> LATEXParser::Relation_list_contentContext::relation() {
  return getRuleContexts<LATEXParser::RelationContext>();
}

LATEXParser::RelationContext* LATEXParser::Relation_list_contentContext::relation(size_t i) {
  return getRuleContext<LATEXParser::RelationContext>(i);
}

std::vector<tree::TerminalNode *> LATEXParser::Relation_list_contentContext::COMMA() {
  return getTokens(LATEXParser::COMMA);
}

tree::TerminalNode* LATEXParser::Relation_list_contentContext::COMMA(size_t i) {
  return getToken(LATEXParser::COMMA, i);
}

std::vector<tree::TerminalNode *> LATEXParser::Relation_list_contentContext::SEMICOLON() {
  return getTokens(LATEXParser::SEMICOLON);
}

tree::TerminalNode* LATEXParser::Relation_list_contentContext::SEMICOLON(size_t i) {
  return getToken(LATEXParser::SEMICOLON, i);
}


size_t LATEXParser::Relation_list_contentContext::getRuleIndex() const {
  return LATEXParser::RuleRelation_list_content;
}


LATEXParser::Relation_list_contentContext* LATEXParser::relation_list_content() {
  Relation_list_contentContext *_localctx = _tracker.createInstance<Relation_list_contentContext>(_ctx, getState());
  enterRule(_localctx, 12, LATEXParser::RuleRelation_list_content);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(271);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(251);
      relation(0);
      setState(252);
      match(LATEXParser::COMMA);
      setState(253);
      relation(0);
      setState(258);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LATEXParser::COMMA) {
        setState(254);
        match(LATEXParser::COMMA);
        setState(255);
        relation(0);
        setState(260);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(261);
      relation(0);
      setState(262);
      match(LATEXParser::SEMICOLON);
      setState(263);
      relation(0);
      setState(268);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LATEXParser::SEMICOLON) {
        setState(264);
        match(LATEXParser::SEMICOLON);
        setState(265);
        relation(0);
        setState(270);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EqualityContext ------------------------------------------------------------------

LATEXParser::EqualityContext::EqualityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LATEXParser::ExprContext *> LATEXParser::EqualityContext::expr() {
  return getRuleContexts<LATEXParser::ExprContext>();
}

LATEXParser::ExprContext* LATEXParser::EqualityContext::expr(size_t i) {
  return getRuleContext<LATEXParser::ExprContext>(i);
}

tree::TerminalNode* LATEXParser::EqualityContext::EQUAL() {
  return getToken(LATEXParser::EQUAL, 0);
}


size_t LATEXParser::EqualityContext::getRuleIndex() const {
  return LATEXParser::RuleEquality;
}


LATEXParser::EqualityContext* LATEXParser::equality() {
  EqualityContext *_localctx = _tracker.createInstance<EqualityContext>(_ctx, getState());
  enterRule(_localctx, 14, LATEXParser::RuleEquality);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(273);
    expr();
    setState(274);
    match(LATEXParser::EQUAL);
    setState(275);
    expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

LATEXParser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::AdditiveContext* LATEXParser::ExprContext::additive() {
  return getRuleContext<LATEXParser::AdditiveContext>(0);
}


size_t LATEXParser::ExprContext::getRuleIndex() const {
  return LATEXParser::RuleExpr;
}


LATEXParser::ExprContext* LATEXParser::expr() {
  ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, getState());
  enterRule(_localctx, 16, LATEXParser::RuleExpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(277);
    additive(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AdditiveContext ------------------------------------------------------------------

LATEXParser::AdditiveContext::AdditiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::MpContext* LATEXParser::AdditiveContext::mp() {
  return getRuleContext<LATEXParser::MpContext>(0);
}

std::vector<LATEXParser::AdditiveContext *> LATEXParser::AdditiveContext::additive() {
  return getRuleContexts<LATEXParser::AdditiveContext>();
}

LATEXParser::AdditiveContext* LATEXParser::AdditiveContext::additive(size_t i) {
  return getRuleContext<LATEXParser::AdditiveContext>(i);
}

tree::TerminalNode* LATEXParser::AdditiveContext::ADD() {
  return getToken(LATEXParser::ADD, 0);
}

tree::TerminalNode* LATEXParser::AdditiveContext::SUB() {
  return getToken(LATEXParser::SUB, 0);
}


size_t LATEXParser::AdditiveContext::getRuleIndex() const {
  return LATEXParser::RuleAdditive;
}



LATEXParser::AdditiveContext* LATEXParser::additive() {
   return additive(0);
}

LATEXParser::AdditiveContext* LATEXParser::additive(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LATEXParser::AdditiveContext *_localctx = _tracker.createInstance<AdditiveContext>(_ctx, parentState);
  LATEXParser::AdditiveContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 18;
  enterRecursionRule(_localctx, 18, LATEXParser::RuleAdditive, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(280);
    mp(0);
    _ctx->stop = _input->LT(-1);
    setState(287);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<AdditiveContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleAdditive);
        setState(282);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(283);
        _la = _input->LA(1);
        if (!(_la == LATEXParser::ADD

        || _la == LATEXParser::SUB)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(284);
        additive(3); 
      }
      setState(289);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- MpContext ------------------------------------------------------------------

LATEXParser::MpContext::MpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::UnaryContext* LATEXParser::MpContext::unary() {
  return getRuleContext<LATEXParser::UnaryContext>(0);
}

std::vector<LATEXParser::MpContext *> LATEXParser::MpContext::mp() {
  return getRuleContexts<LATEXParser::MpContext>();
}

LATEXParser::MpContext* LATEXParser::MpContext::mp(size_t i) {
  return getRuleContext<LATEXParser::MpContext>(i);
}

tree::TerminalNode* LATEXParser::MpContext::MUL() {
  return getToken(LATEXParser::MUL, 0);
}

tree::TerminalNode* LATEXParser::MpContext::CMD_TIMES() {
  return getToken(LATEXParser::CMD_TIMES, 0);
}

tree::TerminalNode* LATEXParser::MpContext::CMD_CDOT() {
  return getToken(LATEXParser::CMD_CDOT, 0);
}

tree::TerminalNode* LATEXParser::MpContext::DIV() {
  return getToken(LATEXParser::DIV, 0);
}

tree::TerminalNode* LATEXParser::MpContext::CMD_DIV() {
  return getToken(LATEXParser::CMD_DIV, 0);
}

tree::TerminalNode* LATEXParser::MpContext::COLON() {
  return getToken(LATEXParser::COLON, 0);
}

tree::TerminalNode* LATEXParser::MpContext::CMD_MOD() {
  return getToken(LATEXParser::CMD_MOD, 0);
}


size_t LATEXParser::MpContext::getRuleIndex() const {
  return LATEXParser::RuleMp;
}



LATEXParser::MpContext* LATEXParser::mp() {
   return mp(0);
}

LATEXParser::MpContext* LATEXParser::mp(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LATEXParser::MpContext *_localctx = _tracker.createInstance<MpContext>(_ctx, parentState);
  LATEXParser::MpContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 20;
  enterRecursionRule(_localctx, 20, LATEXParser::RuleMp, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(291);
    unary();
    _ctx->stop = _input->LT(-1);
    setState(298);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<MpContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleMp);
        setState(293);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(294);
        _la = _input->LA(1);
        if (!(_la == LATEXParser::MUL

        || _la == LATEXParser::DIV || (((_la - 83) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 83)) & 2097223) != 0)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(295);
        mp(3); 
      }
      setState(300);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Mp_nofuncContext ------------------------------------------------------------------

LATEXParser::Mp_nofuncContext::Mp_nofuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Unary_nofuncContext* LATEXParser::Mp_nofuncContext::unary_nofunc() {
  return getRuleContext<LATEXParser::Unary_nofuncContext>(0);
}

std::vector<LATEXParser::Mp_nofuncContext *> LATEXParser::Mp_nofuncContext::mp_nofunc() {
  return getRuleContexts<LATEXParser::Mp_nofuncContext>();
}

LATEXParser::Mp_nofuncContext* LATEXParser::Mp_nofuncContext::mp_nofunc(size_t i) {
  return getRuleContext<LATEXParser::Mp_nofuncContext>(i);
}

tree::TerminalNode* LATEXParser::Mp_nofuncContext::MUL() {
  return getToken(LATEXParser::MUL, 0);
}

tree::TerminalNode* LATEXParser::Mp_nofuncContext::CMD_TIMES() {
  return getToken(LATEXParser::CMD_TIMES, 0);
}

tree::TerminalNode* LATEXParser::Mp_nofuncContext::CMD_CDOT() {
  return getToken(LATEXParser::CMD_CDOT, 0);
}

tree::TerminalNode* LATEXParser::Mp_nofuncContext::DIV() {
  return getToken(LATEXParser::DIV, 0);
}

tree::TerminalNode* LATEXParser::Mp_nofuncContext::CMD_DIV() {
  return getToken(LATEXParser::CMD_DIV, 0);
}

tree::TerminalNode* LATEXParser::Mp_nofuncContext::COLON() {
  return getToken(LATEXParser::COLON, 0);
}

tree::TerminalNode* LATEXParser::Mp_nofuncContext::CMD_MOD() {
  return getToken(LATEXParser::CMD_MOD, 0);
}


size_t LATEXParser::Mp_nofuncContext::getRuleIndex() const {
  return LATEXParser::RuleMp_nofunc;
}



LATEXParser::Mp_nofuncContext* LATEXParser::mp_nofunc() {
   return mp_nofunc(0);
}

LATEXParser::Mp_nofuncContext* LATEXParser::mp_nofunc(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LATEXParser::Mp_nofuncContext *_localctx = _tracker.createInstance<Mp_nofuncContext>(_ctx, parentState);
  LATEXParser::Mp_nofuncContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 22;
  enterRecursionRule(_localctx, 22, LATEXParser::RuleMp_nofunc, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(302);
    unary_nofunc();
    _ctx->stop = _input->LT(-1);
    setState(309);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Mp_nofuncContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleMp_nofunc);
        setState(304);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(305);
        _la = _input->LA(1);
        if (!(_la == LATEXParser::MUL

        || _la == LATEXParser::DIV || (((_la - 83) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 83)) & 2097223) != 0)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(306);
        mp_nofunc(3); 
      }
      setState(311);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- UnaryContext ------------------------------------------------------------------

LATEXParser::UnaryContext::UnaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::UnaryContext* LATEXParser::UnaryContext::unary() {
  return getRuleContext<LATEXParser::UnaryContext>(0);
}

tree::TerminalNode* LATEXParser::UnaryContext::ADD() {
  return getToken(LATEXParser::ADD, 0);
}

tree::TerminalNode* LATEXParser::UnaryContext::SUB() {
  return getToken(LATEXParser::SUB, 0);
}

std::vector<LATEXParser::PostfixContext *> LATEXParser::UnaryContext::postfix() {
  return getRuleContexts<LATEXParser::PostfixContext>();
}

LATEXParser::PostfixContext* LATEXParser::UnaryContext::postfix(size_t i) {
  return getRuleContext<LATEXParser::PostfixContext>(i);
}


size_t LATEXParser::UnaryContext::getRuleIndex() const {
  return LATEXParser::RuleUnary;
}


LATEXParser::UnaryContext* LATEXParser::unary() {
  UnaryContext *_localctx = _tracker.createInstance<UnaryContext>(_ctx, getState());
  enterRule(_localctx, 24, LATEXParser::RuleUnary);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(319);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::ADD:
      case LATEXParser::SUB: {
        enterOuterAlt(_localctx, 1);
        setState(312);
        _la = _input->LA(1);
        if (!(_la == LATEXParser::ADD

        || _la == LATEXParser::SUB)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(313);
        unary();
        break;
      }

      case LATEXParser::L_PAREN:
      case LATEXParser::L_GROUP:
      case LATEXParser::L_BRACE:
      case LATEXParser::L_BRACE_VISUAL:
      case LATEXParser::L_BRACE_CMD:
      case LATEXParser::L_BRACKET:
      case LATEXParser::L_BRACK:
      case LATEXParser::BAR:
      case LATEXParser::L_VERT:
      case LATEXParser::VERT:
      case LATEXParser::L_FLOOR:
      case LATEXParser::LL_CORNER:
      case LATEXParser::L_CEIL:
      case LATEXParser::UL_CORNER:
      case LATEXParser::L_LEFT:
      case LATEXParser::ML_LEFT:
      case LATEXParser::FUNC_LIM:
      case LATEXParser::FUNC_INT:
      case LATEXParser::FUNC_SUM:
      case LATEXParser::FUNC_PROD:
      case LATEXParser::FUNC_LOG:
      case LATEXParser::FUNC_LN:
      case LATEXParser::FUNC_EXP:
      case LATEXParser::FUNC_SIN:
      case LATEXParser::FUNC_COS:
      case LATEXParser::FUNC_TAN:
      case LATEXParser::FUNC_CSC:
      case LATEXParser::FUNC_SEC:
      case LATEXParser::FUNC_COT:
      case LATEXParser::FUNC_ARCSIN:
      case LATEXParser::FUNC_ARCCOS:
      case LATEXParser::FUNC_ARCTAN:
      case LATEXParser::FUNC_ARCCSC:
      case LATEXParser::FUNC_ARCSEC:
      case LATEXParser::FUNC_ARCCOT:
      case LATEXParser::FUNC_SINH:
      case LATEXParser::FUNC_COSH:
      case LATEXParser::FUNC_TANH:
      case LATEXParser::FUNC_ARSINH:
      case LATEXParser::FUNC_ARCOSH:
      case LATEXParser::FUNC_ARTANH:
      case LATEXParser::FUNC_ARCSINH:
      case LATEXParser::FUNC_ARCCOSH:
      case LATEXParser::FUNC_ARCTANH:
      case LATEXParser::FUNC_SQRT:
      case LATEXParser::FUNC_GCD:
      case LATEXParser::FUNC_LCM:
      case LATEXParser::FUNC_FLOOR:
      case LATEXParser::FUNC_CEIL:
      case LATEXParser::FUNC_MAX:
      case LATEXParser::FUNC_MIN:
      case LATEXParser::CMD_FRAC:
      case LATEXParser::CMD_BINOM:
      case LATEXParser::CMD_CHOOSE:
      case LATEXParser::CMD_MATHIT:
      case LATEXParser::CMD_OPERATORNAME:
      case LATEXParser::CMD_MATRIX_START:
      case LATEXParser::ACCENT_OVERLINE:
      case LATEXParser::ACCENT_BAR:
      case LATEXParser::DIFFERENTIAL:
      case LATEXParser::EXP_E:
      case LATEXParser::LETTER_NO_E:
      case LATEXParser::NUMBER:
      case LATEXParser::FRACTION_NUMBER:
      case LATEXParser::SCI_NOTATION_NUMBER:
      case LATEXParser::E_NOTATION:
      case LATEXParser::PERCENT_NUMBER:
      case LATEXParser::GREEK_CMD:
      case LATEXParser::SYMBOL:
      case LATEXParser::VARIABLE: {
        enterOuterAlt(_localctx, 2);
        setState(315); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(314);
                  postfix();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(317); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_nofuncContext ------------------------------------------------------------------

LATEXParser::Unary_nofuncContext::Unary_nofuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Unary_nofuncContext* LATEXParser::Unary_nofuncContext::unary_nofunc() {
  return getRuleContext<LATEXParser::Unary_nofuncContext>(0);
}

tree::TerminalNode* LATEXParser::Unary_nofuncContext::ADD() {
  return getToken(LATEXParser::ADD, 0);
}

tree::TerminalNode* LATEXParser::Unary_nofuncContext::SUB() {
  return getToken(LATEXParser::SUB, 0);
}

LATEXParser::PostfixContext* LATEXParser::Unary_nofuncContext::postfix() {
  return getRuleContext<LATEXParser::PostfixContext>(0);
}

std::vector<LATEXParser::Postfix_nofuncContext *> LATEXParser::Unary_nofuncContext::postfix_nofunc() {
  return getRuleContexts<LATEXParser::Postfix_nofuncContext>();
}

LATEXParser::Postfix_nofuncContext* LATEXParser::Unary_nofuncContext::postfix_nofunc(size_t i) {
  return getRuleContext<LATEXParser::Postfix_nofuncContext>(i);
}


size_t LATEXParser::Unary_nofuncContext::getRuleIndex() const {
  return LATEXParser::RuleUnary_nofunc;
}


LATEXParser::Unary_nofuncContext* LATEXParser::unary_nofunc() {
  Unary_nofuncContext *_localctx = _tracker.createInstance<Unary_nofuncContext>(_ctx, getState());
  enterRule(_localctx, 26, LATEXParser::RuleUnary_nofunc);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(330);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::ADD:
      case LATEXParser::SUB: {
        enterOuterAlt(_localctx, 1);
        setState(321);
        _la = _input->LA(1);
        if (!(_la == LATEXParser::ADD

        || _la == LATEXParser::SUB)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(322);
        unary_nofunc();
        break;
      }

      case LATEXParser::L_PAREN:
      case LATEXParser::L_GROUP:
      case LATEXParser::L_BRACE:
      case LATEXParser::L_BRACE_VISUAL:
      case LATEXParser::L_BRACE_CMD:
      case LATEXParser::L_BRACKET:
      case LATEXParser::L_BRACK:
      case LATEXParser::BAR:
      case LATEXParser::L_VERT:
      case LATEXParser::VERT:
      case LATEXParser::L_FLOOR:
      case LATEXParser::LL_CORNER:
      case LATEXParser::L_CEIL:
      case LATEXParser::UL_CORNER:
      case LATEXParser::L_LEFT:
      case LATEXParser::ML_LEFT:
      case LATEXParser::FUNC_LIM:
      case LATEXParser::FUNC_INT:
      case LATEXParser::FUNC_SUM:
      case LATEXParser::FUNC_PROD:
      case LATEXParser::FUNC_LOG:
      case LATEXParser::FUNC_LN:
      case LATEXParser::FUNC_EXP:
      case LATEXParser::FUNC_SIN:
      case LATEXParser::FUNC_COS:
      case LATEXParser::FUNC_TAN:
      case LATEXParser::FUNC_CSC:
      case LATEXParser::FUNC_SEC:
      case LATEXParser::FUNC_COT:
      case LATEXParser::FUNC_ARCSIN:
      case LATEXParser::FUNC_ARCCOS:
      case LATEXParser::FUNC_ARCTAN:
      case LATEXParser::FUNC_ARCCSC:
      case LATEXParser::FUNC_ARCSEC:
      case LATEXParser::FUNC_ARCCOT:
      case LATEXParser::FUNC_SINH:
      case LATEXParser::FUNC_COSH:
      case LATEXParser::FUNC_TANH:
      case LATEXParser::FUNC_ARSINH:
      case LATEXParser::FUNC_ARCOSH:
      case LATEXParser::FUNC_ARTANH:
      case LATEXParser::FUNC_ARCSINH:
      case LATEXParser::FUNC_ARCCOSH:
      case LATEXParser::FUNC_ARCTANH:
      case LATEXParser::FUNC_SQRT:
      case LATEXParser::FUNC_GCD:
      case LATEXParser::FUNC_LCM:
      case LATEXParser::FUNC_FLOOR:
      case LATEXParser::FUNC_CEIL:
      case LATEXParser::FUNC_MAX:
      case LATEXParser::FUNC_MIN:
      case LATEXParser::CMD_FRAC:
      case LATEXParser::CMD_BINOM:
      case LATEXParser::CMD_CHOOSE:
      case LATEXParser::CMD_MATHIT:
      case LATEXParser::CMD_OPERATORNAME:
      case LATEXParser::CMD_MATRIX_START:
      case LATEXParser::ACCENT_OVERLINE:
      case LATEXParser::ACCENT_BAR:
      case LATEXParser::DIFFERENTIAL:
      case LATEXParser::EXP_E:
      case LATEXParser::LETTER_NO_E:
      case LATEXParser::NUMBER:
      case LATEXParser::FRACTION_NUMBER:
      case LATEXParser::SCI_NOTATION_NUMBER:
      case LATEXParser::E_NOTATION:
      case LATEXParser::PERCENT_NUMBER:
      case LATEXParser::GREEK_CMD:
      case LATEXParser::SYMBOL:
      case LATEXParser::VARIABLE: {
        enterOuterAlt(_localctx, 2);
        setState(323);
        postfix();
        setState(327);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(324);
            postfix_nofunc(); 
          }
          setState(329);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PostfixContext ------------------------------------------------------------------

LATEXParser::PostfixContext::PostfixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::ExpContext* LATEXParser::PostfixContext::exp() {
  return getRuleContext<LATEXParser::ExpContext>(0);
}

std::vector<LATEXParser::Postfix_opContext *> LATEXParser::PostfixContext::postfix_op() {
  return getRuleContexts<LATEXParser::Postfix_opContext>();
}

LATEXParser::Postfix_opContext* LATEXParser::PostfixContext::postfix_op(size_t i) {
  return getRuleContext<LATEXParser::Postfix_opContext>(i);
}


size_t LATEXParser::PostfixContext::getRuleIndex() const {
  return LATEXParser::RulePostfix;
}


LATEXParser::PostfixContext* LATEXParser::postfix() {
  PostfixContext *_localctx = _tracker.createInstance<PostfixContext>(_ctx, getState());
  enterRule(_localctx, 28, LATEXParser::RulePostfix);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(332);
    exp(0);
    setState(336);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(333);
        postfix_op(); 
      }
      setState(338);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Postfix_nofuncContext ------------------------------------------------------------------

LATEXParser::Postfix_nofuncContext::Postfix_nofuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Exp_nofuncContext* LATEXParser::Postfix_nofuncContext::exp_nofunc() {
  return getRuleContext<LATEXParser::Exp_nofuncContext>(0);
}

std::vector<LATEXParser::Postfix_opContext *> LATEXParser::Postfix_nofuncContext::postfix_op() {
  return getRuleContexts<LATEXParser::Postfix_opContext>();
}

LATEXParser::Postfix_opContext* LATEXParser::Postfix_nofuncContext::postfix_op(size_t i) {
  return getRuleContext<LATEXParser::Postfix_opContext>(i);
}


size_t LATEXParser::Postfix_nofuncContext::getRuleIndex() const {
  return LATEXParser::RulePostfix_nofunc;
}


LATEXParser::Postfix_nofuncContext* LATEXParser::postfix_nofunc() {
  Postfix_nofuncContext *_localctx = _tracker.createInstance<Postfix_nofuncContext>(_ctx, getState());
  enterRule(_localctx, 30, LATEXParser::RulePostfix_nofunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(339);
    exp_nofunc(0);
    setState(343);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(340);
        postfix_op(); 
      }
      setState(345);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Postfix_opContext ------------------------------------------------------------------

LATEXParser::Postfix_opContext::Postfix_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Postfix_opContext::BANG() {
  return getToken(LATEXParser::BANG, 0);
}

LATEXParser::Eval_atContext* LATEXParser::Postfix_opContext::eval_at() {
  return getRuleContext<LATEXParser::Eval_atContext>(0);
}


size_t LATEXParser::Postfix_opContext::getRuleIndex() const {
  return LATEXParser::RulePostfix_op;
}


LATEXParser::Postfix_opContext* LATEXParser::postfix_op() {
  Postfix_opContext *_localctx = _tracker.createInstance<Postfix_opContext>(_ctx, getState());
  enterRule(_localctx, 32, LATEXParser::RulePostfix_op);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(348);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::BANG: {
        enterOuterAlt(_localctx, 1);
        setState(346);
        match(LATEXParser::BANG);
        break;
      }

      case LATEXParser::BAR: {
        enterOuterAlt(_localctx, 2);
        setState(347);
        eval_at();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Eval_atContext ------------------------------------------------------------------

LATEXParser::Eval_atContext::Eval_atContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Eval_atContext::BAR() {
  return getToken(LATEXParser::BAR, 0);
}

LATEXParser::Eval_at_supContext* LATEXParser::Eval_atContext::eval_at_sup() {
  return getRuleContext<LATEXParser::Eval_at_supContext>(0);
}

LATEXParser::Eval_at_subContext* LATEXParser::Eval_atContext::eval_at_sub() {
  return getRuleContext<LATEXParser::Eval_at_subContext>(0);
}


size_t LATEXParser::Eval_atContext::getRuleIndex() const {
  return LATEXParser::RuleEval_at;
}


LATEXParser::Eval_atContext* LATEXParser::eval_at() {
  Eval_atContext *_localctx = _tracker.createInstance<Eval_atContext>(_ctx, getState());
  enterRule(_localctx, 34, LATEXParser::RuleEval_at);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(350);
    match(LATEXParser::BAR);
    setState(356);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      setState(351);
      eval_at_sup();
      break;
    }

    case 2: {
      setState(352);
      eval_at_sub();
      break;
    }

    case 3: {
      setState(353);
      eval_at_sup();
      setState(354);
      eval_at_sub();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Eval_at_subContext ------------------------------------------------------------------

LATEXParser::Eval_at_subContext::Eval_at_subContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Eval_at_subContext::UNDERSCORE() {
  return getToken(LATEXParser::UNDERSCORE, 0);
}

tree::TerminalNode* LATEXParser::Eval_at_subContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

tree::TerminalNode* LATEXParser::Eval_at_subContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

LATEXParser::ExprContext* LATEXParser::Eval_at_subContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

LATEXParser::EqualityContext* LATEXParser::Eval_at_subContext::equality() {
  return getRuleContext<LATEXParser::EqualityContext>(0);
}


size_t LATEXParser::Eval_at_subContext::getRuleIndex() const {
  return LATEXParser::RuleEval_at_sub;
}


LATEXParser::Eval_at_subContext* LATEXParser::eval_at_sub() {
  Eval_at_subContext *_localctx = _tracker.createInstance<Eval_at_subContext>(_ctx, getState());
  enterRule(_localctx, 36, LATEXParser::RuleEval_at_sub);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(358);
    match(LATEXParser::UNDERSCORE);
    setState(359);
    match(LATEXParser::L_BRACE);
    setState(362);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      setState(360);
      expr();
      break;
    }

    case 2: {
      setState(361);
      equality();
      break;
    }

    default:
      break;
    }
    setState(364);
    match(LATEXParser::R_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Eval_at_supContext ------------------------------------------------------------------

LATEXParser::Eval_at_supContext::Eval_at_supContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Eval_at_supContext::CARET() {
  return getToken(LATEXParser::CARET, 0);
}

tree::TerminalNode* LATEXParser::Eval_at_supContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

tree::TerminalNode* LATEXParser::Eval_at_supContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

LATEXParser::ExprContext* LATEXParser::Eval_at_supContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

LATEXParser::EqualityContext* LATEXParser::Eval_at_supContext::equality() {
  return getRuleContext<LATEXParser::EqualityContext>(0);
}


size_t LATEXParser::Eval_at_supContext::getRuleIndex() const {
  return LATEXParser::RuleEval_at_sup;
}


LATEXParser::Eval_at_supContext* LATEXParser::eval_at_sup() {
  Eval_at_supContext *_localctx = _tracker.createInstance<Eval_at_supContext>(_ctx, getState());
  enterRule(_localctx, 38, LATEXParser::RuleEval_at_sup);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(366);
    match(LATEXParser::CARET);
    setState(367);
    match(LATEXParser::L_BRACE);
    setState(370);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
    case 1: {
      setState(368);
      expr();
      break;
    }

    case 2: {
      setState(369);
      equality();
      break;
    }

    default:
      break;
    }
    setState(372);
    match(LATEXParser::R_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpContext ------------------------------------------------------------------

LATEXParser::ExpContext::ExpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::CompContext* LATEXParser::ExpContext::comp() {
  return getRuleContext<LATEXParser::CompContext>(0);
}

LATEXParser::ExpContext* LATEXParser::ExpContext::exp() {
  return getRuleContext<LATEXParser::ExpContext>(0);
}

tree::TerminalNode* LATEXParser::ExpContext::CARET() {
  return getToken(LATEXParser::CARET, 0);
}

LATEXParser::AtomContext* LATEXParser::ExpContext::atom() {
  return getRuleContext<LATEXParser::AtomContext>(0);
}

tree::TerminalNode* LATEXParser::ExpContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

LATEXParser::ExprContext* LATEXParser::ExpContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::ExpContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

LATEXParser::SubexprContext* LATEXParser::ExpContext::subexpr() {
  return getRuleContext<LATEXParser::SubexprContext>(0);
}


size_t LATEXParser::ExpContext::getRuleIndex() const {
  return LATEXParser::RuleExp;
}



LATEXParser::ExpContext* LATEXParser::exp() {
   return exp(0);
}

LATEXParser::ExpContext* LATEXParser::exp(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LATEXParser::ExpContext *_localctx = _tracker.createInstance<ExpContext>(_ctx, parentState);
  LATEXParser::ExpContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 40;
  enterRecursionRule(_localctx, 40, LATEXParser::RuleExp, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(375);
    comp();
    _ctx->stop = _input->LT(-1);
    setState(391);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<ExpContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleExp);
        setState(377);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(378);
        match(LATEXParser::CARET);
        setState(384);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case LATEXParser::CMD_MATHIT:
          case LATEXParser::ACCENT_OVERLINE:
          case LATEXParser::ACCENT_BAR:
          case LATEXParser::DIFFERENTIAL:
          case LATEXParser::LETTER_NO_E:
          case LATEXParser::NUMBER:
          case LATEXParser::FRACTION_NUMBER:
          case LATEXParser::SCI_NOTATION_NUMBER:
          case LATEXParser::E_NOTATION:
          case LATEXParser::PERCENT_NUMBER:
          case LATEXParser::GREEK_CMD:
          case LATEXParser::SYMBOL:
          case LATEXParser::VARIABLE: {
            setState(379);
            atom();
            break;
          }

          case LATEXParser::L_BRACE: {
            setState(380);
            match(LATEXParser::L_BRACE);
            setState(381);
            expr();
            setState(382);
            match(LATEXParser::R_BRACE);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(387);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
        case 1: {
          setState(386);
          subexpr();
          break;
        }

        default:
          break;
        } 
      }
      setState(393);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Exp_nofuncContext ------------------------------------------------------------------

LATEXParser::Exp_nofuncContext::Exp_nofuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Comp_nofuncContext* LATEXParser::Exp_nofuncContext::comp_nofunc() {
  return getRuleContext<LATEXParser::Comp_nofuncContext>(0);
}

LATEXParser::Exp_nofuncContext* LATEXParser::Exp_nofuncContext::exp_nofunc() {
  return getRuleContext<LATEXParser::Exp_nofuncContext>(0);
}

tree::TerminalNode* LATEXParser::Exp_nofuncContext::CARET() {
  return getToken(LATEXParser::CARET, 0);
}

LATEXParser::AtomContext* LATEXParser::Exp_nofuncContext::atom() {
  return getRuleContext<LATEXParser::AtomContext>(0);
}

tree::TerminalNode* LATEXParser::Exp_nofuncContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

LATEXParser::ExprContext* LATEXParser::Exp_nofuncContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::Exp_nofuncContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

LATEXParser::SubexprContext* LATEXParser::Exp_nofuncContext::subexpr() {
  return getRuleContext<LATEXParser::SubexprContext>(0);
}


size_t LATEXParser::Exp_nofuncContext::getRuleIndex() const {
  return LATEXParser::RuleExp_nofunc;
}



LATEXParser::Exp_nofuncContext* LATEXParser::exp_nofunc() {
   return exp_nofunc(0);
}

LATEXParser::Exp_nofuncContext* LATEXParser::exp_nofunc(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LATEXParser::Exp_nofuncContext *_localctx = _tracker.createInstance<Exp_nofuncContext>(_ctx, parentState);
  LATEXParser::Exp_nofuncContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 42;
  enterRecursionRule(_localctx, 42, LATEXParser::RuleExp_nofunc, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(395);
    comp_nofunc();
    _ctx->stop = _input->LT(-1);
    setState(411);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Exp_nofuncContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleExp_nofunc);
        setState(397);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(398);
        match(LATEXParser::CARET);
        setState(404);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case LATEXParser::CMD_MATHIT:
          case LATEXParser::ACCENT_OVERLINE:
          case LATEXParser::ACCENT_BAR:
          case LATEXParser::DIFFERENTIAL:
          case LATEXParser::LETTER_NO_E:
          case LATEXParser::NUMBER:
          case LATEXParser::FRACTION_NUMBER:
          case LATEXParser::SCI_NOTATION_NUMBER:
          case LATEXParser::E_NOTATION:
          case LATEXParser::PERCENT_NUMBER:
          case LATEXParser::GREEK_CMD:
          case LATEXParser::SYMBOL:
          case LATEXParser::VARIABLE: {
            setState(399);
            atom();
            break;
          }

          case LATEXParser::L_BRACE: {
            setState(400);
            match(LATEXParser::L_BRACE);
            setState(401);
            expr();
            setState(402);
            match(LATEXParser::R_BRACE);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(407);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
        case 1: {
          setState(406);
          subexpr();
          break;
        }

        default:
          break;
        } 
      }
      setState(413);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- CompContext ------------------------------------------------------------------

LATEXParser::CompContext::CompContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::GroupContext* LATEXParser::CompContext::group() {
  return getRuleContext<LATEXParser::GroupContext>(0);
}

LATEXParser::Abs_groupContext* LATEXParser::CompContext::abs_group() {
  return getRuleContext<LATEXParser::Abs_groupContext>(0);
}

LATEXParser::Floor_groupContext* LATEXParser::CompContext::floor_group() {
  return getRuleContext<LATEXParser::Floor_groupContext>(0);
}

LATEXParser::Ceil_groupContext* LATEXParser::CompContext::ceil_group() {
  return getRuleContext<LATEXParser::Ceil_groupContext>(0);
}

LATEXParser::FuncContext* LATEXParser::CompContext::func() {
  return getRuleContext<LATEXParser::FuncContext>(0);
}

LATEXParser::AtomContext* LATEXParser::CompContext::atom() {
  return getRuleContext<LATEXParser::AtomContext>(0);
}

LATEXParser::FracContext* LATEXParser::CompContext::frac() {
  return getRuleContext<LATEXParser::FracContext>(0);
}

LATEXParser::BinomContext* LATEXParser::CompContext::binom() {
  return getRuleContext<LATEXParser::BinomContext>(0);
}

LATEXParser::MatrixContext* LATEXParser::CompContext::matrix() {
  return getRuleContext<LATEXParser::MatrixContext>(0);
}


size_t LATEXParser::CompContext::getRuleIndex() const {
  return LATEXParser::RuleComp;
}


LATEXParser::CompContext* LATEXParser::comp() {
  CompContext *_localctx = _tracker.createInstance<CompContext>(_ctx, getState());
  enterRule(_localctx, 44, LATEXParser::RuleComp);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(423);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(414);
      group();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(415);
      abs_group();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(416);
      floor_group();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(417);
      ceil_group();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(418);
      func();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(419);
      atom();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(420);
      frac();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(421);
      binom();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(422);
      matrix();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comp_nofuncContext ------------------------------------------------------------------

LATEXParser::Comp_nofuncContext::Comp_nofuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::GroupContext* LATEXParser::Comp_nofuncContext::group() {
  return getRuleContext<LATEXParser::GroupContext>(0);
}

LATEXParser::Abs_groupContext* LATEXParser::Comp_nofuncContext::abs_group() {
  return getRuleContext<LATEXParser::Abs_groupContext>(0);
}

LATEXParser::Floor_groupContext* LATEXParser::Comp_nofuncContext::floor_group() {
  return getRuleContext<LATEXParser::Floor_groupContext>(0);
}

LATEXParser::Ceil_groupContext* LATEXParser::Comp_nofuncContext::ceil_group() {
  return getRuleContext<LATEXParser::Ceil_groupContext>(0);
}

LATEXParser::AtomContext* LATEXParser::Comp_nofuncContext::atom() {
  return getRuleContext<LATEXParser::AtomContext>(0);
}

LATEXParser::FracContext* LATEXParser::Comp_nofuncContext::frac() {
  return getRuleContext<LATEXParser::FracContext>(0);
}

LATEXParser::BinomContext* LATEXParser::Comp_nofuncContext::binom() {
  return getRuleContext<LATEXParser::BinomContext>(0);
}

LATEXParser::MatrixContext* LATEXParser::Comp_nofuncContext::matrix() {
  return getRuleContext<LATEXParser::MatrixContext>(0);
}


size_t LATEXParser::Comp_nofuncContext::getRuleIndex() const {
  return LATEXParser::RuleComp_nofunc;
}


LATEXParser::Comp_nofuncContext* LATEXParser::comp_nofunc() {
  Comp_nofuncContext *_localctx = _tracker.createInstance<Comp_nofuncContext>(_ctx, getState());
  enterRule(_localctx, 46, LATEXParser::RuleComp_nofunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(433);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(425);
      group();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(426);
      abs_group();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(427);
      floor_group();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(428);
      ceil_group();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(429);
      atom();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(430);
      frac();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(431);
      binom();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(432);
      matrix();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupContext ------------------------------------------------------------------

LATEXParser::GroupContext::GroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::GroupContext::L_PAREN() {
  return getToken(LATEXParser::L_PAREN, 0);
}

LATEXParser::ExprContext* LATEXParser::GroupContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::GroupContext::R_PAREN() {
  return getToken(LATEXParser::R_PAREN, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::L_GROUP() {
  return getToken(LATEXParser::L_GROUP, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::R_GROUP() {
  return getToken(LATEXParser::R_GROUP, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::L_BRACE_VISUAL() {
  return getToken(LATEXParser::L_BRACE_VISUAL, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::R_BRACE_VISUAL() {
  return getToken(LATEXParser::R_BRACE_VISUAL, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::L_BRACE_CMD() {
  return getToken(LATEXParser::L_BRACE_CMD, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::R_BRACE_CMD() {
  return getToken(LATEXParser::R_BRACE_CMD, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::L_BRACKET() {
  return getToken(LATEXParser::L_BRACKET, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::R_BRACKET() {
  return getToken(LATEXParser::R_BRACKET, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::L_BRACK() {
  return getToken(LATEXParser::L_BRACK, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::R_BRACK() {
  return getToken(LATEXParser::R_BRACK, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::L_LEFT() {
  return getToken(LATEXParser::L_LEFT, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::R_RIGHT() {
  return getToken(LATEXParser::R_RIGHT, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::ML_LEFT() {
  return getToken(LATEXParser::ML_LEFT, 0);
}

tree::TerminalNode* LATEXParser::GroupContext::MR_RIGHT() {
  return getToken(LATEXParser::MR_RIGHT, 0);
}


size_t LATEXParser::GroupContext::getRuleIndex() const {
  return LATEXParser::RuleGroup;
}


LATEXParser::GroupContext* LATEXParser::group() {
  GroupContext *_localctx = _tracker.createInstance<GroupContext>(_ctx, getState());
  enterRule(_localctx, 48, LATEXParser::RuleGroup);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(547);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(435);
      match(LATEXParser::L_PAREN);
      setState(436);
      expr();
      setState(437);
      match(LATEXParser::R_PAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(439);
      match(LATEXParser::L_GROUP);
      setState(440);
      expr();
      setState(441);
      match(LATEXParser::R_GROUP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(443);
      match(LATEXParser::L_BRACE);
      setState(444);
      expr();
      setState(445);
      match(LATEXParser::R_BRACE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(447);
      match(LATEXParser::L_BRACE_VISUAL);
      setState(448);
      expr();
      setState(449);
      match(LATEXParser::R_BRACE_VISUAL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(451);
      match(LATEXParser::L_BRACE_CMD);
      setState(452);
      expr();
      setState(453);
      match(LATEXParser::R_BRACE_CMD);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(455);
      match(LATEXParser::L_BRACKET);
      setState(456);
      expr();
      setState(457);
      match(LATEXParser::R_BRACKET);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(459);
      match(LATEXParser::L_BRACK);
      setState(460);
      expr();
      setState(461);
      match(LATEXParser::R_BRACK);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(463);
      match(LATEXParser::L_LEFT);
      setState(464);
      match(LATEXParser::L_PAREN);
      setState(465);
      expr();
      setState(466);
      match(LATEXParser::R_RIGHT);
      setState(467);
      match(LATEXParser::R_PAREN);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(469);
      match(LATEXParser::L_LEFT);
      setState(470);
      match(LATEXParser::L_GROUP);
      setState(471);
      expr();
      setState(472);
      match(LATEXParser::R_RIGHT);
      setState(473);
      match(LATEXParser::R_GROUP);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(475);
      match(LATEXParser::L_LEFT);
      setState(476);
      match(LATEXParser::L_BRACE);
      setState(477);
      expr();
      setState(478);
      match(LATEXParser::R_RIGHT);
      setState(479);
      match(LATEXParser::R_BRACE);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(481);
      match(LATEXParser::L_LEFT);
      setState(482);
      match(LATEXParser::L_BRACE_VISUAL);
      setState(483);
      expr();
      setState(484);
      match(LATEXParser::R_RIGHT);
      setState(485);
      match(LATEXParser::R_BRACE_VISUAL);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(487);
      match(LATEXParser::L_LEFT);
      setState(488);
      match(LATEXParser::L_BRACE_CMD);
      setState(489);
      expr();
      setState(490);
      match(LATEXParser::R_RIGHT);
      setState(491);
      match(LATEXParser::R_BRACE_CMD);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(493);
      match(LATEXParser::L_LEFT);
      setState(494);
      match(LATEXParser::L_BRACKET);
      setState(495);
      expr();
      setState(496);
      match(LATEXParser::R_RIGHT);
      setState(497);
      match(LATEXParser::R_BRACKET);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(499);
      match(LATEXParser::L_LEFT);
      setState(500);
      match(LATEXParser::L_BRACK);
      setState(501);
      expr();
      setState(502);
      match(LATEXParser::R_RIGHT);
      setState(503);
      match(LATEXParser::R_BRACK);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(505);
      match(LATEXParser::ML_LEFT);
      setState(506);
      match(LATEXParser::L_PAREN);
      setState(507);
      expr();
      setState(508);
      match(LATEXParser::MR_RIGHT);
      setState(509);
      match(LATEXParser::R_PAREN);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(511);
      match(LATEXParser::ML_LEFT);
      setState(512);
      match(LATEXParser::L_GROUP);
      setState(513);
      expr();
      setState(514);
      match(LATEXParser::MR_RIGHT);
      setState(515);
      match(LATEXParser::R_GROUP);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(517);
      match(LATEXParser::ML_LEFT);
      setState(518);
      match(LATEXParser::L_BRACE);
      setState(519);
      expr();
      setState(520);
      match(LATEXParser::MR_RIGHT);
      setState(521);
      match(LATEXParser::R_BRACE);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(523);
      match(LATEXParser::ML_LEFT);
      setState(524);
      match(LATEXParser::L_BRACE_VISUAL);
      setState(525);
      expr();
      setState(526);
      match(LATEXParser::MR_RIGHT);
      setState(527);
      match(LATEXParser::R_BRACE_VISUAL);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(529);
      match(LATEXParser::ML_LEFT);
      setState(530);
      match(LATEXParser::L_BRACE_CMD);
      setState(531);
      expr();
      setState(532);
      match(LATEXParser::MR_RIGHT);
      setState(533);
      match(LATEXParser::R_BRACE_CMD);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(535);
      match(LATEXParser::ML_LEFT);
      setState(536);
      match(LATEXParser::L_BRACKET);
      setState(537);
      expr();
      setState(538);
      match(LATEXParser::MR_RIGHT);
      setState(539);
      match(LATEXParser::R_BRACKET);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(541);
      match(LATEXParser::ML_LEFT);
      setState(542);
      match(LATEXParser::L_BRACK);
      setState(543);
      expr();
      setState(544);
      match(LATEXParser::MR_RIGHT);
      setState(545);
      match(LATEXParser::R_BRACK);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Abs_groupContext ------------------------------------------------------------------

LATEXParser::Abs_groupContext::Abs_groupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LATEXParser::Abs_groupContext::BAR() {
  return getTokens(LATEXParser::BAR);
}

tree::TerminalNode* LATEXParser::Abs_groupContext::BAR(size_t i) {
  return getToken(LATEXParser::BAR, i);
}

LATEXParser::ExprContext* LATEXParser::Abs_groupContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::Abs_groupContext::L_VERT() {
  return getToken(LATEXParser::L_VERT, 0);
}

tree::TerminalNode* LATEXParser::Abs_groupContext::R_VERT() {
  return getToken(LATEXParser::R_VERT, 0);
}

std::vector<tree::TerminalNode *> LATEXParser::Abs_groupContext::VERT() {
  return getTokens(LATEXParser::VERT);
}

tree::TerminalNode* LATEXParser::Abs_groupContext::VERT(size_t i) {
  return getToken(LATEXParser::VERT, i);
}

tree::TerminalNode* LATEXParser::Abs_groupContext::L_LEFT() {
  return getToken(LATEXParser::L_LEFT, 0);
}

tree::TerminalNode* LATEXParser::Abs_groupContext::R_RIGHT() {
  return getToken(LATEXParser::R_RIGHT, 0);
}

tree::TerminalNode* LATEXParser::Abs_groupContext::ML_LEFT() {
  return getToken(LATEXParser::ML_LEFT, 0);
}

tree::TerminalNode* LATEXParser::Abs_groupContext::MR_RIGHT() {
  return getToken(LATEXParser::MR_RIGHT, 0);
}


size_t LATEXParser::Abs_groupContext::getRuleIndex() const {
  return LATEXParser::RuleAbs_group;
}


LATEXParser::Abs_groupContext* LATEXParser::abs_group() {
  Abs_groupContext *_localctx = _tracker.createInstance<Abs_groupContext>(_ctx, getState());
  enterRule(_localctx, 50, LATEXParser::RuleAbs_group);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(597);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(549);
      match(LATEXParser::BAR);
      setState(550);
      expr();
      setState(551);
      match(LATEXParser::BAR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(553);
      match(LATEXParser::L_VERT);
      setState(554);
      expr();
      setState(555);
      match(LATEXParser::R_VERT);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(557);
      match(LATEXParser::VERT);
      setState(558);
      expr();
      setState(559);
      match(LATEXParser::VERT);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(561);
      match(LATEXParser::L_LEFT);
      setState(562);
      match(LATEXParser::BAR);
      setState(563);
      expr();
      setState(564);
      match(LATEXParser::R_RIGHT);
      setState(565);
      match(LATEXParser::BAR);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(567);
      match(LATEXParser::L_LEFT);
      setState(568);
      match(LATEXParser::L_VERT);
      setState(569);
      expr();
      setState(570);
      match(LATEXParser::R_RIGHT);
      setState(571);
      match(LATEXParser::R_VERT);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(573);
      match(LATEXParser::L_LEFT);
      setState(574);
      match(LATEXParser::VERT);
      setState(575);
      expr();
      setState(576);
      match(LATEXParser::R_RIGHT);
      setState(577);
      match(LATEXParser::VERT);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(579);
      match(LATEXParser::ML_LEFT);
      setState(580);
      match(LATEXParser::BAR);
      setState(581);
      expr();
      setState(582);
      match(LATEXParser::MR_RIGHT);
      setState(583);
      match(LATEXParser::BAR);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(585);
      match(LATEXParser::ML_LEFT);
      setState(586);
      match(LATEXParser::L_VERT);
      setState(587);
      expr();
      setState(588);
      match(LATEXParser::MR_RIGHT);
      setState(589);
      match(LATEXParser::R_VERT);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(591);
      match(LATEXParser::ML_LEFT);
      setState(592);
      match(LATEXParser::VERT);
      setState(593);
      expr();
      setState(594);
      match(LATEXParser::MR_RIGHT);
      setState(595);
      match(LATEXParser::VERT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Floor_groupContext ------------------------------------------------------------------

LATEXParser::Floor_groupContext::Floor_groupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Floor_groupContext::L_FLOOR() {
  return getToken(LATEXParser::L_FLOOR, 0);
}

LATEXParser::ExprContext* LATEXParser::Floor_groupContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::Floor_groupContext::R_FLOOR() {
  return getToken(LATEXParser::R_FLOOR, 0);
}

tree::TerminalNode* LATEXParser::Floor_groupContext::LL_CORNER() {
  return getToken(LATEXParser::LL_CORNER, 0);
}

tree::TerminalNode* LATEXParser::Floor_groupContext::LR_CORNER() {
  return getToken(LATEXParser::LR_CORNER, 0);
}

tree::TerminalNode* LATEXParser::Floor_groupContext::L_LEFT() {
  return getToken(LATEXParser::L_LEFT, 0);
}

tree::TerminalNode* LATEXParser::Floor_groupContext::R_RIGHT() {
  return getToken(LATEXParser::R_RIGHT, 0);
}

tree::TerminalNode* LATEXParser::Floor_groupContext::ML_LEFT() {
  return getToken(LATEXParser::ML_LEFT, 0);
}

tree::TerminalNode* LATEXParser::Floor_groupContext::MR_RIGHT() {
  return getToken(LATEXParser::MR_RIGHT, 0);
}


size_t LATEXParser::Floor_groupContext::getRuleIndex() const {
  return LATEXParser::RuleFloor_group;
}


LATEXParser::Floor_groupContext* LATEXParser::floor_group() {
  Floor_groupContext *_localctx = _tracker.createInstance<Floor_groupContext>(_ctx, getState());
  enterRule(_localctx, 52, LATEXParser::RuleFloor_group);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(631);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(599);
      match(LATEXParser::L_FLOOR);
      setState(600);
      expr();
      setState(601);
      match(LATEXParser::R_FLOOR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(603);
      match(LATEXParser::LL_CORNER);
      setState(604);
      expr();
      setState(605);
      match(LATEXParser::LR_CORNER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(607);
      match(LATEXParser::L_LEFT);
      setState(608);
      match(LATEXParser::L_FLOOR);
      setState(609);
      expr();
      setState(610);
      match(LATEXParser::R_RIGHT);
      setState(611);
      match(LATEXParser::R_FLOOR);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(613);
      match(LATEXParser::L_LEFT);
      setState(614);
      match(LATEXParser::LL_CORNER);
      setState(615);
      expr();
      setState(616);
      match(LATEXParser::R_RIGHT);
      setState(617);
      match(LATEXParser::LR_CORNER);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(619);
      match(LATEXParser::ML_LEFT);
      setState(620);
      match(LATEXParser::L_FLOOR);
      setState(621);
      expr();
      setState(622);
      match(LATEXParser::MR_RIGHT);
      setState(623);
      match(LATEXParser::R_FLOOR);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(625);
      match(LATEXParser::ML_LEFT);
      setState(626);
      match(LATEXParser::LL_CORNER);
      setState(627);
      expr();
      setState(628);
      match(LATEXParser::MR_RIGHT);
      setState(629);
      match(LATEXParser::LR_CORNER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ceil_groupContext ------------------------------------------------------------------

LATEXParser::Ceil_groupContext::Ceil_groupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Ceil_groupContext::L_CEIL() {
  return getToken(LATEXParser::L_CEIL, 0);
}

LATEXParser::ExprContext* LATEXParser::Ceil_groupContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::Ceil_groupContext::R_CEIL() {
  return getToken(LATEXParser::R_CEIL, 0);
}

tree::TerminalNode* LATEXParser::Ceil_groupContext::UL_CORNER() {
  return getToken(LATEXParser::UL_CORNER, 0);
}

tree::TerminalNode* LATEXParser::Ceil_groupContext::UR_CORNER() {
  return getToken(LATEXParser::UR_CORNER, 0);
}

tree::TerminalNode* LATEXParser::Ceil_groupContext::L_LEFT() {
  return getToken(LATEXParser::L_LEFT, 0);
}

tree::TerminalNode* LATEXParser::Ceil_groupContext::R_RIGHT() {
  return getToken(LATEXParser::R_RIGHT, 0);
}

tree::TerminalNode* LATEXParser::Ceil_groupContext::ML_LEFT() {
  return getToken(LATEXParser::ML_LEFT, 0);
}

tree::TerminalNode* LATEXParser::Ceil_groupContext::MR_RIGHT() {
  return getToken(LATEXParser::MR_RIGHT, 0);
}


size_t LATEXParser::Ceil_groupContext::getRuleIndex() const {
  return LATEXParser::RuleCeil_group;
}


LATEXParser::Ceil_groupContext* LATEXParser::ceil_group() {
  Ceil_groupContext *_localctx = _tracker.createInstance<Ceil_groupContext>(_ctx, getState());
  enterRule(_localctx, 54, LATEXParser::RuleCeil_group);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(665);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(633);
      match(LATEXParser::L_CEIL);
      setState(634);
      expr();
      setState(635);
      match(LATEXParser::R_CEIL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(637);
      match(LATEXParser::UL_CORNER);
      setState(638);
      expr();
      setState(639);
      match(LATEXParser::UR_CORNER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(641);
      match(LATEXParser::L_LEFT);
      setState(642);
      match(LATEXParser::L_CEIL);
      setState(643);
      expr();
      setState(644);
      match(LATEXParser::R_RIGHT);
      setState(645);
      match(LATEXParser::R_CEIL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(647);
      match(LATEXParser::L_LEFT);
      setState(648);
      match(LATEXParser::UL_CORNER);
      setState(649);
      expr();
      setState(650);
      match(LATEXParser::R_RIGHT);
      setState(651);
      match(LATEXParser::UR_CORNER);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(653);
      match(LATEXParser::ML_LEFT);
      setState(654);
      match(LATEXParser::L_CEIL);
      setState(655);
      expr();
      setState(656);
      match(LATEXParser::MR_RIGHT);
      setState(657);
      match(LATEXParser::R_CEIL);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(659);
      match(LATEXParser::ML_LEFT);
      setState(660);
      match(LATEXParser::UL_CORNER);
      setState(661);
      expr();
      setState(662);
      match(LATEXParser::MR_RIGHT);
      setState(663);
      match(LATEXParser::UR_CORNER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccentContext ------------------------------------------------------------------

LATEXParser::AccentContext::AccentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Accent_symbolContext* LATEXParser::AccentContext::accent_symbol() {
  return getRuleContext<LATEXParser::Accent_symbolContext>(0);
}

tree::TerminalNode* LATEXParser::AccentContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

tree::TerminalNode* LATEXParser::AccentContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

LATEXParser::ExprContext* LATEXParser::AccentContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}


size_t LATEXParser::AccentContext::getRuleIndex() const {
  return LATEXParser::RuleAccent;
}


LATEXParser::AccentContext* LATEXParser::accent() {
  AccentContext *_localctx = _tracker.createInstance<AccentContext>(_ctx, getState());
  enterRule(_localctx, 56, LATEXParser::RuleAccent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(667);
    accent_symbol();
    setState(668);
    match(LATEXParser::L_BRACE);
    setState(669);
    antlrcpp::downCast<AccentContext *>(_localctx)->base = expr();
    setState(670);
    match(LATEXParser::R_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Atom_exprContext ------------------------------------------------------------------

LATEXParser::Atom_exprContext::Atom_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Atom_exprContext::LETTER_NO_E() {
  return getToken(LATEXParser::LETTER_NO_E, 0);
}

tree::TerminalNode* LATEXParser::Atom_exprContext::GREEK_CMD() {
  return getToken(LATEXParser::GREEK_CMD, 0);
}

LATEXParser::AccentContext* LATEXParser::Atom_exprContext::accent() {
  return getRuleContext<LATEXParser::AccentContext>(0);
}

LATEXParser::SupexprContext* LATEXParser::Atom_exprContext::supexpr() {
  return getRuleContext<LATEXParser::SupexprContext>(0);
}

LATEXParser::SubexprContext* LATEXParser::Atom_exprContext::subexpr() {
  return getRuleContext<LATEXParser::SubexprContext>(0);
}


size_t LATEXParser::Atom_exprContext::getRuleIndex() const {
  return LATEXParser::RuleAtom_expr;
}


LATEXParser::Atom_exprContext* LATEXParser::atom_expr() {
  Atom_exprContext *_localctx = _tracker.createInstance<Atom_exprContext>(_ctx, getState());
  enterRule(_localctx, 58, LATEXParser::RuleAtom_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(675);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::LETTER_NO_E: {
        setState(672);
        match(LATEXParser::LETTER_NO_E);
        break;
      }

      case LATEXParser::GREEK_CMD: {
        setState(673);
        match(LATEXParser::GREEK_CMD);
        break;
      }

      case LATEXParser::ACCENT_OVERLINE:
      case LATEXParser::ACCENT_BAR: {
        setState(674);
        accent();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(685);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
    case 1: {
      setState(677);
      supexpr();
      setState(678);
      subexpr();
      break;
    }

    case 2: {
      setState(680);
      subexpr();
      setState(681);
      supexpr();
      break;
    }

    case 3: {
      setState(683);
      subexpr();
      break;
    }

    case 4: {
      setState(684);
      supexpr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AtomContext ------------------------------------------------------------------

LATEXParser::AtomContext::AtomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Atom_exprContext* LATEXParser::AtomContext::atom_expr() {
  return getRuleContext<LATEXParser::Atom_exprContext>(0);
}

tree::TerminalNode* LATEXParser::AtomContext::SYMBOL() {
  return getToken(LATEXParser::SYMBOL, 0);
}

tree::TerminalNode* LATEXParser::AtomContext::NUMBER() {
  return getToken(LATEXParser::NUMBER, 0);
}

tree::TerminalNode* LATEXParser::AtomContext::SCI_NOTATION_NUMBER() {
  return getToken(LATEXParser::SCI_NOTATION_NUMBER, 0);
}

tree::TerminalNode* LATEXParser::AtomContext::FRACTION_NUMBER() {
  return getToken(LATEXParser::FRACTION_NUMBER, 0);
}

tree::TerminalNode* LATEXParser::AtomContext::PERCENT_NUMBER() {
  return getToken(LATEXParser::PERCENT_NUMBER, 0);
}

tree::TerminalNode* LATEXParser::AtomContext::E_NOTATION() {
  return getToken(LATEXParser::E_NOTATION, 0);
}

tree::TerminalNode* LATEXParser::AtomContext::DIFFERENTIAL() {
  return getToken(LATEXParser::DIFFERENTIAL, 0);
}

LATEXParser::MathitContext* LATEXParser::AtomContext::mathit() {
  return getRuleContext<LATEXParser::MathitContext>(0);
}

tree::TerminalNode* LATEXParser::AtomContext::VARIABLE() {
  return getToken(LATEXParser::VARIABLE, 0);
}


size_t LATEXParser::AtomContext::getRuleIndex() const {
  return LATEXParser::RuleAtom;
}


LATEXParser::AtomContext* LATEXParser::atom() {
  AtomContext *_localctx = _tracker.createInstance<AtomContext>(_ctx, getState());
  enterRule(_localctx, 60, LATEXParser::RuleAtom);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(697);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::ACCENT_OVERLINE:
      case LATEXParser::ACCENT_BAR:
      case LATEXParser::LETTER_NO_E:
      case LATEXParser::GREEK_CMD: {
        enterOuterAlt(_localctx, 1);
        setState(687);
        atom_expr();
        break;
      }

      case LATEXParser::SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(688);
        match(LATEXParser::SYMBOL);
        break;
      }

      case LATEXParser::NUMBER: {
        enterOuterAlt(_localctx, 3);
        setState(689);
        match(LATEXParser::NUMBER);
        break;
      }

      case LATEXParser::SCI_NOTATION_NUMBER: {
        enterOuterAlt(_localctx, 4);
        setState(690);
        match(LATEXParser::SCI_NOTATION_NUMBER);
        break;
      }

      case LATEXParser::FRACTION_NUMBER: {
        enterOuterAlt(_localctx, 5);
        setState(691);
        match(LATEXParser::FRACTION_NUMBER);
        break;
      }

      case LATEXParser::PERCENT_NUMBER: {
        enterOuterAlt(_localctx, 6);
        setState(692);
        match(LATEXParser::PERCENT_NUMBER);
        break;
      }

      case LATEXParser::E_NOTATION: {
        enterOuterAlt(_localctx, 7);
        setState(693);
        match(LATEXParser::E_NOTATION);
        break;
      }

      case LATEXParser::DIFFERENTIAL: {
        enterOuterAlt(_localctx, 8);
        setState(694);
        match(LATEXParser::DIFFERENTIAL);
        break;
      }

      case LATEXParser::CMD_MATHIT: {
        enterOuterAlt(_localctx, 9);
        setState(695);
        mathit();
        break;
      }

      case LATEXParser::VARIABLE: {
        enterOuterAlt(_localctx, 10);
        setState(696);
        match(LATEXParser::VARIABLE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MathitContext ------------------------------------------------------------------

LATEXParser::MathitContext::MathitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::MathitContext::CMD_MATHIT() {
  return getToken(LATEXParser::CMD_MATHIT, 0);
}

tree::TerminalNode* LATEXParser::MathitContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

LATEXParser::Mathit_textContext* LATEXParser::MathitContext::mathit_text() {
  return getRuleContext<LATEXParser::Mathit_textContext>(0);
}

tree::TerminalNode* LATEXParser::MathitContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}


size_t LATEXParser::MathitContext::getRuleIndex() const {
  return LATEXParser::RuleMathit;
}


LATEXParser::MathitContext* LATEXParser::mathit() {
  MathitContext *_localctx = _tracker.createInstance<MathitContext>(_ctx, getState());
  enterRule(_localctx, 62, LATEXParser::RuleMathit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(699);
    match(LATEXParser::CMD_MATHIT);
    setState(700);
    match(LATEXParser::L_BRACE);
    setState(701);
    mathit_text();
    setState(702);
    match(LATEXParser::R_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mathit_textContext ------------------------------------------------------------------

LATEXParser::Mathit_textContext::Mathit_textContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LATEXParser::Mathit_textContext::LETTER_NO_E() {
  return getTokens(LATEXParser::LETTER_NO_E);
}

tree::TerminalNode* LATEXParser::Mathit_textContext::LETTER_NO_E(size_t i) {
  return getToken(LATEXParser::LETTER_NO_E, i);
}

std::vector<tree::TerminalNode *> LATEXParser::Mathit_textContext::E_NOTATION_E() {
  return getTokens(LATEXParser::E_NOTATION_E);
}

tree::TerminalNode* LATEXParser::Mathit_textContext::E_NOTATION_E(size_t i) {
  return getToken(LATEXParser::E_NOTATION_E, i);
}

std::vector<tree::TerminalNode *> LATEXParser::Mathit_textContext::EXP_E() {
  return getTokens(LATEXParser::EXP_E);
}

tree::TerminalNode* LATEXParser::Mathit_textContext::EXP_E(size_t i) {
  return getToken(LATEXParser::EXP_E, i);
}


size_t LATEXParser::Mathit_textContext::getRuleIndex() const {
  return LATEXParser::RuleMathit_text;
}


LATEXParser::Mathit_textContext* LATEXParser::mathit_text() {
  Mathit_textContext *_localctx = _tracker.createInstance<Mathit_textContext>(_ctx, getState());
  enterRule(_localctx, 64, LATEXParser::RuleMathit_text);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(705); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(704);
      _la = _input->LA(1);
      if (!((((_la - 109) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 109)) & 7) != 0)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(707); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la - 109) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 109)) & 7) != 0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FracContext ------------------------------------------------------------------

LATEXParser::FracContext::FracContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::FracContext::CMD_FRAC() {
  return getToken(LATEXParser::CMD_FRAC, 0);
}

std::vector<tree::TerminalNode *> LATEXParser::FracContext::L_BRACE() {
  return getTokens(LATEXParser::L_BRACE);
}

tree::TerminalNode* LATEXParser::FracContext::L_BRACE(size_t i) {
  return getToken(LATEXParser::L_BRACE, i);
}

std::vector<tree::TerminalNode *> LATEXParser::FracContext::R_BRACE() {
  return getTokens(LATEXParser::R_BRACE);
}

tree::TerminalNode* LATEXParser::FracContext::R_BRACE(size_t i) {
  return getToken(LATEXParser::R_BRACE, i);
}

std::vector<LATEXParser::ExprContext *> LATEXParser::FracContext::expr() {
  return getRuleContexts<LATEXParser::ExprContext>();
}

LATEXParser::ExprContext* LATEXParser::FracContext::expr(size_t i) {
  return getRuleContext<LATEXParser::ExprContext>(i);
}


size_t LATEXParser::FracContext::getRuleIndex() const {
  return LATEXParser::RuleFrac;
}


LATEXParser::FracContext* LATEXParser::frac() {
  FracContext *_localctx = _tracker.createInstance<FracContext>(_ctx, getState());
  enterRule(_localctx, 66, LATEXParser::RuleFrac);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(709);
    match(LATEXParser::CMD_FRAC);
    setState(710);
    match(LATEXParser::L_BRACE);
    setState(711);
    antlrcpp::downCast<FracContext *>(_localctx)->upper = expr();
    setState(712);
    match(LATEXParser::R_BRACE);
    setState(713);
    match(LATEXParser::L_BRACE);
    setState(714);
    antlrcpp::downCast<FracContext *>(_localctx)->lower = expr();
    setState(715);
    match(LATEXParser::R_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinomContext ------------------------------------------------------------------

LATEXParser::BinomContext::BinomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LATEXParser::BinomContext::L_BRACE() {
  return getTokens(LATEXParser::L_BRACE);
}

tree::TerminalNode* LATEXParser::BinomContext::L_BRACE(size_t i) {
  return getToken(LATEXParser::L_BRACE, i);
}

std::vector<tree::TerminalNode *> LATEXParser::BinomContext::R_BRACE() {
  return getTokens(LATEXParser::R_BRACE);
}

tree::TerminalNode* LATEXParser::BinomContext::R_BRACE(size_t i) {
  return getToken(LATEXParser::R_BRACE, i);
}

tree::TerminalNode* LATEXParser::BinomContext::CMD_BINOM() {
  return getToken(LATEXParser::CMD_BINOM, 0);
}

tree::TerminalNode* LATEXParser::BinomContext::CMD_CHOOSE() {
  return getToken(LATEXParser::CMD_CHOOSE, 0);
}

std::vector<LATEXParser::ExprContext *> LATEXParser::BinomContext::expr() {
  return getRuleContexts<LATEXParser::ExprContext>();
}

LATEXParser::ExprContext* LATEXParser::BinomContext::expr(size_t i) {
  return getRuleContext<LATEXParser::ExprContext>(i);
}


size_t LATEXParser::BinomContext::getRuleIndex() const {
  return LATEXParser::RuleBinom;
}


LATEXParser::BinomContext* LATEXParser::binom() {
  BinomContext *_localctx = _tracker.createInstance<BinomContext>(_ctx, getState());
  enterRule(_localctx, 68, LATEXParser::RuleBinom);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(717);
    _la = _input->LA(1);
    if (!(_la == LATEXParser::CMD_BINOM

    || _la == LATEXParser::CMD_CHOOSE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(718);
    match(LATEXParser::L_BRACE);
    setState(719);
    antlrcpp::downCast<BinomContext *>(_localctx)->upper = expr();
    setState(720);
    match(LATEXParser::R_BRACE);
    setState(721);
    match(LATEXParser::L_BRACE);
    setState(722);
    antlrcpp::downCast<BinomContext *>(_localctx)->lower = expr();
    setState(723);
    match(LATEXParser::R_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_normal_functions_single_argContext ------------------------------------------------------------------

LATEXParser::Func_normal_functions_single_argContext::Func_normal_functions_single_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_LOG() {
  return getToken(LATEXParser::FUNC_LOG, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_LN() {
  return getToken(LATEXParser::FUNC_LN, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_EXP() {
  return getToken(LATEXParser::FUNC_EXP, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_SIN() {
  return getToken(LATEXParser::FUNC_SIN, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_COS() {
  return getToken(LATEXParser::FUNC_COS, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_TAN() {
  return getToken(LATEXParser::FUNC_TAN, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_CSC() {
  return getToken(LATEXParser::FUNC_CSC, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_SEC() {
  return getToken(LATEXParser::FUNC_SEC, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_COT() {
  return getToken(LATEXParser::FUNC_COT, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCSIN() {
  return getToken(LATEXParser::FUNC_ARCSIN, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCCOS() {
  return getToken(LATEXParser::FUNC_ARCCOS, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCTAN() {
  return getToken(LATEXParser::FUNC_ARCTAN, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCCSC() {
  return getToken(LATEXParser::FUNC_ARCCSC, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCSEC() {
  return getToken(LATEXParser::FUNC_ARCSEC, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCCOT() {
  return getToken(LATEXParser::FUNC_ARCCOT, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_SINH() {
  return getToken(LATEXParser::FUNC_SINH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_COSH() {
  return getToken(LATEXParser::FUNC_COSH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_TANH() {
  return getToken(LATEXParser::FUNC_TANH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARSINH() {
  return getToken(LATEXParser::FUNC_ARSINH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCOSH() {
  return getToken(LATEXParser::FUNC_ARCOSH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARTANH() {
  return getToken(LATEXParser::FUNC_ARTANH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCSINH() {
  return getToken(LATEXParser::FUNC_ARCSINH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCCOSH() {
  return getToken(LATEXParser::FUNC_ARCCOSH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_ARCTANH() {
  return getToken(LATEXParser::FUNC_ARCTANH, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_FLOOR() {
  return getToken(LATEXParser::FUNC_FLOOR, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_single_argContext::FUNC_CEIL() {
  return getToken(LATEXParser::FUNC_CEIL, 0);
}


size_t LATEXParser::Func_normal_functions_single_argContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_normal_functions_single_arg;
}


LATEXParser::Func_normal_functions_single_argContext* LATEXParser::func_normal_functions_single_arg() {
  Func_normal_functions_single_argContext *_localctx = _tracker.createInstance<Func_normal_functions_single_argContext>(_ctx, getState());
  enterRule(_localctx, 70, LATEXParser::RuleFunc_normal_functions_single_arg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(725);
    _la = _input->LA(1);
    if (!((((_la - 42) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 42)) & 412333637631) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_normal_functions_multi_argContext ------------------------------------------------------------------

LATEXParser::Func_normal_functions_multi_argContext::Func_normal_functions_multi_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Func_normal_functions_multi_argContext::FUNC_GCD() {
  return getToken(LATEXParser::FUNC_GCD, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_multi_argContext::FUNC_LCM() {
  return getToken(LATEXParser::FUNC_LCM, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_multi_argContext::FUNC_MAX() {
  return getToken(LATEXParser::FUNC_MAX, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_functions_multi_argContext::FUNC_MIN() {
  return getToken(LATEXParser::FUNC_MIN, 0);
}


size_t LATEXParser::Func_normal_functions_multi_argContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_normal_functions_multi_arg;
}


LATEXParser::Func_normal_functions_multi_argContext* LATEXParser::func_normal_functions_multi_arg() {
  Func_normal_functions_multi_argContext *_localctx = _tracker.createInstance<Func_normal_functions_multi_argContext>(_ctx, getState());
  enterRule(_localctx, 72, LATEXParser::RuleFunc_normal_functions_multi_arg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(727);
    _la = _input->LA(1);
    if (!((((_la - 77) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 77)) & 51) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_operator_names_single_argContext ------------------------------------------------------------------

LATEXParser::Func_operator_names_single_argContext::Func_operator_names_single_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Func_operator_names_single_argContext::FUNC_ARSINH_NAME() {
  return getToken(LATEXParser::FUNC_ARSINH_NAME, 0);
}

tree::TerminalNode* LATEXParser::Func_operator_names_single_argContext::FUNC_ARCOSH_NAME() {
  return getToken(LATEXParser::FUNC_ARCOSH_NAME, 0);
}

tree::TerminalNode* LATEXParser::Func_operator_names_single_argContext::FUNC_ARTANH_NAME() {
  return getToken(LATEXParser::FUNC_ARTANH_NAME, 0);
}

tree::TerminalNode* LATEXParser::Func_operator_names_single_argContext::FUNC_ARCSINH_NAME() {
  return getToken(LATEXParser::FUNC_ARCSINH_NAME, 0);
}

tree::TerminalNode* LATEXParser::Func_operator_names_single_argContext::FUNC_ARCCOSH_NAME() {
  return getToken(LATEXParser::FUNC_ARCCOSH_NAME, 0);
}

tree::TerminalNode* LATEXParser::Func_operator_names_single_argContext::FUNC_ARCTANH_NAME() {
  return getToken(LATEXParser::FUNC_ARCTANH_NAME, 0);
}

tree::TerminalNode* LATEXParser::Func_operator_names_single_argContext::FUNC_FLOOR_NAME() {
  return getToken(LATEXParser::FUNC_FLOOR_NAME, 0);
}

tree::TerminalNode* LATEXParser::Func_operator_names_single_argContext::FUNC_CEIL_NAME() {
  return getToken(LATEXParser::FUNC_CEIL_NAME, 0);
}


size_t LATEXParser::Func_operator_names_single_argContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_operator_names_single_arg;
}


LATEXParser::Func_operator_names_single_argContext* LATEXParser::func_operator_names_single_arg() {
  Func_operator_names_single_argContext *_localctx = _tracker.createInstance<Func_operator_names_single_argContext>(_ctx, getState());
  enterRule(_localctx, 74, LATEXParser::RuleFunc_operator_names_single_arg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(729);
    _la = _input->LA(1);
    if (!((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 831) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_operator_names_multi_argContext ------------------------------------------------------------------

LATEXParser::Func_operator_names_multi_argContext::Func_operator_names_multi_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Func_operator_names_multi_argContext::FUNC_GCD_NAME() {
  return getToken(LATEXParser::FUNC_GCD_NAME, 0);
}

tree::TerminalNode* LATEXParser::Func_operator_names_multi_argContext::FUNC_LCM_NAME() {
  return getToken(LATEXParser::FUNC_LCM_NAME, 0);
}


size_t LATEXParser::Func_operator_names_multi_argContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_operator_names_multi_arg;
}


LATEXParser::Func_operator_names_multi_argContext* LATEXParser::func_operator_names_multi_arg() {
  Func_operator_names_multi_argContext *_localctx = _tracker.createInstance<Func_operator_names_multi_argContext>(_ctx, getState());
  enterRule(_localctx, 76, LATEXParser::RuleFunc_operator_names_multi_arg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(731);
    _la = _input->LA(1);
    if (!(_la == LATEXParser::FUNC_GCD_NAME

    || _la == LATEXParser::FUNC_LCM_NAME)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_normal_single_argContext ------------------------------------------------------------------

LATEXParser::Func_normal_single_argContext::Func_normal_single_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Func_normal_functions_single_argContext* LATEXParser::Func_normal_single_argContext::func_normal_functions_single_arg() {
  return getRuleContext<LATEXParser::Func_normal_functions_single_argContext>(0);
}

tree::TerminalNode* LATEXParser::Func_normal_single_argContext::CMD_OPERATORNAME() {
  return getToken(LATEXParser::CMD_OPERATORNAME, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_single_argContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_single_argContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

LATEXParser::Func_operator_names_single_argContext* LATEXParser::Func_normal_single_argContext::func_operator_names_single_arg() {
  return getRuleContext<LATEXParser::Func_operator_names_single_argContext>(0);
}


size_t LATEXParser::Func_normal_single_argContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_normal_single_arg;
}


LATEXParser::Func_normal_single_argContext* LATEXParser::func_normal_single_arg() {
  Func_normal_single_argContext *_localctx = _tracker.createInstance<Func_normal_single_argContext>(_ctx, getState());
  enterRule(_localctx, 78, LATEXParser::RuleFunc_normal_single_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(739);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::FUNC_LOG:
      case LATEXParser::FUNC_LN:
      case LATEXParser::FUNC_EXP:
      case LATEXParser::FUNC_SIN:
      case LATEXParser::FUNC_COS:
      case LATEXParser::FUNC_TAN:
      case LATEXParser::FUNC_CSC:
      case LATEXParser::FUNC_SEC:
      case LATEXParser::FUNC_COT:
      case LATEXParser::FUNC_ARCSIN:
      case LATEXParser::FUNC_ARCCOS:
      case LATEXParser::FUNC_ARCTAN:
      case LATEXParser::FUNC_ARCCSC:
      case LATEXParser::FUNC_ARCSEC:
      case LATEXParser::FUNC_ARCCOT:
      case LATEXParser::FUNC_SINH:
      case LATEXParser::FUNC_COSH:
      case LATEXParser::FUNC_TANH:
      case LATEXParser::FUNC_ARSINH:
      case LATEXParser::FUNC_ARCOSH:
      case LATEXParser::FUNC_ARTANH:
      case LATEXParser::FUNC_ARCSINH:
      case LATEXParser::FUNC_ARCCOSH:
      case LATEXParser::FUNC_ARCTANH:
      case LATEXParser::FUNC_FLOOR:
      case LATEXParser::FUNC_CEIL: {
        enterOuterAlt(_localctx, 1);
        setState(733);
        func_normal_functions_single_arg();
        break;
      }

      case LATEXParser::CMD_OPERATORNAME: {
        enterOuterAlt(_localctx, 2);
        setState(734);
        match(LATEXParser::CMD_OPERATORNAME);
        setState(735);
        match(LATEXParser::L_BRACE);
        setState(736);
        antlrcpp::downCast<Func_normal_single_argContext *>(_localctx)->func_operator_name = func_operator_names_single_arg();
        setState(737);
        match(LATEXParser::R_BRACE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_normal_multi_argContext ------------------------------------------------------------------

LATEXParser::Func_normal_multi_argContext::Func_normal_multi_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Func_normal_functions_multi_argContext* LATEXParser::Func_normal_multi_argContext::func_normal_functions_multi_arg() {
  return getRuleContext<LATEXParser::Func_normal_functions_multi_argContext>(0);
}

tree::TerminalNode* LATEXParser::Func_normal_multi_argContext::CMD_OPERATORNAME() {
  return getToken(LATEXParser::CMD_OPERATORNAME, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_multi_argContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

tree::TerminalNode* LATEXParser::Func_normal_multi_argContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

LATEXParser::Func_operator_names_multi_argContext* LATEXParser::Func_normal_multi_argContext::func_operator_names_multi_arg() {
  return getRuleContext<LATEXParser::Func_operator_names_multi_argContext>(0);
}


size_t LATEXParser::Func_normal_multi_argContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_normal_multi_arg;
}


LATEXParser::Func_normal_multi_argContext* LATEXParser::func_normal_multi_arg() {
  Func_normal_multi_argContext *_localctx = _tracker.createInstance<Func_normal_multi_argContext>(_ctx, getState());
  enterRule(_localctx, 80, LATEXParser::RuleFunc_normal_multi_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(747);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::FUNC_GCD:
      case LATEXParser::FUNC_LCM:
      case LATEXParser::FUNC_MAX:
      case LATEXParser::FUNC_MIN: {
        enterOuterAlt(_localctx, 1);
        setState(741);
        func_normal_functions_multi_arg();
        break;
      }

      case LATEXParser::CMD_OPERATORNAME: {
        enterOuterAlt(_localctx, 2);
        setState(742);
        match(LATEXParser::CMD_OPERATORNAME);
        setState(743);
        match(LATEXParser::L_BRACE);
        setState(744);
        antlrcpp::downCast<Func_normal_multi_argContext *>(_localctx)->func_operator_name = func_operator_names_multi_arg();
        setState(745);
        match(LATEXParser::R_BRACE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FuncContext ------------------------------------------------------------------

LATEXParser::FuncContext::FuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Func_normal_single_argContext* LATEXParser::FuncContext::func_normal_single_arg() {
  return getRuleContext<LATEXParser::Func_normal_single_argContext>(0);
}

tree::TerminalNode* LATEXParser::FuncContext::L_PAREN() {
  return getToken(LATEXParser::L_PAREN, 0);
}

LATEXParser::Func_single_argContext* LATEXParser::FuncContext::func_single_arg() {
  return getRuleContext<LATEXParser::Func_single_argContext>(0);
}

tree::TerminalNode* LATEXParser::FuncContext::R_PAREN() {
  return getToken(LATEXParser::R_PAREN, 0);
}

LATEXParser::Func_single_arg_noparensContext* LATEXParser::FuncContext::func_single_arg_noparens() {
  return getRuleContext<LATEXParser::Func_single_arg_noparensContext>(0);
}

LATEXParser::SubexprContext* LATEXParser::FuncContext::subexpr() {
  return getRuleContext<LATEXParser::SubexprContext>(0);
}

LATEXParser::SupexprContext* LATEXParser::FuncContext::supexpr() {
  return getRuleContext<LATEXParser::SupexprContext>(0);
}

tree::TerminalNode* LATEXParser::FuncContext::L_LEFT() {
  return getToken(LATEXParser::L_LEFT, 0);
}

tree::TerminalNode* LATEXParser::FuncContext::R_RIGHT() {
  return getToken(LATEXParser::R_RIGHT, 0);
}

tree::TerminalNode* LATEXParser::FuncContext::ML_LEFT() {
  return getToken(LATEXParser::ML_LEFT, 0);
}

tree::TerminalNode* LATEXParser::FuncContext::MR_RIGHT() {
  return getToken(LATEXParser::MR_RIGHT, 0);
}

LATEXParser::Func_normal_multi_argContext* LATEXParser::FuncContext::func_normal_multi_arg() {
  return getRuleContext<LATEXParser::Func_normal_multi_argContext>(0);
}

LATEXParser::Func_multi_argContext* LATEXParser::FuncContext::func_multi_arg() {
  return getRuleContext<LATEXParser::Func_multi_argContext>(0);
}

tree::TerminalNode* LATEXParser::FuncContext::FUNC_INT() {
  return getToken(LATEXParser::FUNC_INT, 0);
}

tree::TerminalNode* LATEXParser::FuncContext::DIFFERENTIAL() {
  return getToken(LATEXParser::DIFFERENTIAL, 0);
}

LATEXParser::FracContext* LATEXParser::FuncContext::frac() {
  return getRuleContext<LATEXParser::FracContext>(0);
}

LATEXParser::AdditiveContext* LATEXParser::FuncContext::additive() {
  return getRuleContext<LATEXParser::AdditiveContext>(0);
}

tree::TerminalNode* LATEXParser::FuncContext::UNDERSCORE() {
  return getToken(LATEXParser::UNDERSCORE, 0);
}

std::vector<tree::TerminalNode *> LATEXParser::FuncContext::L_BRACE() {
  return getTokens(LATEXParser::L_BRACE);
}

tree::TerminalNode* LATEXParser::FuncContext::L_BRACE(size_t i) {
  return getToken(LATEXParser::L_BRACE, i);
}

std::vector<tree::TerminalNode *> LATEXParser::FuncContext::R_BRACE() {
  return getTokens(LATEXParser::R_BRACE);
}

tree::TerminalNode* LATEXParser::FuncContext::R_BRACE(size_t i) {
  return getToken(LATEXParser::R_BRACE, i);
}

tree::TerminalNode* LATEXParser::FuncContext::CARET() {
  return getToken(LATEXParser::CARET, 0);
}

tree::TerminalNode* LATEXParser::FuncContext::FUNC_SQRT() {
  return getToken(LATEXParser::FUNC_SQRT, 0);
}

std::vector<LATEXParser::ExprContext *> LATEXParser::FuncContext::expr() {
  return getRuleContexts<LATEXParser::ExprContext>();
}

LATEXParser::ExprContext* LATEXParser::FuncContext::expr(size_t i) {
  return getRuleContext<LATEXParser::ExprContext>(i);
}

tree::TerminalNode* LATEXParser::FuncContext::L_BRACKET() {
  return getToken(LATEXParser::L_BRACKET, 0);
}

tree::TerminalNode* LATEXParser::FuncContext::R_BRACKET() {
  return getToken(LATEXParser::R_BRACKET, 0);
}

LATEXParser::MpContext* LATEXParser::FuncContext::mp() {
  return getRuleContext<LATEXParser::MpContext>(0);
}

tree::TerminalNode* LATEXParser::FuncContext::FUNC_SUM() {
  return getToken(LATEXParser::FUNC_SUM, 0);
}

tree::TerminalNode* LATEXParser::FuncContext::FUNC_PROD() {
  return getToken(LATEXParser::FUNC_PROD, 0);
}

LATEXParser::SubeqContext* LATEXParser::FuncContext::subeq() {
  return getRuleContext<LATEXParser::SubeqContext>(0);
}

tree::TerminalNode* LATEXParser::FuncContext::FUNC_LIM() {
  return getToken(LATEXParser::FUNC_LIM, 0);
}

LATEXParser::Limit_subContext* LATEXParser::FuncContext::limit_sub() {
  return getRuleContext<LATEXParser::Limit_subContext>(0);
}

tree::TerminalNode* LATEXParser::FuncContext::EXP_E() {
  return getToken(LATEXParser::EXP_E, 0);
}


size_t LATEXParser::FuncContext::getRuleIndex() const {
  return LATEXParser::RuleFunc;
}


LATEXParser::FuncContext* LATEXParser::func() {
  FuncContext *_localctx = _tracker.createInstance<FuncContext>(_ctx, getState());
  enterRule(_localctx, 82, LATEXParser::RuleFunc);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(885);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(749);
      func_normal_single_arg();
      setState(762);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
      case 1: {
        setState(751);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::UNDERSCORE) {
          setState(750);
          subexpr();
        }
        setState(754);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::CARET) {
          setState(753);
          supexpr();
        }
        break;
      }

      case 2: {
        setState(757);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::CARET) {
          setState(756);
          supexpr();
        }
        setState(760);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::UNDERSCORE) {
          setState(759);
          subexpr();
        }
        break;
      }

      default:
        break;
      }
      setState(785);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
      case 1: {
        setState(765);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::L_LEFT) {
          setState(764);
          match(LATEXParser::L_LEFT);
        }
        setState(767);
        match(LATEXParser::L_PAREN);
        setState(768);
        func_single_arg();
        setState(770);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::R_RIGHT) {
          setState(769);
          match(LATEXParser::R_RIGHT);
        }
        setState(772);
        match(LATEXParser::R_PAREN);
        break;
      }

      case 2: {
        setState(775);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::ML_LEFT) {
          setState(774);
          match(LATEXParser::ML_LEFT);
        }
        setState(777);
        match(LATEXParser::L_PAREN);
        setState(778);
        func_single_arg();
        setState(780);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::MR_RIGHT) {
          setState(779);
          match(LATEXParser::MR_RIGHT);
        }
        setState(782);
        match(LATEXParser::R_PAREN);
        break;
      }

      case 3: {
        setState(784);
        func_single_arg_noparens();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(787);
      func_normal_multi_arg();
      setState(800);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
      case 1: {
        setState(789);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::UNDERSCORE) {
          setState(788);
          subexpr();
        }
        setState(792);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::CARET) {
          setState(791);
          supexpr();
        }
        break;
      }

      case 2: {
        setState(795);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::CARET) {
          setState(794);
          supexpr();
        }
        setState(798);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::UNDERSCORE) {
          setState(797);
          subexpr();
        }
        break;
      }

      default:
        break;
      }
      setState(822);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
      case 1: {
        setState(803);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::L_LEFT) {
          setState(802);
          match(LATEXParser::L_LEFT);
        }
        setState(805);
        match(LATEXParser::L_PAREN);
        setState(806);
        func_multi_arg();
        setState(808);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::R_RIGHT) {
          setState(807);
          match(LATEXParser::R_RIGHT);
        }
        setState(810);
        match(LATEXParser::R_PAREN);
        break;
      }

      case 2: {
        setState(813);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::ML_LEFT) {
          setState(812);
          match(LATEXParser::ML_LEFT);
        }
        setState(815);
        match(LATEXParser::L_PAREN);
        setState(816);
        func_multi_arg();
        setState(818);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LATEXParser::MR_RIGHT) {
          setState(817);
          match(LATEXParser::MR_RIGHT);
        }
        setState(820);
        match(LATEXParser::R_PAREN);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(824);
      match(LATEXParser::FUNC_INT);
      setState(845);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
      case 1: {
        setState(825);
        subexpr();
        setState(826);
        supexpr();
        break;
      }

      case 2: {
        setState(828);
        supexpr();
        setState(829);
        subexpr();
        break;
      }

      case 3: {
        setState(831);
        match(LATEXParser::UNDERSCORE);
        setState(832);
        match(LATEXParser::L_BRACE);
        setState(833);
        match(LATEXParser::R_BRACE);

        setState(835);
        match(LATEXParser::CARET);
        setState(836);
        match(LATEXParser::L_BRACE);
        setState(837);
        match(LATEXParser::R_BRACE);
        break;
      }

      case 4: {
        setState(838);
        match(LATEXParser::CARET);
        setState(839);
        match(LATEXParser::L_BRACE);
        setState(840);
        match(LATEXParser::R_BRACE);

        setState(842);
        match(LATEXParser::UNDERSCORE);
        setState(843);
        match(LATEXParser::L_BRACE);
        setState(844);
        match(LATEXParser::R_BRACE);
        break;
      }

      default:
        break;
      }
      setState(853);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
      case 1: {
        setState(848);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
        case 1: {
          setState(847);
          additive(0);
          break;
        }

        default:
          break;
        }
        setState(850);
        match(LATEXParser::DIFFERENTIAL);
        break;
      }

      case 2: {
        setState(851);
        frac();
        break;
      }

      case 3: {
        setState(852);
        additive(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(855);
      match(LATEXParser::FUNC_SQRT);
      setState(860);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == LATEXParser::L_BRACKET) {
        setState(856);
        match(LATEXParser::L_BRACKET);
        setState(857);
        antlrcpp::downCast<FuncContext *>(_localctx)->root = expr();
        setState(858);
        match(LATEXParser::R_BRACKET);
      }
      setState(862);
      match(LATEXParser::L_BRACE);
      setState(863);
      antlrcpp::downCast<FuncContext *>(_localctx)->base = expr();
      setState(864);
      match(LATEXParser::R_BRACE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(866);
      _la = _input->LA(1);
      if (!(_la == LATEXParser::FUNC_SUM

      || _la == LATEXParser::FUNC_PROD)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(873);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case LATEXParser::UNDERSCORE: {
          setState(867);
          subeq();
          setState(868);
          supexpr();
          break;
        }

        case LATEXParser::CARET: {
          setState(870);
          supexpr();
          setState(871);
          subeq();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(875);
      mp(0);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(877);
      match(LATEXParser::FUNC_LIM);
      setState(878);
      limit_sub();
      setState(879);
      mp(0);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(881);
      match(LATEXParser::EXP_E);
      setState(883);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
      case 1: {
        setState(882);
        supexpr();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgsContext ------------------------------------------------------------------

LATEXParser::ArgsContext::ArgsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::ExprContext* LATEXParser::ArgsContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::ArgsContext::COMMA() {
  return getToken(LATEXParser::COMMA, 0);
}

LATEXParser::ArgsContext* LATEXParser::ArgsContext::args() {
  return getRuleContext<LATEXParser::ArgsContext>(0);
}


size_t LATEXParser::ArgsContext::getRuleIndex() const {
  return LATEXParser::RuleArgs;
}


LATEXParser::ArgsContext* LATEXParser::args() {
  ArgsContext *_localctx = _tracker.createInstance<ArgsContext>(_ctx, getState());
  enterRule(_localctx, 84, LATEXParser::RuleArgs);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(892);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(887);
      expr();
      setState(888);
      match(LATEXParser::COMMA);
      setState(889);
      args();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(891);
      expr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Limit_subContext ------------------------------------------------------------------

LATEXParser::Limit_subContext::Limit_subContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::Limit_subContext::UNDERSCORE() {
  return getToken(LATEXParser::UNDERSCORE, 0);
}

std::vector<tree::TerminalNode *> LATEXParser::Limit_subContext::L_BRACE() {
  return getTokens(LATEXParser::L_BRACE);
}

tree::TerminalNode* LATEXParser::Limit_subContext::L_BRACE(size_t i) {
  return getToken(LATEXParser::L_BRACE, i);
}

tree::TerminalNode* LATEXParser::Limit_subContext::LIM_APPROACH_SYM() {
  return getToken(LATEXParser::LIM_APPROACH_SYM, 0);
}

LATEXParser::ExprContext* LATEXParser::Limit_subContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

std::vector<tree::TerminalNode *> LATEXParser::Limit_subContext::R_BRACE() {
  return getTokens(LATEXParser::R_BRACE);
}

tree::TerminalNode* LATEXParser::Limit_subContext::R_BRACE(size_t i) {
  return getToken(LATEXParser::R_BRACE, i);
}

tree::TerminalNode* LATEXParser::Limit_subContext::LETTER_NO_E() {
  return getToken(LATEXParser::LETTER_NO_E, 0);
}

tree::TerminalNode* LATEXParser::Limit_subContext::GREEK_CMD() {
  return getToken(LATEXParser::GREEK_CMD, 0);
}

tree::TerminalNode* LATEXParser::Limit_subContext::CARET() {
  return getToken(LATEXParser::CARET, 0);
}

tree::TerminalNode* LATEXParser::Limit_subContext::ADD() {
  return getToken(LATEXParser::ADD, 0);
}

tree::TerminalNode* LATEXParser::Limit_subContext::SUB() {
  return getToken(LATEXParser::SUB, 0);
}


size_t LATEXParser::Limit_subContext::getRuleIndex() const {
  return LATEXParser::RuleLimit_sub;
}


LATEXParser::Limit_subContext* LATEXParser::limit_sub() {
  Limit_subContext *_localctx = _tracker.createInstance<Limit_subContext>(_ctx, getState());
  enterRule(_localctx, 86, LATEXParser::RuleLimit_sub);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(894);
    match(LATEXParser::UNDERSCORE);
    setState(895);
    match(LATEXParser::L_BRACE);
    setState(896);
    _la = _input->LA(1);
    if (!(_la == LATEXParser::LETTER_NO_E

    || _la == LATEXParser::GREEK_CMD)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(897);
    match(LATEXParser::LIM_APPROACH_SYM);
    setState(898);
    expr();
    setState(903);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LATEXParser::CARET) {
      setState(899);
      match(LATEXParser::CARET);
      setState(900);
      match(LATEXParser::L_BRACE);
      setState(901);
      _la = _input->LA(1);
      if (!(_la == LATEXParser::ADD

      || _la == LATEXParser::SUB)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(902);
      match(LATEXParser::R_BRACE);
    }
    setState(905);
    match(LATEXParser::R_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_single_argContext ------------------------------------------------------------------

LATEXParser::Func_single_argContext::Func_single_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::ExprContext* LATEXParser::Func_single_argContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}


size_t LATEXParser::Func_single_argContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_single_arg;
}


LATEXParser::Func_single_argContext* LATEXParser::func_single_arg() {
  Func_single_argContext *_localctx = _tracker.createInstance<Func_single_argContext>(_ctx, getState());
  enterRule(_localctx, 88, LATEXParser::RuleFunc_single_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(907);
    expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_single_arg_noparensContext ------------------------------------------------------------------

LATEXParser::Func_single_arg_noparensContext::Func_single_arg_noparensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::Mp_nofuncContext* LATEXParser::Func_single_arg_noparensContext::mp_nofunc() {
  return getRuleContext<LATEXParser::Mp_nofuncContext>(0);
}


size_t LATEXParser::Func_single_arg_noparensContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_single_arg_noparens;
}


LATEXParser::Func_single_arg_noparensContext* LATEXParser::func_single_arg_noparens() {
  Func_single_arg_noparensContext *_localctx = _tracker.createInstance<Func_single_arg_noparensContext>(_ctx, getState());
  enterRule(_localctx, 90, LATEXParser::RuleFunc_single_arg_noparens);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(909);
    mp_nofunc(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_multi_argContext ------------------------------------------------------------------

LATEXParser::Func_multi_argContext::Func_multi_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LATEXParser::ExprContext* LATEXParser::Func_multi_argContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::Func_multi_argContext::COMMA() {
  return getToken(LATEXParser::COMMA, 0);
}

LATEXParser::Func_multi_argContext* LATEXParser::Func_multi_argContext::func_multi_arg() {
  return getRuleContext<LATEXParser::Func_multi_argContext>(0);
}


size_t LATEXParser::Func_multi_argContext::getRuleIndex() const {
  return LATEXParser::RuleFunc_multi_arg;
}


LATEXParser::Func_multi_argContext* LATEXParser::func_multi_arg() {
  Func_multi_argContext *_localctx = _tracker.createInstance<Func_multi_argContext>(_ctx, getState());
  enterRule(_localctx, 92, LATEXParser::RuleFunc_multi_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(916);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(911);
      expr();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(912);
      expr();
      setState(913);
      match(LATEXParser::COMMA);
      setState(914);
      func_multi_arg();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubexprContext ------------------------------------------------------------------

LATEXParser::SubexprContext::SubexprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::SubexprContext::UNDERSCORE() {
  return getToken(LATEXParser::UNDERSCORE, 0);
}

LATEXParser::AtomContext* LATEXParser::SubexprContext::atom() {
  return getRuleContext<LATEXParser::AtomContext>(0);
}

tree::TerminalNode* LATEXParser::SubexprContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

tree::TerminalNode* LATEXParser::SubexprContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}

LATEXParser::ExprContext* LATEXParser::SubexprContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

LATEXParser::ArgsContext* LATEXParser::SubexprContext::args() {
  return getRuleContext<LATEXParser::ArgsContext>(0);
}


size_t LATEXParser::SubexprContext::getRuleIndex() const {
  return LATEXParser::RuleSubexpr;
}


LATEXParser::SubexprContext* LATEXParser::subexpr() {
  SubexprContext *_localctx = _tracker.createInstance<SubexprContext>(_ctx, getState());
  enterRule(_localctx, 94, LATEXParser::RuleSubexpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(918);
    match(LATEXParser::UNDERSCORE);
    setState(927);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::CMD_MATHIT:
      case LATEXParser::ACCENT_OVERLINE:
      case LATEXParser::ACCENT_BAR:
      case LATEXParser::DIFFERENTIAL:
      case LATEXParser::LETTER_NO_E:
      case LATEXParser::NUMBER:
      case LATEXParser::FRACTION_NUMBER:
      case LATEXParser::SCI_NOTATION_NUMBER:
      case LATEXParser::E_NOTATION:
      case LATEXParser::PERCENT_NUMBER:
      case LATEXParser::GREEK_CMD:
      case LATEXParser::SYMBOL:
      case LATEXParser::VARIABLE: {
        setState(919);
        atom();
        break;
      }

      case LATEXParser::L_BRACE: {
        setState(920);
        match(LATEXParser::L_BRACE);
        setState(923);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
        case 1: {
          setState(921);
          expr();
          break;
        }

        case 2: {
          setState(922);
          args();
          break;
        }

        default:
          break;
        }
        setState(925);
        match(LATEXParser::R_BRACE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SupexprContext ------------------------------------------------------------------

LATEXParser::SupexprContext::SupexprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::SupexprContext::CARET() {
  return getToken(LATEXParser::CARET, 0);
}

LATEXParser::AtomContext* LATEXParser::SupexprContext::atom() {
  return getRuleContext<LATEXParser::AtomContext>(0);
}

tree::TerminalNode* LATEXParser::SupexprContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

LATEXParser::ExprContext* LATEXParser::SupexprContext::expr() {
  return getRuleContext<LATEXParser::ExprContext>(0);
}

tree::TerminalNode* LATEXParser::SupexprContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}


size_t LATEXParser::SupexprContext::getRuleIndex() const {
  return LATEXParser::RuleSupexpr;
}


LATEXParser::SupexprContext* LATEXParser::supexpr() {
  SupexprContext *_localctx = _tracker.createInstance<SupexprContext>(_ctx, getState());
  enterRule(_localctx, 96, LATEXParser::RuleSupexpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(929);
    match(LATEXParser::CARET);
    setState(935);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LATEXParser::CMD_MATHIT:
      case LATEXParser::ACCENT_OVERLINE:
      case LATEXParser::ACCENT_BAR:
      case LATEXParser::DIFFERENTIAL:
      case LATEXParser::LETTER_NO_E:
      case LATEXParser::NUMBER:
      case LATEXParser::FRACTION_NUMBER:
      case LATEXParser::SCI_NOTATION_NUMBER:
      case LATEXParser::E_NOTATION:
      case LATEXParser::PERCENT_NUMBER:
      case LATEXParser::GREEK_CMD:
      case LATEXParser::SYMBOL:
      case LATEXParser::VARIABLE: {
        setState(930);
        atom();
        break;
      }

      case LATEXParser::L_BRACE: {
        setState(931);
        match(LATEXParser::L_BRACE);
        setState(932);
        expr();
        setState(933);
        match(LATEXParser::R_BRACE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubeqContext ------------------------------------------------------------------

LATEXParser::SubeqContext::SubeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LATEXParser::SubeqContext::UNDERSCORE() {
  return getToken(LATEXParser::UNDERSCORE, 0);
}

tree::TerminalNode* LATEXParser::SubeqContext::L_BRACE() {
  return getToken(LATEXParser::L_BRACE, 0);
}

LATEXParser::EqualityContext* LATEXParser::SubeqContext::equality() {
  return getRuleContext<LATEXParser::EqualityContext>(0);
}

tree::TerminalNode* LATEXParser::SubeqContext::R_BRACE() {
  return getToken(LATEXParser::R_BRACE, 0);
}


size_t LATEXParser::SubeqContext::getRuleIndex() const {
  return LATEXParser::RuleSubeq;
}


LATEXParser::SubeqContext* LATEXParser::subeq() {
  SubeqContext *_localctx = _tracker.createInstance<SubeqContext>(_ctx, getState());
  enterRule(_localctx, 98, LATEXParser::RuleSubeq);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(937);
    match(LATEXParser::UNDERSCORE);
    setState(938);
    match(LATEXParser::L_BRACE);
    setState(939);
    equality();
    setState(940);
    match(LATEXParser::R_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool LATEXParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 4: return relationSempred(antlrcpp::downCast<RelationContext *>(context), predicateIndex);
    case 9: return additiveSempred(antlrcpp::downCast<AdditiveContext *>(context), predicateIndex);
    case 10: return mpSempred(antlrcpp::downCast<MpContext *>(context), predicateIndex);
    case 11: return mp_nofuncSempred(antlrcpp::downCast<Mp_nofuncContext *>(context), predicateIndex);
    case 20: return expSempred(antlrcpp::downCast<ExpContext *>(context), predicateIndex);
    case 21: return exp_nofuncSempred(antlrcpp::downCast<Exp_nofuncContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool LATEXParser::relationSempred(RelationContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool LATEXParser::additiveSempred(AdditiveContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool LATEXParser::mpSempred(MpContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool LATEXParser::mp_nofuncSempred(Mp_nofuncContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 3: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool LATEXParser::expSempred(ExpContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool LATEXParser::exp_nofuncSempred(Exp_nofuncContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 5: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

void LATEXParser::initialize() {
  ::antlr4::internal::call_once(latexParserOnceFlag, latexParserInitialize);
}
